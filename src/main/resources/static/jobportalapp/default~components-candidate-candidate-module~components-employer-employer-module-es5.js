function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~components-candidate-candidate-module~components-employer-employer-module"], {
  /***/
  "./node_modules/lodash/lodash.js":
  /*!***************************************!*\
    !*** ./node_modules/lodash/lodash.js ***!
    \***************************************/

  /*! no static exports found */

  /***/
  function node_modulesLodashLodashJs(module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */
    (function (module) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      /**
      * @license
      * Lodash <https://lodash.com/>
      * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
      * Released under MIT license <https://lodash.com/license>
      * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
      * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
      */


      ;
      (function () {
        /** Used as a safe reference for `undefined` in pre-ES5 environments. */
        var undefined;
        /** Used as the semantic version number. */

        var VERSION = '4.17.15';
        /** Used as the size to enable large array optimizations. */

        var LARGE_ARRAY_SIZE = 200;
        /** Error message constants. */

        var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
            FUNC_ERROR_TEXT = 'Expected a function';
        /** Used to stand-in for `undefined` hash values. */

        var HASH_UNDEFINED = '__lodash_hash_undefined__';
        /** Used as the maximum memoize cache size. */

        var MAX_MEMOIZE_SIZE = 500;
        /** Used as the internal argument placeholder. */

        var PLACEHOLDER = '__lodash_placeholder__';
        /** Used to compose bitmasks for cloning. */

        var CLONE_DEEP_FLAG = 1,
            CLONE_FLAT_FLAG = 2,
            CLONE_SYMBOLS_FLAG = 4;
        /** Used to compose bitmasks for value comparisons. */

        var COMPARE_PARTIAL_FLAG = 1,
            COMPARE_UNORDERED_FLAG = 2;
        /** Used to compose bitmasks for function metadata. */

        var WRAP_BIND_FLAG = 1,
            WRAP_BIND_KEY_FLAG = 2,
            WRAP_CURRY_BOUND_FLAG = 4,
            WRAP_CURRY_FLAG = 8,
            WRAP_CURRY_RIGHT_FLAG = 16,
            WRAP_PARTIAL_FLAG = 32,
            WRAP_PARTIAL_RIGHT_FLAG = 64,
            WRAP_ARY_FLAG = 128,
            WRAP_REARG_FLAG = 256,
            WRAP_FLIP_FLAG = 512;
        /** Used as default options for `_.truncate`. */

        var DEFAULT_TRUNC_LENGTH = 30,
            DEFAULT_TRUNC_OMISSION = '...';
        /** Used to detect hot functions by number of calls within a span of milliseconds. */

        var HOT_COUNT = 800,
            HOT_SPAN = 16;
        /** Used to indicate the type of lazy iteratees. */

        var LAZY_FILTER_FLAG = 1,
            LAZY_MAP_FLAG = 2,
            LAZY_WHILE_FLAG = 3;
        /** Used as references for various `Number` constants. */

        var INFINITY = 1 / 0,
            MAX_SAFE_INTEGER = 9007199254740991,
            MAX_INTEGER = 1.7976931348623157e+308,
            NAN = 0 / 0;
        /** Used as references for the maximum length and index of an array. */

        var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        /** Used to associate wrap methods with their bit flags. */

        var wrapFlags = [['ary', WRAP_ARY_FLAG], ['bind', WRAP_BIND_FLAG], ['bindKey', WRAP_BIND_KEY_FLAG], ['curry', WRAP_CURRY_FLAG], ['curryRight', WRAP_CURRY_RIGHT_FLAG], ['flip', WRAP_FLIP_FLAG], ['partial', WRAP_PARTIAL_FLAG], ['partialRight', WRAP_PARTIAL_RIGHT_FLAG], ['rearg', WRAP_REARG_FLAG]];
        /** `Object#toString` result references. */

        var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            asyncTag = '[object AsyncFunction]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            domExcTag = '[object DOMException]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            nullTag = '[object Null]',
            objectTag = '[object Object]',
            promiseTag = '[object Promise]',
            proxyTag = '[object Proxy]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            symbolTag = '[object Symbol]',
            undefinedTag = '[object Undefined]',
            weakMapTag = '[object WeakMap]',
            weakSetTag = '[object WeakSet]';
        var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';
        /** Used to match empty string literals in compiled template source. */

        var reEmptyStringLeading = /\b__p \+= '';/g,
            reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
            reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        /** Used to match HTML entities and HTML characters. */

        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
            reUnescapedHtml = /[&<>"']/g,
            reHasEscapedHtml = RegExp(reEscapedHtml.source),
            reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        /** Used to match template delimiters. */

        var reEscape = /<%-([\s\S]+?)%>/g,
            reEvaluate = /<%([\s\S]+?)%>/g,
            reInterpolate = /<%=([\s\S]+?)%>/g;
        /** Used to match property names within property paths. */

        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            reIsPlainProp = /^\w*$/,
            rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */

        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
            reHasRegExpChar = RegExp(reRegExpChar.source);
        /** Used to match leading and trailing whitespace. */

        var reTrim = /^\s+|\s+$/g,
            reTrimStart = /^\s+/,
            reTrimEnd = /\s+$/;
        /** Used to match wrap detail comments. */

        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
            reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
            reSplitDetails = /,? & /;
        /** Used to match words composed of alphanumeric characters. */

        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        /** Used to match backslashes in property paths. */

        var reEscapeChar = /\\(\\)?/g;
        /**
         * Used to match
         * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
         */

        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        /** Used to match `RegExp` flags from their coerced string values. */

        var reFlags = /\w*$/;
        /** Used to detect bad signed hexadecimal string values. */

        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        /** Used to detect binary string values. */

        var reIsBinary = /^0b[01]+$/i;
        /** Used to detect host constructors (Safari). */

        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        /** Used to detect octal string values. */

        var reIsOctal = /^0o[0-7]+$/i;
        /** Used to detect unsigned integer values. */

        var reIsUint = /^(?:0|[1-9]\d*)$/;
        /** Used to match Latin Unicode letters (excluding mathematical operators). */

        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        /** Used to ensure capturing order of template delimiters. */

        var reNoMatch = /($^)/;
        /** Used to match unescaped characters in compiled string literals. */

        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        /** Used to compose unicode character classes. */

        var rsAstralRange = "\\ud800-\\udfff",
            rsComboMarksRange = "\\u0300-\\u036f",
            reComboHalfMarksRange = "\\ufe20-\\ufe2f",
            rsComboSymbolsRange = "\\u20d0-\\u20ff",
            rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
            rsDingbatRange = "\\u2700-\\u27bf",
            rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
            rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
            rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
            rsPunctuationRange = "\\u2000-\\u206f",
            rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
            rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
            rsVarRange = "\\ufe0e\\ufe0f",
            rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        /** Used to compose unicode capture groups. */

        var rsApos = "['\u2019]",
            rsAstral = '[' + rsAstralRange + ']',
            rsBreak = '[' + rsBreakRange + ']',
            rsCombo = '[' + rsComboRange + ']',
            rsDigits = '\\d+',
            rsDingbat = '[' + rsDingbatRange + ']',
            rsLower = '[' + rsLowerRange + ']',
            rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
            rsFitz = "\\ud83c[\\udffb-\\udfff]",
            rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
            rsNonAstral = '[^' + rsAstralRange + ']',
            rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            rsUpper = '[' + rsUpperRange + ']',
            rsZWJ = "\\u200d";
        /** Used to compose unicode regexes. */

        var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
            rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
            rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
            rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
            reOptMod = rsModifier + '?',
            rsOptVar = '[' + rsVarRange + ']?',
            rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
            rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
            rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
            rsSeq = rsOptVar + reOptMod + rsOptJoin,
            rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
            rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
        /** Used to match apostrophes. */

        var reApos = RegExp(rsApos, 'g');
        /**
         * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
         * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
         */

        var reComboMark = RegExp(rsCombo, 'g');
        /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

        var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
        /** Used to match complex or compound words. */

        var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');
        /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

        var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
        /** Used to detect strings that need a more robust regexp to match words. */

        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        /** Used to assign default `context` object properties. */

        var contextProps = ['Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object', 'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'];
        /** Used to make template sourceURLs easier to identify. */

        var templateCounter = -1;
        /** Used to identify `toStringTag` values of typed arrays. */

        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        /** Used to identify `toStringTag` values supported by `_.clone`. */

        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        /** Used to map Latin Unicode letters to basic Latin letters. */

        var deburredLetters = {
          // Latin-1 Supplement block.
          '\xc0': 'A',
          '\xc1': 'A',
          '\xc2': 'A',
          '\xc3': 'A',
          '\xc4': 'A',
          '\xc5': 'A',
          '\xe0': 'a',
          '\xe1': 'a',
          '\xe2': 'a',
          '\xe3': 'a',
          '\xe4': 'a',
          '\xe5': 'a',
          '\xc7': 'C',
          '\xe7': 'c',
          '\xd0': 'D',
          '\xf0': 'd',
          '\xc8': 'E',
          '\xc9': 'E',
          '\xca': 'E',
          '\xcb': 'E',
          '\xe8': 'e',
          '\xe9': 'e',
          '\xea': 'e',
          '\xeb': 'e',
          '\xcc': 'I',
          '\xcd': 'I',
          '\xce': 'I',
          '\xcf': 'I',
          '\xec': 'i',
          '\xed': 'i',
          '\xee': 'i',
          '\xef': 'i',
          '\xd1': 'N',
          '\xf1': 'n',
          '\xd2': 'O',
          '\xd3': 'O',
          '\xd4': 'O',
          '\xd5': 'O',
          '\xd6': 'O',
          '\xd8': 'O',
          '\xf2': 'o',
          '\xf3': 'o',
          '\xf4': 'o',
          '\xf5': 'o',
          '\xf6': 'o',
          '\xf8': 'o',
          '\xd9': 'U',
          '\xda': 'U',
          '\xdb': 'U',
          '\xdc': 'U',
          '\xf9': 'u',
          '\xfa': 'u',
          '\xfb': 'u',
          '\xfc': 'u',
          '\xdd': 'Y',
          '\xfd': 'y',
          '\xff': 'y',
          '\xc6': 'Ae',
          '\xe6': 'ae',
          '\xde': 'Th',
          '\xfe': 'th',
          '\xdf': 'ss',
          // Latin Extended-A block.
          "\u0100": 'A',
          "\u0102": 'A',
          "\u0104": 'A',
          "\u0101": 'a',
          "\u0103": 'a',
          "\u0105": 'a',
          "\u0106": 'C',
          "\u0108": 'C',
          "\u010A": 'C',
          "\u010C": 'C',
          "\u0107": 'c',
          "\u0109": 'c',
          "\u010B": 'c',
          "\u010D": 'c',
          "\u010E": 'D',
          "\u0110": 'D',
          "\u010F": 'd',
          "\u0111": 'd',
          "\u0112": 'E',
          "\u0114": 'E',
          "\u0116": 'E',
          "\u0118": 'E',
          "\u011A": 'E',
          "\u0113": 'e',
          "\u0115": 'e',
          "\u0117": 'e',
          "\u0119": 'e',
          "\u011B": 'e',
          "\u011C": 'G',
          "\u011E": 'G',
          "\u0120": 'G',
          "\u0122": 'G',
          "\u011D": 'g',
          "\u011F": 'g',
          "\u0121": 'g',
          "\u0123": 'g',
          "\u0124": 'H',
          "\u0126": 'H',
          "\u0125": 'h',
          "\u0127": 'h',
          "\u0128": 'I',
          "\u012A": 'I',
          "\u012C": 'I',
          "\u012E": 'I',
          "\u0130": 'I',
          "\u0129": 'i',
          "\u012B": 'i',
          "\u012D": 'i',
          "\u012F": 'i',
          "\u0131": 'i',
          "\u0134": 'J',
          "\u0135": 'j',
          "\u0136": 'K',
          "\u0137": 'k',
          "\u0138": 'k',
          "\u0139": 'L',
          "\u013B": 'L',
          "\u013D": 'L',
          "\u013F": 'L',
          "\u0141": 'L',
          "\u013A": 'l',
          "\u013C": 'l',
          "\u013E": 'l',
          "\u0140": 'l',
          "\u0142": 'l',
          "\u0143": 'N',
          "\u0145": 'N',
          "\u0147": 'N',
          "\u014A": 'N',
          "\u0144": 'n',
          "\u0146": 'n',
          "\u0148": 'n',
          "\u014B": 'n',
          "\u014C": 'O',
          "\u014E": 'O',
          "\u0150": 'O',
          "\u014D": 'o',
          "\u014F": 'o',
          "\u0151": 'o',
          "\u0154": 'R',
          "\u0156": 'R',
          "\u0158": 'R',
          "\u0155": 'r',
          "\u0157": 'r',
          "\u0159": 'r',
          "\u015A": 'S',
          "\u015C": 'S',
          "\u015E": 'S',
          "\u0160": 'S',
          "\u015B": 's',
          "\u015D": 's',
          "\u015F": 's',
          "\u0161": 's',
          "\u0162": 'T',
          "\u0164": 'T',
          "\u0166": 'T',
          "\u0163": 't',
          "\u0165": 't',
          "\u0167": 't',
          "\u0168": 'U',
          "\u016A": 'U',
          "\u016C": 'U',
          "\u016E": 'U',
          "\u0170": 'U',
          "\u0172": 'U',
          "\u0169": 'u',
          "\u016B": 'u',
          "\u016D": 'u',
          "\u016F": 'u',
          "\u0171": 'u',
          "\u0173": 'u',
          "\u0174": 'W',
          "\u0175": 'w',
          "\u0176": 'Y',
          "\u0177": 'y',
          "\u0178": 'Y',
          "\u0179": 'Z',
          "\u017B": 'Z',
          "\u017D": 'Z',
          "\u017A": 'z',
          "\u017C": 'z',
          "\u017E": 'z',
          "\u0132": 'IJ',
          "\u0133": 'ij',
          "\u0152": 'Oe',
          "\u0153": 'oe',
          "\u0149": "'n",
          "\u017F": 's'
        };
        /** Used to map characters to HTML entities. */

        var htmlEscapes = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        };
        /** Used to map HTML entities to characters. */

        var htmlUnescapes = {
          '&amp;': '&',
          '&lt;': '<',
          '&gt;': '>',
          '&quot;': '"',
          '&#39;': "'"
        };
        /** Used to escape characters for inclusion in compiled string literals. */

        var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          "\u2028": 'u2028',
          "\u2029": 'u2029'
        };
        /** Built-in method references without a dependency on `root`. */

        var freeParseFloat = parseFloat,
            freeParseInt = parseInt;
        /** Detect free variable `global` from Node.js. */

        var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
        /** Detect free variable `self`. */

        var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
        /** Used as a reference to the global object. */

        var root = freeGlobal || freeSelf || Function('return this')();
        /** Detect free variable `exports`. */

        var freeExports = true && exports && !exports.nodeType && exports;
        /** Detect free variable `module`. */

        var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
        /** Detect the popular CommonJS extension `module.exports`. */

        var moduleExports = freeModule && freeModule.exports === freeExports;
        /** Detect free variable `process` from Node.js. */

        var freeProcess = moduleExports && freeGlobal.process;
        /** Used to access faster Node.js helpers. */

        var nodeUtil = function () {
          try {
            // Use `util.types` for Node.js 10+.
            var types = freeModule && freeModule.require && freeModule.require('util').types;

            if (types) {
              return types;
            } // Legacy `process.binding('util')` for Node.js < 10.


            return freeProcess && freeProcess.binding && freeProcess.binding('util');
          } catch (e) {}
        }();
        /* Node.js helper references. */


        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
            nodeIsDate = nodeUtil && nodeUtil.isDate,
            nodeIsMap = nodeUtil && nodeUtil.isMap,
            nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
            nodeIsSet = nodeUtil && nodeUtil.isSet,
            nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        /*--------------------------------------------------------------------------*/

        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */

        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);

            case 1:
              return func.call(thisArg, args[0]);

            case 2:
              return func.call(thisArg, args[0], args[1]);

            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }

          return func.apply(thisArg, args);
        }
        /**
         * A specialized version of `baseAggregator` for arrays.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform keys.
         * @param {Object} accumulator The initial aggregated object.
         * @returns {Function} Returns `accumulator`.
         */


        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1,
              length = array == null ? 0 : array.length;

          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }

          return accumulator;
        }
        /**
         * A specialized version of `_.forEach` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */


        function arrayEach(array, iteratee) {
          var index = -1,
              length = array == null ? 0 : array.length;

          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }

          return array;
        }
        /**
         * A specialized version of `_.forEachRight` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */


        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;

          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }

          return array;
        }
        /**
         * A specialized version of `_.every` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         */


        function arrayEvery(array, predicate) {
          var index = -1,
              length = array == null ? 0 : array.length;

          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }

          return true;
        }
        /**
         * A specialized version of `_.filter` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */


        function arrayFilter(array, predicate) {
          var index = -1,
              length = array == null ? 0 : array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index];

            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }

          return result;
        }
        /**
         * A specialized version of `_.includes` for arrays without support for
         * specifying an index to search from.
         *
         * @private
         * @param {Array} [array] The array to inspect.
         * @param {*} target The value to search for.
         * @returns {boolean} Returns `true` if `target` is found, else `false`.
         */


        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        /**
         * This function is like `arrayIncludes` except that it accepts a comparator.
         *
         * @private
         * @param {Array} [array] The array to inspect.
         * @param {*} target The value to search for.
         * @param {Function} comparator The comparator invoked per element.
         * @returns {boolean} Returns `true` if `target` is found, else `false`.
         */


        function arrayIncludesWith(array, value, comparator) {
          var index = -1,
              length = array == null ? 0 : array.length;

          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }

          return false;
        }
        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */


        function arrayMap(array, iteratee) {
          var index = -1,
              length = array == null ? 0 : array.length,
              result = Array(length);

          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }

          return result;
        }
        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */


        function arrayPush(array, values) {
          var index = -1,
              length = values.length,
              offset = array.length;

          while (++index < length) {
            array[offset + index] = values[index];
          }

          return array;
        }
        /**
         * A specialized version of `_.reduce` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initAccum] Specify using the first element of `array` as
         *  the initial value.
         * @returns {*} Returns the accumulated value.
         */


        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1,
              length = array == null ? 0 : array.length;

          if (initAccum && length) {
            accumulator = array[++index];
          }

          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }

          return accumulator;
        }
        /**
         * A specialized version of `_.reduceRight` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initAccum] Specify using the last element of `array` as
         *  the initial value.
         * @returns {*} Returns the accumulated value.
         */


        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;

          if (initAccum && length) {
            accumulator = array[--length];
          }

          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }

          return accumulator;
        }
        /**
         * A specialized version of `_.some` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */


        function arraySome(array, predicate) {
          var index = -1,
              length = array == null ? 0 : array.length;

          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }

          return false;
        }
        /**
         * Gets the size of an ASCII `string`.
         *
         * @private
         * @param {string} string The string inspect.
         * @returns {number} Returns the string size.
         */


        var asciiSize = baseProperty('length');
        /**
         * Converts an ASCII `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */

        function asciiToArray(string) {
          return string.split('');
        }
        /**
         * Splits an ASCII `string` into an array of its words.
         *
         * @private
         * @param {string} The string to inspect.
         * @returns {Array} Returns the words of `string`.
         */


        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        /**
         * The base implementation of methods like `_.findKey` and `_.findLastKey`,
         * without support for iteratee shorthands, which iterates over `collection`
         * using `eachFunc`.
         *
         * @private
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} predicate The function invoked per iteration.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the found element or its key, else `undefined`.
         */


        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function (value, key, collection) {
            if (predicate(value, key, collection)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        /**
         * The base implementation of `_.findIndex` and `_.findLastIndex` without
         * support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} predicate The function invoked per iteration.
         * @param {number} fromIndex The index to search from.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */


        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length,
              index = fromIndex + (fromRight ? 1 : -1);

          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }

          return -1;
        }
        /**
         * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */


        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        /**
         * This function is like `baseIndexOf` except that it accepts a comparator.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @param {Function} comparator The comparator invoked per element.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */


        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1,
              length = array.length;

          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }

          return -1;
        }
        /**
         * The base implementation of `_.isNaN` without support for number objects.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         */


        function baseIsNaN(value) {
          return value !== value;
        }
        /**
         * The base implementation of `_.mean` and `_.meanBy` without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the mean.
         */


        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new accessor function.
         */


        function baseProperty(key) {
          return function (object) {
            return object == null ? undefined : object[key];
          };
        }
        /**
         * The base implementation of `_.propertyOf` without support for deep paths.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         */


        function basePropertyOf(object) {
          return function (key) {
            return object == null ? undefined : object[key];
          };
        }
        /**
         * The base implementation of `_.reduce` and `_.reduceRight`, without support
         * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} accumulator The initial value.
         * @param {boolean} initAccum Specify using the first or last element of
         *  `collection` as the initial value.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the accumulated value.
         */


        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function (value, index, collection) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        /**
         * The base implementation of `_.sortBy` which uses `comparer` to define the
         * sort order of `array` and replaces criteria objects with their corresponding
         * values.
         *
         * @private
         * @param {Array} array The array to sort.
         * @param {Function} comparer The function to define sort order.
         * @returns {Array} Returns `array`.
         */


        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);

          while (length--) {
            array[length] = array[length].value;
          }

          return array;
        }
        /**
         * The base implementation of `_.sum` and `_.sumBy` without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the sum.
         */


        function baseSum(array, iteratee) {
          var result,
              index = -1,
              length = array.length;

          while (++index < length) {
            var current = iteratee(array[index]);

            if (current !== undefined) {
              result = result === undefined ? current : result + current;
            }
          }

          return result;
        }
        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */


        function baseTimes(n, iteratee) {
          var index = -1,
              result = Array(n);

          while (++index < n) {
            result[index] = iteratee(index);
          }

          return result;
        }
        /**
         * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
         * of key-value pairs for `object` corresponding to the property names of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the key-value pairs.
         */


        function baseToPairs(object, props) {
          return arrayMap(props, function (key) {
            return [key, object[key]];
          });
        }
        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */


        function baseUnary(func) {
          return function (value) {
            return func(value);
          };
        }
        /**
         * The base implementation of `_.values` and `_.valuesIn` which creates an
         * array of `object` property values corresponding to the property names
         * of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the array of property values.
         */


        function baseValues(object, props) {
          return arrayMap(props, function (key) {
            return object[key];
          });
        }
        /**
         * Checks if a `cache` value for `key` exists.
         *
         * @private
         * @param {Object} cache The cache to query.
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */


        function cacheHas(cache, key) {
          return cache.has(key);
        }
        /**
         * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
         * that is not found in the character symbols.
         *
         * @private
         * @param {Array} strSymbols The string symbols to inspect.
         * @param {Array} chrSymbols The character symbols to find.
         * @returns {number} Returns the index of the first unmatched string symbol.
         */


        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1,
              length = strSymbols.length;

          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}

          return index;
        }
        /**
         * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
         * that is not found in the character symbols.
         *
         * @private
         * @param {Array} strSymbols The string symbols to inspect.
         * @param {Array} chrSymbols The character symbols to find.
         * @returns {number} Returns the index of the last unmatched string symbol.
         */


        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;

          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}

          return index;
        }
        /**
         * Gets the number of `placeholder` occurrences in `array`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} placeholder The placeholder to search for.
         * @returns {number} Returns the placeholder count.
         */


        function countHolders(array, placeholder) {
          var length = array.length,
              result = 0;

          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }

          return result;
        }
        /**
         * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
         * letters to basic Latin letters.
         *
         * @private
         * @param {string} letter The matched letter to deburr.
         * @returns {string} Returns the deburred letter.
         */


        var deburrLetter = basePropertyOf(deburredLetters);
        /**
         * Used by `_.escape` to convert characters to HTML entities.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */

        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        /**
         * Used by `_.template` to escape characters for inclusion in compiled string literals.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */

        function escapeStringChar(chr) {
          return '\\' + stringEscapes[chr];
        }
        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */


        function getValue(object, key) {
          return object == null ? undefined : object[key];
        }
        /**
         * Checks if `string` contains Unicode symbols.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {boolean} Returns `true` if a symbol is found, else `false`.
         */


        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        /**
         * Checks if `string` contains a word composed of Unicode symbols.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {boolean} Returns `true` if a word is found, else `false`.
         */


        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        /**
         * Converts `iterator` to an array.
         *
         * @private
         * @param {Object} iterator The iterator to convert.
         * @returns {Array} Returns the converted array.
         */


        function iteratorToArray(iterator) {
          var data,
              result = [];

          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }

          return result;
        }
        /**
         * Converts `map` to its key-value pairs.
         *
         * @private
         * @param {Object} map The map to convert.
         * @returns {Array} Returns the key-value pairs.
         */


        function mapToArray(map) {
          var index = -1,
              result = Array(map.size);
          map.forEach(function (value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */


        function overArg(func, transform) {
          return function (arg) {
            return func(transform(arg));
          };
        }
        /**
         * Replaces all `placeholder` elements in `array` with an internal placeholder
         * and returns an array of their indexes.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {*} placeholder The placeholder to replace.
         * @returns {Array} Returns the new array of placeholder indexes.
         */


        function replaceHolders(array, placeholder) {
          var index = -1,
              length = array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index];

            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }

          return result;
        }
        /**
         * Converts `set` to an array of its values.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the values.
         */


        function setToArray(set) {
          var index = -1,
              result = Array(set.size);
          set.forEach(function (value) {
            result[++index] = value;
          });
          return result;
        }
        /**
         * Converts `set` to its value-value pairs.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the value-value pairs.
         */


        function setToPairs(set) {
          var index = -1,
              result = Array(set.size);
          set.forEach(function (value) {
            result[++index] = [value, value];
          });
          return result;
        }
        /**
         * A specialized version of `_.indexOf` which performs strict equality
         * comparisons of values, i.e. `===`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */


        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1,
              length = array.length;

          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }

          return -1;
        }
        /**
         * A specialized version of `_.lastIndexOf` which performs strict equality
         * comparisons of values, i.e. `===`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */


        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;

          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }

          return index;
        }
        /**
         * Gets the number of symbols in `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the string size.
         */


        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        /**
         * Converts `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */


        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        /**
         * Used by `_.unescape` to convert HTML entities to characters.
         *
         * @private
         * @param {string} chr The matched character to unescape.
         * @returns {string} Returns the unescaped character.
         */


        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        /**
         * Gets the size of a Unicode `string`.
         *
         * @private
         * @param {string} string The string inspect.
         * @returns {number} Returns the string size.
         */

        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;

          while (reUnicode.test(string)) {
            ++result;
          }

          return result;
        }
        /**
         * Converts a Unicode `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */


        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        /**
         * Splits a Unicode `string` into an array of its words.
         *
         * @private
         * @param {string} The string to inspect.
         * @returns {Array} Returns the words of `string`.
         */


        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        /*--------------------------------------------------------------------------*/

        /**
         * Create a new pristine `lodash` function using the `context` object.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Util
         * @param {Object} [context=root] The context object.
         * @returns {Function} Returns a new `lodash` function.
         * @example
         *
         * _.mixin({ 'foo': _.constant('foo') });
         *
         * var lodash = _.runInContext();
         * lodash.mixin({ 'bar': lodash.constant('bar') });
         *
         * _.isFunction(_.foo);
         * // => true
         * _.isFunction(_.bar);
         * // => false
         *
         * lodash.isFunction(lodash.foo);
         * // => false
         * lodash.isFunction(lodash.bar);
         * // => true
         *
         * // Create a suped-up `defer` in Node.js.
         * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
         */


        var runInContext = function runInContext(context) {
          context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
          /** Built-in constructor references. */

          var Array = context.Array,
              Date = context.Date,
              Error = context.Error,
              Function = context.Function,
              Math = context.Math,
              Object = context.Object,
              RegExp = context.RegExp,
              String = context.String,
              TypeError = context.TypeError;
          /** Used for built-in method references. */

          var arrayProto = Array.prototype,
              funcProto = Function.prototype,
              objectProto = Object.prototype;
          /** Used to detect overreaching core-js shims. */

          var coreJsData = context['__core-js_shared__'];
          /** Used to resolve the decompiled source of functions. */

          var funcToString = funcProto.toString;
          /** Used to check objects for own properties. */

          var hasOwnProperty = objectProto.hasOwnProperty;
          /** Used to generate unique IDs. */

          var idCounter = 0;
          /** Used to detect methods masquerading as native. */

          var maskSrcKey = function () {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
          }();
          /**
           * Used to resolve the
           * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
           * of values.
           */


          var nativeObjectToString = objectProto.toString;
          /** Used to infer the `Object` constructor. */

          var objectCtorString = funcToString.call(Object);
          /** Used to restore the original `_` reference in `_.noConflict`. */

          var oldDash = root._;
          /** Used to detect if a method is native. */

          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
          /** Built-in value references. */

          var Buffer = moduleExports ? context.Buffer : undefined,
              Symbol = context.Symbol,
              Uint8Array = context.Uint8Array,
              allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
              getPrototype = overArg(Object.getPrototypeOf, Object),
              objectCreate = Object.create,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              splice = arrayProto.splice,
              spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
              symIterator = Symbol ? Symbol.iterator : undefined,
              symToStringTag = Symbol ? Symbol.toStringTag : undefined;

          var defineProperty = function () {
            try {
              var func = getNative(Object, 'defineProperty');
              func({}, '', {});
              return func;
            } catch (e) {}
          }();
          /** Mocked built-ins. */


          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
              ctxNow = Date && Date.now !== root.Date.now && Date.now,
              ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          /* Built-in method references for those with the same name as other `lodash` methods. */

          var nativeCeil = Math.ceil,
              nativeFloor = Math.floor,
              nativeGetSymbols = Object.getOwnPropertySymbols,
              nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
              nativeIsFinite = context.isFinite,
              nativeJoin = arrayProto.join,
              nativeKeys = overArg(Object.keys, Object),
              nativeMax = Math.max,
              nativeMin = Math.min,
              nativeNow = Date.now,
              nativeParseInt = context.parseInt,
              nativeRandom = Math.random,
              nativeReverse = arrayProto.reverse;
          /* Built-in method references that are verified to be native. */

          var DataView = getNative(context, 'DataView'),
              Map = getNative(context, 'Map'),
              Promise = getNative(context, 'Promise'),
              Set = getNative(context, 'Set'),
              WeakMap = getNative(context, 'WeakMap'),
              nativeCreate = getNative(Object, 'create');
          /** Used to store function metadata. */

          var metaMap = WeakMap && new WeakMap();
          /** Used to lookup unminified function names. */

          var realNames = {};
          /** Used to detect maps, sets, and weakmaps. */

          var dataViewCtorString = toSource(DataView),
              mapCtorString = toSource(Map),
              promiseCtorString = toSource(Promise),
              setCtorString = toSource(Set),
              weakMapCtorString = toSource(WeakMap);
          /** Used to convert symbols to primitives and strings. */

          var symbolProto = Symbol ? Symbol.prototype : undefined,
              symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
              symbolToString = symbolProto ? symbolProto.toString : undefined;
          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` object which wraps `value` to enable implicit method
           * chain sequences. Methods that operate on and return arrays, collections,
           * and functions can be chained together. Methods that retrieve a single value
           * or may return a primitive value will automatically end the chain sequence
           * and return the unwrapped value. Otherwise, the value must be unwrapped
           * with `_#value`.
           *
           * Explicit chain sequences, which must be unwrapped with `_#value`, may be
           * enabled using `_.chain`.
           *
           * The execution of chained methods is lazy, that is, it's deferred until
           * `_#value` is implicitly or explicitly called.
           *
           * Lazy evaluation allows several methods to support shortcut fusion.
           * Shortcut fusion is an optimization to merge iteratee calls; this avoids
           * the creation of intermediate arrays and can greatly reduce the number of
           * iteratee executions. Sections of a chain sequence qualify for shortcut
           * fusion if the section is applied to an array and iteratees accept only
           * one argument. The heuristic for whether a section qualifies for shortcut
           * fusion is subject to change.
           *
           * Chaining is supported in custom builds as long as the `_#value` method is
           * directly or indirectly included in the build.
           *
           * In addition to lodash methods, wrappers have `Array` and `String` methods.
           *
           * The wrapper `Array` methods are:
           * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
           *
           * The wrapper `String` methods are:
           * `replace` and `split`
           *
           * The wrapper methods that support shortcut fusion are:
           * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
           * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
           * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
           *
           * The chainable wrapper methods are:
           * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
           * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
           * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
           * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
           * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
           * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
           * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
           * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
           * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
           * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
           * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
           * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
           * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
           * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
           * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
           * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
           * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
           * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
           * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
           * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
           * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
           * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
           * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
           * `zipObject`, `zipObjectDeep`, and `zipWith`
           *
           * The wrapper methods that are **not** chainable by default are:
           * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
           * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
           * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
           * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
           * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
           * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
           * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
           * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
           * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
           * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
           * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
           * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
           * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
           * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
           * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
           * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
           * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
           * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
           * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
           * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
           * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
           * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
           * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
           * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
           * `upperFirst`, `value`, and `words`
           *
           * @name _
           * @constructor
           * @category Seq
           * @param {*} value The value to wrap in a `lodash` instance.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var wrapped = _([1, 2, 3]);
           *
           * // Returns an unwrapped value.
           * wrapped.reduce(_.add);
           * // => 6
           *
           * // Returns a wrapped value.
           * var squares = wrapped.map(square);
           *
           * _.isArray(squares);
           * // => false
           *
           * _.isArray(squares.value());
           * // => true
           */

          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }

              if (hasOwnProperty.call(value, '__wrapped__')) {
                return wrapperClone(value);
              }
            }

            return new LodashWrapper(value);
          }
          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} proto The object to inherit from.
           * @returns {Object} Returns the new object.
           */


          var baseCreate = function () {
            function object() {}

            return function (proto) {
              if (!isObject(proto)) {
                return {};
              }

              if (objectCreate) {
                return objectCreate(proto);
              }

              object.prototype = proto;
              var result = new object();
              object.prototype = undefined;
              return result;
            };
          }();
          /**
           * The function whose prototype chain sequence wrappers inherit from.
           *
           * @private
           */


          function baseLodash() {} // No operation performed.

          /**
           * The base constructor for creating `lodash` wrapper objects.
           *
           * @private
           * @param {*} value The value to wrap.
           * @param {boolean} [chainAll] Enable explicit method chain sequences.
           */


          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined;
          }
          /**
           * By default, the template delimiters used by lodash are like those in
           * embedded Ruby (ERB) as well as ES2015 template strings. Change the
           * following template settings to use alternative delimiters.
           *
           * @static
           * @memberOf _
           * @type {Object}
           */


          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'escape': reEscape,

            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'evaluate': reEvaluate,

            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'interpolate': reInterpolate,

            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            'variable': '',

            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            'imports': {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              '_': lodash
            }
          }; // Ensure wrappers are instances of `baseLodash`.

          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          /*------------------------------------------------------------------------*/

          /**
           * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
           *
           * @private
           * @constructor
           * @param {*} value The value to wrap.
           */

          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          /**
           * Creates a clone of the lazy wrapper object.
           *
           * @private
           * @name clone
           * @memberOf LazyWrapper
           * @returns {Object} Returns the cloned `LazyWrapper` object.
           */


          function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = copyArray(this.__actions__);
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = copyArray(this.__iteratees__);
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = copyArray(this.__views__);
            return result;
          }
          /**
           * Reverses the direction of lazy iteration.
           *
           * @private
           * @name reverse
           * @memberOf LazyWrapper
           * @returns {Object} Returns the new reversed `LazyWrapper` object.
           */


          function lazyReverse() {
            if (this.__filtered__) {
              var result = new LazyWrapper(this);
              result.__dir__ = -1;
              result.__filtered__ = true;
            } else {
              result = this.clone();
              result.__dir__ *= -1;
            }

            return result;
          }
          /**
           * Extracts the unwrapped value from its lazy wrapper.
           *
           * @private
           * @name value
           * @memberOf LazyWrapper
           * @returns {*} Returns the unwrapped value.
           */


          function lazyValue() {
            var array = this.__wrapped__.value(),
                dir = this.__dir__,
                isArr = isArray(array),
                isRight = dir < 0,
                arrLength = isArr ? array.length : 0,
                view = getView(0, arrLength, this.__views__),
                start = view.start,
                end = view.end,
                length = end - start,
                index = isRight ? end : start - 1,
                iteratees = this.__iteratees__,
                iterLength = iteratees.length,
                resIndex = 0,
                takeCount = nativeMin(length, this.__takeCount__);

            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }

            var result = [];

            outer: while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1,
                  value = array[index];

              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex],
                    iteratee = data.iteratee,
                    type = data.type,
                    computed = iteratee(value);

                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }

              result[resIndex++] = value;
            }

            return result;
          } // Ensure `LazyWrapper` is an instance of `baseLodash`.


          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          /*------------------------------------------------------------------------*/

          /**
           * Creates a hash object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */

          function Hash(entries) {
            var index = -1,
                length = entries == null ? 0 : entries.length;
            this.clear();

            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
           * Removes all key-value entries from the hash.
           *
           * @private
           * @name clear
           * @memberOf Hash
           */


          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          /**
           * Removes `key` and its value from the hash.
           *
           * @private
           * @name delete
           * @memberOf Hash
           * @param {Object} hash The hash to modify.
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */


          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }
          /**
           * Gets the hash value for `key`.
           *
           * @private
           * @name get
           * @memberOf Hash
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */


          function hashGet(key) {
            var data = this.__data__;

            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }

            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }
          /**
           * Checks if a hash value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Hash
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */


          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
          }
          /**
           * Sets the hash `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Hash
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the hash instance.
           */


          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          } // Add methods to `Hash`.


          Hash.prototype.clear = hashClear;
          Hash.prototype['delete'] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          /*------------------------------------------------------------------------*/

          /**
           * Creates an list cache object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */

          function ListCache(entries) {
            var index = -1,
                length = entries == null ? 0 : entries.length;
            this.clear();

            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
           * Removes all key-value entries from the list cache.
           *
           * @private
           * @name clear
           * @memberOf ListCache
           */


          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          /**
           * Removes `key` and its value from the list cache.
           *
           * @private
           * @name delete
           * @memberOf ListCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */


          function listCacheDelete(key) {
            var data = this.__data__,
                index = assocIndexOf(data, key);

            if (index < 0) {
              return false;
            }

            var lastIndex = data.length - 1;

            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }

            --this.size;
            return true;
          }
          /**
           * Gets the list cache value for `key`.
           *
           * @private
           * @name get
           * @memberOf ListCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */


          function listCacheGet(key) {
            var data = this.__data__,
                index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }
          /**
           * Checks if a list cache value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf ListCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */


          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          /**
           * Sets the list cache `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf ListCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the list cache instance.
           */


          function listCacheSet(key, value) {
            var data = this.__data__,
                index = assocIndexOf(data, key);

            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }

            return this;
          } // Add methods to `ListCache`.


          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype['delete'] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          /*------------------------------------------------------------------------*/

          /**
           * Creates a map cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */

          function MapCache(entries) {
            var index = -1,
                length = entries == null ? 0 : entries.length;
            this.clear();

            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          /**
           * Removes all key-value entries from the map.
           *
           * @private
           * @name clear
           * @memberOf MapCache
           */


          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              'hash': new Hash(),
              'map': new (Map || ListCache)(),
              'string': new Hash()
            };
          }
          /**
           * Removes `key` and its value from the map.
           *
           * @private
           * @name delete
           * @memberOf MapCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */


          function mapCacheDelete(key) {
            var result = getMapData(this, key)['delete'](key);
            this.size -= result ? 1 : 0;
            return result;
          }
          /**
           * Gets the map value for `key`.
           *
           * @private
           * @name get
           * @memberOf MapCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */


          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          /**
           * Checks if a map value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf MapCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */


          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          /**
           * Sets the map `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf MapCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the map cache instance.
           */


          function mapCacheSet(key, value) {
            var data = getMapData(this, key),
                size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          } // Add methods to `MapCache`.


          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype['delete'] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          /*------------------------------------------------------------------------*/

          /**
           *
           * Creates an array cache object to store unique values.
           *
           * @private
           * @constructor
           * @param {Array} [values] The values to cache.
           */

          function SetCache(values) {
            var index = -1,
                length = values == null ? 0 : values.length;
            this.__data__ = new MapCache();

            while (++index < length) {
              this.add(values[index]);
            }
          }
          /**
           * Adds `value` to the array cache.
           *
           * @private
           * @name add
           * @memberOf SetCache
           * @alias push
           * @param {*} value The value to cache.
           * @returns {Object} Returns the cache instance.
           */


          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);

            return this;
          }
          /**
           * Checks if `value` is in the array cache.
           *
           * @private
           * @name has
           * @memberOf SetCache
           * @param {*} value The value to search for.
           * @returns {number} Returns `true` if `value` is found, else `false`.
           */


          function setCacheHas(value) {
            return this.__data__.has(value);
          } // Add methods to `SetCache`.


          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          /*------------------------------------------------------------------------*/

          /**
           * Creates a stack cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */

          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          /**
           * Removes all key-value entries from the stack.
           *
           * @private
           * @name clear
           * @memberOf Stack
           */


          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          /**
           * Removes `key` and its value from the stack.
           *
           * @private
           * @name delete
           * @memberOf Stack
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */


          function stackDelete(key) {
            var data = this.__data__,
                result = data['delete'](key);
            this.size = data.size;
            return result;
          }
          /**
           * Gets the stack value for `key`.
           *
           * @private
           * @name get
           * @memberOf Stack
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */


          function stackGet(key) {
            return this.__data__.get(key);
          }
          /**
           * Checks if a stack value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Stack
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */


          function stackHas(key) {
            return this.__data__.has(key);
          }
          /**
           * Sets the stack `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Stack
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the stack cache instance.
           */


          function stackSet(key, value) {
            var data = this.__data__;

            if (data instanceof ListCache) {
              var pairs = data.__data__;

              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }

              data = this.__data__ = new MapCache(pairs);
            }

            data.set(key, value);
            this.size = data.size;
            return this;
          } // Add methods to `Stack`.


          Stack.prototype.clear = stackClear;
          Stack.prototype['delete'] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of the enumerable property names of the array-like `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @param {boolean} inherited Specify returning inherited property names.
           * @returns {Array} Returns the array of property names.
           */

          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value),
                isArg = !isArr && isArguments(value),
                isBuff = !isArr && !isArg && isBuffer(value),
                isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                skipIndexes = isArr || isArg || isBuff || isType,
                result = skipIndexes ? baseTimes(value.length, String) : [],
                length = result.length;

            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
              key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
              isIndex(key, length)))) {
                result.push(key);
              }
            }

            return result;
          }
          /**
           * A specialized version of `_.sample` for arrays.
           *
           * @private
           * @param {Array} array The array to sample.
           * @returns {*} Returns the random element.
           */


          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined;
          }
          /**
           * A specialized version of `_.sampleSize` for arrays.
           *
           * @private
           * @param {Array} array The array to sample.
           * @param {number} n The number of elements to sample.
           * @returns {Array} Returns the random elements.
           */


          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }
          /**
           * A specialized version of `_.shuffle` for arrays.
           *
           * @private
           * @param {Array} array The array to shuffle.
           * @returns {Array} Returns the new shuffled array.
           */


          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          /**
           * This function is like `assignValue` except that it doesn't assign
           * `undefined` values.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */


          function assignMergeValue(object, key, value) {
            if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          /**
           * Assigns `value` to `key` of `object` if the existing value is not equivalent
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */


          function assignValue(object, key, value) {
            var objValue = object[key];

            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          /**
           * Gets the index at which the `key` is found in `array` of key-value pairs.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {*} key The key to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           */


          function assocIndexOf(array, key) {
            var length = array.length;

            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }

            return -1;
          }
          /**
           * Aggregates elements of `collection` on `accumulator` with keys transformed
           * by `iteratee` and values set by `setter`.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} setter The function to set `accumulator` values.
           * @param {Function} iteratee The iteratee to transform keys.
           * @param {Object} accumulator The initial aggregated object.
           * @returns {Function} Returns `accumulator`.
           */


          function baseAggregator(collection, setter, iteratee, accumulator) {
            baseEach(collection, function (value, key, collection) {
              setter(accumulator, value, iteratee(value), collection);
            });
            return accumulator;
          }
          /**
           * The base implementation of `_.assign` without support for multiple sources
           * or `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @returns {Object} Returns `object`.
           */


          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          /**
           * The base implementation of `_.assignIn` without support for multiple sources
           * or `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @returns {Object} Returns `object`.
           */


          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          /**
           * The base implementation of `assignValue` and `assignMergeValue` without
           * value checks.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */


          function baseAssignValue(object, key, value) {
            if (key == '__proto__' && defineProperty) {
              defineProperty(object, key, {
                'configurable': true,
                'enumerable': true,
                'value': value,
                'writable': true
              });
            } else {
              object[key] = value;
            }
          }
          /**
           * The base implementation of `_.at` without support for individual paths.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {string[]} paths The property paths to pick.
           * @returns {Array} Returns the picked elements.
           */


          function baseAt(object, paths) {
            var index = -1,
                length = paths.length,
                result = Array(length),
                skip = object == null;

            while (++index < length) {
              result[index] = skip ? undefined : get(object, paths[index]);
            }

            return result;
          }
          /**
           * The base implementation of `_.clamp` which doesn't coerce arguments.
           *
           * @private
           * @param {number} number The number to clamp.
           * @param {number} [lower] The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the clamped number.
           */


          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined) {
                number = number <= upper ? number : upper;
              }

              if (lower !== undefined) {
                number = number >= lower ? number : lower;
              }
            }

            return number;
          }
          /**
           * The base implementation of `_.clone` and `_.cloneDeep` which tracks
           * traversed objects.
           *
           * @private
           * @param {*} value The value to clone.
           * @param {boolean} bitmask The bitmask flags.
           *  1 - Deep clone
           *  2 - Flatten inherited properties
           *  4 - Clone symbols
           * @param {Function} [customizer] The function to customize cloning.
           * @param {string} [key] The key of `value`.
           * @param {Object} [object] The parent object of `value`.
           * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
           * @returns {*} Returns the cloned value.
           */


          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result,
                isDeep = bitmask & CLONE_DEEP_FLAG,
                isFlat = bitmask & CLONE_FLAT_FLAG,
                isFull = bitmask & CLONE_SYMBOLS_FLAG;

            if (customizer) {
              result = object ? customizer(value, key, object, stack) : customizer(value);
            }

            if (result !== undefined) {
              return result;
            }

            if (!isObject(value)) {
              return value;
            }

            var isArr = isArray(value);

            if (isArr) {
              result = initCloneArray(value);

              if (!isDeep) {
                return copyArray(value, result);
              }
            } else {
              var tag = getTag(value),
                  isFunc = tag == funcTag || tag == genTag;

              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }

              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result = isFlat || isFunc ? {} : initCloneObject(value);

                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }

                result = initCloneByTag(value, tag, isDeep);
              }
            } // Check for circular references and return its corresponding clone.


            stack || (stack = new Stack());
            var stacked = stack.get(value);

            if (stacked) {
              return stacked;
            }

            stack.set(value, result);

            if (isSet(value)) {
              value.forEach(function (subValue) {
                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function (subValue, key) {
                result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
              });
            }

            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined : keysFunc(value);
            arrayEach(props || value, function (subValue, key) {
              if (props) {
                key = subValue;
                subValue = value[key];
              } // Recursively populate clone (susceptible to call stack limits).


              assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
            return result;
          }
          /**
           * The base implementation of `_.conforms` which doesn't clone `source`.
           *
           * @private
           * @param {Object} source The object of property predicates to conform to.
           * @returns {Function} Returns the new spec function.
           */


          function baseConforms(source) {
            var props = keys(source);
            return function (object) {
              return baseConformsTo(object, source, props);
            };
          }
          /**
           * The base implementation of `_.conformsTo` which accepts `props` to check.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property predicates to conform to.
           * @returns {boolean} Returns `true` if `object` conforms, else `false`.
           */


          function baseConformsTo(object, source, props) {
            var length = props.length;

            if (object == null) {
              return !length;
            }

            object = Object(object);

            while (length--) {
              var key = props[length],
                  predicate = source[key],
                  value = object[key];

              if (value === undefined && !(key in object) || !predicate(value)) {
                return false;
              }
            }

            return true;
          }
          /**
           * The base implementation of `_.delay` and `_.defer` which accepts `args`
           * to provide to `func`.
           *
           * @private
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {Array} args The arguments to provide to `func`.
           * @returns {number|Object} Returns the timer id or timeout object.
           */


          function baseDelay(func, wait, args) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            return setTimeout(function () {
              func.apply(undefined, args);
            }, wait);
          }
          /**
           * The base implementation of methods like `_.difference` without support
           * for excluding multiple arrays or iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Array} values The values to exclude.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           */


          function baseDifference(array, values, iteratee, comparator) {
            var index = -1,
                includes = arrayIncludes,
                isCommon = true,
                length = array.length,
                result = [],
                valuesLength = values.length;

            if (!length) {
              return result;
            }

            if (iteratee) {
              values = arrayMap(values, baseUnary(iteratee));
            }

            if (comparator) {
              includes = arrayIncludesWith;
              isCommon = false;
            } else if (values.length >= LARGE_ARRAY_SIZE) {
              includes = cacheHas;
              isCommon = false;
              values = new SetCache(values);
            }

            outer: while (++index < length) {
              var value = array[index],
                  computed = iteratee == null ? value : iteratee(value);
              value = comparator || value !== 0 ? value : 0;

              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;

                while (valuesIndex--) {
                  if (values[valuesIndex] === computed) {
                    continue outer;
                  }
                }

                result.push(value);
              } else if (!includes(values, computed, comparator)) {
                result.push(value);
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.forEach` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           */


          var baseEach = createBaseEach(baseForOwn);
          /**
           * The base implementation of `_.forEachRight` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           */

          var baseEachRight = createBaseEach(baseForOwnRight, true);
          /**
           * The base implementation of `_.every` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`
           */

          function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function (value, index, collection) {
              result = !!predicate(value, index, collection);
              return result;
            });
            return result;
          }
          /**
           * The base implementation of methods like `_.max` and `_.min` which accepts a
           * `comparator` to determine the extremum value.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The iteratee invoked per iteration.
           * @param {Function} comparator The comparator used to compare values.
           * @returns {*} Returns the extremum value.
           */


          function baseExtremum(array, iteratee, comparator) {
            var index = -1,
                length = array.length;

            while (++index < length) {
              var value = array[index],
                  current = iteratee(value);

              if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current,
                    result = value;
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.fill` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           */


          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);

            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }

            end = end === undefined || end > length ? length : toInteger(end);

            if (end < 0) {
              end += length;
            }

            end = start > end ? 0 : toLength(end);

            while (start < end) {
              array[start++] = value;
            }

            return array;
          }
          /**
           * The base implementation of `_.filter` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           */


          function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function (value, index, collection) {
              if (predicate(value, index, collection)) {
                result.push(value);
              }
            });
            return result;
          }
          /**
           * The base implementation of `_.flatten` with support for restricting flattening.
           *
           * @private
           * @param {Array} array The array to flatten.
           * @param {number} depth The maximum recursion depth.
           * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
           * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
           * @param {Array} [result=[]] The initial result value.
           * @returns {Array} Returns the new flattened array.
           */


          function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1,
                length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);

            while (++index < length) {
              var value = array[index];

              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  // Recursively flatten arrays (susceptible to call stack limits).
                  baseFlatten(value, depth - 1, predicate, isStrict, result);
                } else {
                  arrayPush(result, value);
                }
              } else if (!isStrict) {
                result[result.length] = value;
              }
            }

            return result;
          }
          /**
           * The base implementation of `baseForOwn` which iterates over `object`
           * properties returned by `keysFunc` and invokes `iteratee` for each property.
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */


          var baseFor = createBaseFor();
          /**
           * This function is like `baseFor` except that it iterates over properties
           * in the opposite order.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */

          var baseForRight = createBaseFor(true);
          /**
           * The base implementation of `_.forOwn` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */

          function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
          }
          /**
           * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */


          function baseForOwnRight(object, iteratee) {
            return object && baseForRight(object, iteratee, keys);
          }
          /**
           * The base implementation of `_.functions` which creates an array of
           * `object` function property names filtered from `props`.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Array} props The property names to filter.
           * @returns {Array} Returns the function names.
           */


          function baseFunctions(object, props) {
            return arrayFilter(props, function (key) {
              return isFunction(object[key]);
            });
          }
          /**
           * The base implementation of `_.get` without support for default values.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @returns {*} Returns the resolved value.
           */


          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0,
                length = path.length;

            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }

            return index && index == length ? object : undefined;
          }
          /**
           * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
           * `keysFunc` and `symbolsFunc` to get the enumerable property names and
           * symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @param {Function} symbolsFunc The function to get the symbols of `object`.
           * @returns {Array} Returns the array of property names and symbols.
           */


          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
          }
          /**
           * The base implementation of `getTag` without fallbacks for buggy environments.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */


          function baseGetTag(value) {
            if (value == null) {
              return value === undefined ? undefinedTag : nullTag;
            }

            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }
          /**
           * The base implementation of `_.gt` which doesn't coerce arguments.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than `other`,
           *  else `false`.
           */


          function baseGt(value, other) {
            return value > other;
          }
          /**
           * The base implementation of `_.has` without support for deep paths.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {Array|string} key The key to check.
           * @returns {boolean} Returns `true` if `key` exists, else `false`.
           */


          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          /**
           * The base implementation of `_.hasIn` without support for deep paths.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {Array|string} key The key to check.
           * @returns {boolean} Returns `true` if `key` exists, else `false`.
           */


          function baseHasIn(object, key) {
            return object != null && key in Object(object);
          }
          /**
           * The base implementation of `_.inRange` which doesn't coerce arguments.
           *
           * @private
           * @param {number} number The number to check.
           * @param {number} start The start of the range.
           * @param {number} end The end of the range.
           * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
           */


          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          /**
           * The base implementation of methods like `_.intersection`, without support
           * for iteratee shorthands, that accepts an array of arrays to inspect.
           *
           * @private
           * @param {Array} arrays The arrays to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of shared values.
           */


          function baseIntersection(arrays, iteratee, comparator) {
            var includes = comparator ? arrayIncludesWith : arrayIncludes,
                length = arrays[0].length,
                othLength = arrays.length,
                othIndex = othLength,
                caches = Array(othLength),
                maxLength = Infinity,
                result = [];

            while (othIndex--) {
              var array = arrays[othIndex];

              if (othIndex && iteratee) {
                array = arrayMap(array, baseUnary(iteratee));
              }

              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
            }

            array = arrays[0];
            var index = -1,
                seen = caches[0];

            outer: while (++index < length && result.length < maxLength) {
              var value = array[index],
                  computed = iteratee ? iteratee(value) : value;
              value = comparator || value !== 0 ? value : 0;

              if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                othIndex = othLength;

                while (--othIndex) {
                  var cache = caches[othIndex];

                  if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }

                if (seen) {
                  seen.push(computed);
                }

                result.push(value);
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.invert` and `_.invertBy` which inverts
           * `object` with values transformed by `iteratee` and set by `setter`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} setter The function to set `accumulator` values.
           * @param {Function} iteratee The iteratee to transform values.
           * @param {Object} accumulator The initial inverted object.
           * @returns {Function} Returns `accumulator`.
           */


          function baseInverter(object, setter, iteratee, accumulator) {
            baseForOwn(object, function (value, key, object) {
              setter(accumulator, iteratee(value), key, object);
            });
            return accumulator;
          }
          /**
           * The base implementation of `_.invoke` without support for individual
           * method arguments.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the method to invoke.
           * @param {Array} args The arguments to invoke the method with.
           * @returns {*} Returns the result of the invoked method.
           */


          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined : apply(func, object, args);
          }
          /**
           * The base implementation of `_.isArguments`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           */


          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          /**
           * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
           */


          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          /**
           * The base implementation of `_.isDate` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
           */


          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          /**
           * The base implementation of `_.isEqual` which supports partial comparisons
           * and tracks traversed objects.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {boolean} bitmask The bitmask flags.
           *  1 - Unordered comparison
           *  2 - Partial comparison
           * @param {Function} [customizer] The function to customize comparisons.
           * @param {Object} [stack] Tracks traversed `value` and `other` objects.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           */


          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }

            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }

            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          /**
           * A specialized version of `baseIsEqual` for arrays and objects which performs
           * deep comparisons and tracks traversed objects enabling objects with circular
           * references to be compared.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} [stack] Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */


          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = objIsArr ? arrayTag : getTag(object),
                othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag,
                othIsObj = othTag == objectTag,
                isSameTag = objTag == othTag;

            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }

              objIsArr = true;
              objIsObj = false;
            }

            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }

            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                  othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object,
                    othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }

            if (!isSameTag) {
              return false;
            }

            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          /**
           * The base implementation of `_.isMap` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a map, else `false`.
           */


          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          /**
           * The base implementation of `_.isMatch` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @param {Array} matchData The property names, values, and compare flags to match.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           */


          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length,
                length = index,
                noCustomizer = !customizer;

            if (object == null) {
              return !length;
            }

            object = Object(object);

            while (index--) {
              var data = matchData[index];

              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }

            while (++index < length) {
              data = matchData[index];
              var key = data[0],
                  objValue = object[key],
                  srcValue = data[1];

              if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();

                if (customizer) {
                  var result = customizer(objValue, srcValue, key, object, source, stack);
                }

                if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                  return false;
                }
              }
            }

            return true;
          }
          /**
           * The base implementation of `_.isNative` without bad shim checks.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           */


          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }

            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          /**
           * The base implementation of `_.isRegExp` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
           */


          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          /**
           * The base implementation of `_.isSet` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a set, else `false`.
           */


          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          /**
           * The base implementation of `_.isTypedArray` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           */


          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          /**
           * The base implementation of `_.iteratee`.
           *
           * @private
           * @param {*} [value=_.identity] The value to convert to an iteratee.
           * @returns {Function} Returns the iteratee.
           */


          function baseIteratee(value) {
            // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
            // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
            if (typeof value == 'function') {
              return value;
            }

            if (value == null) {
              return identity;
            }

            if (typeof value == 'object') {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }

            return property(value);
          }
          /**
           * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */


          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }

            var result = [];

            for (var key in Object(object)) {
              if (hasOwnProperty.call(object, key) && key != 'constructor') {
                result.push(key);
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */


          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }

            var isProto = isPrototype(object),
                result = [];

            for (var key in object) {
              if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                result.push(key);
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.lt` which doesn't coerce arguments.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than `other`,
           *  else `false`.
           */


          function baseLt(value, other) {
            return value < other;
          }
          /**
           * The base implementation of `_.map` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           */


          function baseMap(collection, iteratee) {
            var index = -1,
                result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function (value, key, collection) {
              result[++index] = iteratee(value, key, collection);
            });
            return result;
          }
          /**
           * The base implementation of `_.matches` which doesn't clone `source`.
           *
           * @private
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new spec function.
           */


          function baseMatches(source) {
            var matchData = getMatchData(source);

            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }

            return function (object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          /**
           * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
           *
           * @private
           * @param {string} path The path of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           */


          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }

            return function (object) {
              var objValue = get(object, path);
              return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          /**
           * The base implementation of `_.merge` without support for multiple sources.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} [customizer] The function to customize merged values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */


          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }

            baseFor(source, function (srcValue, key) {
              stack || (stack = new Stack());

              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

                if (newValue === undefined) {
                  newValue = srcValue;
                }

                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          /**
           * A specialized version of `baseMerge` for arrays and objects which performs
           * deep merges and tracks traversed objects enabling objects with circular
           * references to be merged.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {string} key The key of the value to merge.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} mergeFunc The function to merge values.
           * @param {Function} [customizer] The function to customize assigned values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */


          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key),
                srcValue = safeGet(source, key),
                stacked = stack.get(srcValue);

            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }

            var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
            var isCommon = newValue === undefined;

            if (isCommon) {
              var isArr = isArray(srcValue),
                  isBuff = !isArr && isBuffer(srcValue),
                  isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;

              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;

                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }

            if (isCommon) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack['delete'](srcValue);
            }

            assignMergeValue(object, key, newValue);
          }
          /**
           * The base implementation of `_.nth` which doesn't coerce arguments.
           *
           * @private
           * @param {Array} array The array to query.
           * @param {number} n The index of the element to return.
           * @returns {*} Returns the nth element of `array`.
           */


          function baseNth(array, n) {
            var length = array.length;

            if (!length) {
              return;
            }

            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined;
          }
          /**
           * The base implementation of `_.orderBy` without param guards.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
           * @param {string[]} orders The sort orders of `iteratees`.
           * @returns {Array} Returns the new sorted array.
           */


          function baseOrderBy(collection, iteratees, orders) {
            var index = -1;
            iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
            var result = baseMap(collection, function (value, key, collection) {
              var criteria = arrayMap(iteratees, function (iteratee) {
                return iteratee(value);
              });
              return {
                'criteria': criteria,
                'index': ++index,
                'value': value
              };
            });
            return baseSortBy(result, function (object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          /**
           * The base implementation of `_.pick` without support for individual
           * property identifiers.
           *
           * @private
           * @param {Object} object The source object.
           * @param {string[]} paths The property paths to pick.
           * @returns {Object} Returns the new object.
           */


          function basePick(object, paths) {
            return basePickBy(object, paths, function (value, path) {
              return hasIn(object, path);
            });
          }
          /**
           * The base implementation of  `_.pickBy` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The source object.
           * @param {string[]} paths The property paths to pick.
           * @param {Function} predicate The function invoked per property.
           * @returns {Object} Returns the new object.
           */


          function basePickBy(object, paths, predicate) {
            var index = -1,
                length = paths.length,
                result = {};

            while (++index < length) {
              var path = paths[index],
                  value = baseGet(object, path);

              if (predicate(value, path)) {
                baseSet(result, castPath(path, object), value);
              }
            }

            return result;
          }
          /**
           * A specialized version of `baseProperty` which supports deep paths.
           *
           * @private
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new accessor function.
           */


          function basePropertyDeep(path) {
            return function (object) {
              return baseGet(object, path);
            };
          }
          /**
           * The base implementation of `_.pullAllBy` without support for iteratee
           * shorthands.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns `array`.
           */


          function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
                index = -1,
                length = values.length,
                seen = array;

            if (array === values) {
              values = copyArray(values);
            }

            if (iteratee) {
              seen = arrayMap(array, baseUnary(iteratee));
            }

            while (++index < length) {
              var fromIndex = 0,
                  value = values[index],
                  computed = iteratee ? iteratee(value) : value;

              while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }

                splice.call(array, fromIndex, 1);
              }
            }

            return array;
          }
          /**
           * The base implementation of `_.pullAt` without support for individual
           * indexes or capturing the removed elements.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {number[]} indexes The indexes of elements to remove.
           * @returns {Array} Returns `array`.
           */


          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0,
                lastIndex = length - 1;

            while (length--) {
              var index = indexes[length];

              if (length == lastIndex || index !== previous) {
                var previous = index;

                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }

            return array;
          }
          /**
           * The base implementation of `_.random` without support for returning
           * floating-point numbers.
           *
           * @private
           * @param {number} lower The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the random number.
           */


          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          /**
           * The base implementation of `_.range` and `_.rangeRight` which doesn't
           * coerce arguments.
           *
           * @private
           * @param {number} start The start of the range.
           * @param {number} end The end of the range.
           * @param {number} step The value to increment or decrement by.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Array} Returns the range of numbers.
           */


          function baseRange(start, end, step, fromRight) {
            var index = -1,
                length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                result = Array(length);

            while (length--) {
              result[fromRight ? length : ++index] = start;
              start += step;
            }

            return result;
          }
          /**
           * The base implementation of `_.repeat` which doesn't coerce arguments.
           *
           * @private
           * @param {string} string The string to repeat.
           * @param {number} n The number of times to repeat the string.
           * @returns {string} Returns the repeated string.
           */


          function baseRepeat(string, n) {
            var result = '';

            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result;
            } // Leverage the exponentiation by squaring algorithm for a faster repeat.
            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.


            do {
              if (n % 2) {
                result += string;
              }

              n = nativeFloor(n / 2);

              if (n) {
                string += string;
              }
            } while (n);

            return result;
          }
          /**
           * The base implementation of `_.rest` which doesn't validate or coerce arguments.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           */


          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + '');
          }
          /**
           * The base implementation of `_.sample`.
           *
           * @private
           * @param {Array|Object} collection The collection to sample.
           * @returns {*} Returns the random element.
           */


          function baseSample(collection) {
            return arraySample(values(collection));
          }
          /**
           * The base implementation of `_.sampleSize` without param guards.
           *
           * @private
           * @param {Array|Object} collection The collection to sample.
           * @param {number} n The number of elements to sample.
           * @returns {Array} Returns the random elements.
           */


          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          /**
           * The base implementation of `_.set`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @param {Function} [customizer] The function to customize path creation.
           * @returns {Object} Returns `object`.
           */


          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }

            path = castPath(path, object);
            var index = -1,
                length = path.length,
                lastIndex = length - 1,
                nested = object;

            while (nested != null && ++index < length) {
              var key = toKey(path[index]),
                  newValue = value;

              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined;

                if (newValue === undefined) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }

              assignValue(nested, key, newValue);
              nested = nested[key];
            }

            return object;
          }
          /**
           * The base implementation of `setData` without support for hot loop shorting.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */


          var baseSetData = !metaMap ? identity : function (func, data) {
            metaMap.set(func, data);
            return func;
          };
          /**
           * The base implementation of `setToString` without support for hot loop shorting.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */

          var baseSetToString = !defineProperty ? identity : function (func, string) {
            return defineProperty(func, 'toString', {
              'configurable': true,
              'enumerable': false,
              'value': constant(string),
              'writable': true
            });
          };
          /**
           * The base implementation of `_.shuffle`.
           *
           * @private
           * @param {Array|Object} collection The collection to shuffle.
           * @returns {Array} Returns the new shuffled array.
           */

          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          /**
           * The base implementation of `_.slice` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */


          function baseSlice(array, start, end) {
            var index = -1,
                length = array.length;

            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }

            end = end > length ? length : end;

            if (end < 0) {
              end += length;
            }

            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);

            while (++index < length) {
              result[index] = array[index + start];
            }

            return result;
          }
          /**
           * The base implementation of `_.some` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           */


          function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function (value, index, collection) {
              result = predicate(value, index, collection);
              return !result;
            });
            return !!result;
          }
          /**
           * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
           * performs a binary search of `array` to determine the index at which `value`
           * should be inserted into `array` in order to maintain its sort order.
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */


          function baseSortedIndex(array, value, retHighest) {
            var low = 0,
                high = array == null ? low : array.length;

            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1,
                    computed = array[mid];

                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }

              return high;
            }

            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          /**
           * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
           * which invokes `iteratee` for `value` and each element of `array` to compute
           * their sort ranking. The iteratee is invoked with one argument; (value).
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} iteratee The iteratee invoked per element.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */


          function baseSortedIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);
            var low = 0,
                high = array == null ? 0 : array.length,
                valIsNaN = value !== value,
                valIsNull = value === null,
                valIsSymbol = isSymbol(value),
                valIsUndefined = value === undefined;

            while (low < high) {
              var mid = nativeFloor((low + high) / 2),
                  computed = iteratee(array[mid]),
                  othIsDefined = computed !== undefined,
                  othIsNull = computed === null,
                  othIsReflexive = computed === computed,
                  othIsSymbol = isSymbol(computed);

              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }

              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }

            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          /**
           * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
           * support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           */


          function baseSortedUniq(array, iteratee) {
            var index = -1,
                length = array.length,
                resIndex = 0,
                result = [];

            while (++index < length) {
              var value = array[index],
                  computed = iteratee ? iteratee(value) : value;

              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result[resIndex++] = value === 0 ? 0 : value;
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.toNumber` which doesn't ensure correct
           * conversions of binary, hexadecimal, or octal string values.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {number} Returns the number.
           */


          function baseToNumber(value) {
            if (typeof value == 'number') {
              return value;
            }

            if (isSymbol(value)) {
              return NAN;
            }

            return +value;
          }
          /**
           * The base implementation of `_.toString` which doesn't convert nullish
           * values to empty strings.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {string} Returns the string.
           */


          function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == 'string') {
              return value;
            }

            if (isArray(value)) {
              // Recursively convert values (susceptible to call stack limits).
              return arrayMap(value, baseToString) + '';
            }

            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : '';
            }

            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
          }
          /**
           * The base implementation of `_.uniqBy` without support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           */


          function baseUniq(array, iteratee, comparator) {
            var index = -1,
                includes = arrayIncludes,
                length = array.length,
                isCommon = true,
                result = [],
                seen = result;

            if (comparator) {
              isCommon = false;
              includes = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set = iteratee ? null : createSet(array);

              if (set) {
                return setToArray(set);
              }

              isCommon = false;
              includes = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee ? [] : result;
            }

            outer: while (++index < length) {
              var value = array[index],
                  computed = iteratee ? iteratee(value) : value;
              value = comparator || value !== 0 ? value : 0;

              if (isCommon && computed === computed) {
                var seenIndex = seen.length;

                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }

                if (iteratee) {
                  seen.push(computed);
                }

                result.push(value);
              } else if (!includes(seen, computed, comparator)) {
                if (seen !== result) {
                  seen.push(computed);
                }

                result.push(value);
              }
            }

            return result;
          }
          /**
           * The base implementation of `_.unset`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The property path to unset.
           * @returns {boolean} Returns `true` if the property is deleted, else `false`.
           */


          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          /**
           * The base implementation of `_.update`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to update.
           * @param {Function} updater The function to produce the updated value.
           * @param {Function} [customizer] The function to customize path creation.
           * @returns {Object} Returns `object`.
           */


          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          /**
           * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
           * without support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to query.
           * @param {Function} predicate The function invoked per iteration.
           * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Array} Returns the slice of `array`.
           */


          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length,
                index = fromRight ? length : -1;

            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}

            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          /**
           * The base implementation of `wrapperValue` which returns the result of
           * performing a sequence of actions on the unwrapped `value`, where each
           * successive action is supplied the return value of the previous.
           *
           * @private
           * @param {*} value The unwrapped value.
           * @param {Array} actions Actions to perform to resolve the unwrapped value.
           * @returns {*} Returns the resolved value.
           */


          function baseWrapperValue(value, actions) {
            var result = value;

            if (result instanceof LazyWrapper) {
              result = result.value();
            }

            return arrayReduce(actions, function (result, action) {
              return action.func.apply(action.thisArg, arrayPush([result], action.args));
            }, result);
          }
          /**
           * The base implementation of methods like `_.xor`, without support for
           * iteratee shorthands, that accepts an array of arrays to inspect.
           *
           * @private
           * @param {Array} arrays The arrays to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of values.
           */


          function baseXor(arrays, iteratee, comparator) {
            var length = arrays.length;

            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }

            var index = -1,
                result = Array(length);

            while (++index < length) {
              var array = arrays[index],
                  othIndex = -1;

              while (++othIndex < length) {
                if (othIndex != index) {
                  result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
                }
              }
            }

            return baseUniq(baseFlatten(result, 1), iteratee, comparator);
          }
          /**
           * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
           *
           * @private
           * @param {Array} props The property identifiers.
           * @param {Array} values The property values.
           * @param {Function} assignFunc The function to assign values.
           * @returns {Object} Returns the new object.
           */


          function baseZipObject(props, values, assignFunc) {
            var index = -1,
                length = props.length,
                valsLength = values.length,
                result = {};

            while (++index < length) {
              var value = index < valsLength ? values[index] : undefined;
              assignFunc(result, props[index], value);
            }

            return result;
          }
          /**
           * Casts `value` to an empty array if it's not an array like object.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {Array|Object} Returns the cast array-like object.
           */


          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          /**
           * Casts `value` to `identity` if it's not a function.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {Function} Returns cast function.
           */


          function castFunction(value) {
            return typeof value == 'function' ? value : identity;
          }
          /**
           * Casts `value` to a path array if it's not one.
           *
           * @private
           * @param {*} value The value to inspect.
           * @param {Object} [object] The object to query keys on.
           * @returns {Array} Returns the cast property path array.
           */


          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }

            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          /**
           * A `baseRest` alias which can be replaced with `identity` by module
           * replacement plugins.
           *
           * @private
           * @type {Function}
           * @param {Function} func The function to apply a rest parameter to.
           * @returns {Function} Returns the new function.
           */


          var castRest = baseRest;
          /**
           * Casts `array` to a slice if it's needed.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {number} start The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the cast slice.
           */

          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          /**
           * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
           *
           * @private
           * @param {number|Object} id The timer id or timeout object of the timer to clear.
           */


          var clearTimeout = ctxClearTimeout || function (id) {
            return root.clearTimeout(id);
          };
          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */


          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }

            var length = buffer.length,
                result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
          }
          /**
           * Creates a clone of `arrayBuffer`.
           *
           * @private
           * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
           * @returns {ArrayBuffer} Returns the cloned array buffer.
           */


          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
          }
          /**
           * Creates a clone of `dataView`.
           *
           * @private
           * @param {Object} dataView The data view to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned data view.
           */


          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          /**
           * Creates a clone of `regexp`.
           *
           * @private
           * @param {Object} regexp The regexp to clone.
           * @returns {Object} Returns the cloned regexp.
           */


          function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
          }
          /**
           * Creates a clone of the `symbol` object.
           *
           * @private
           * @param {Object} symbol The symbol object to clone.
           * @returns {Object} Returns the cloned symbol object.
           */


          function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
          }
          /**
           * Creates a clone of `typedArray`.
           *
           * @private
           * @param {Object} typedArray The typed array to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned typed array.
           */


          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          /**
           * Compares values to sort them in ascending order.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {number} Returns the sort order indicator for `value`.
           */


          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined,
                  valIsNull = value === null,
                  valIsReflexive = value === value,
                  valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined,
                  othIsNull = other === null,
                  othIsReflexive = other === other,
                  othIsSymbol = isSymbol(other);

              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }

              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }

            return 0;
          }
          /**
           * Used by `_.orderBy` to compare multiple properties of a value to another
           * and stable sort them.
           *
           * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
           * specify an order of "desc" for descending or "asc" for ascending sort order
           * of corresponding values.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {boolean[]|string[]} orders The order to sort by for each property.
           * @returns {number} Returns the sort order indicator for `object`.
           */


          function compareMultiple(object, other, orders) {
            var index = -1,
                objCriteria = object.criteria,
                othCriteria = other.criteria,
                length = objCriteria.length,
                ordersLength = orders.length;

            while (++index < length) {
              var result = compareAscending(objCriteria[index], othCriteria[index]);

              if (result) {
                if (index >= ordersLength) {
                  return result;
                }

                var order = orders[index];
                return result * (order == 'desc' ? -1 : 1);
              }
            } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
            // that causes it, under certain circumstances, to provide the same value for
            // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
            // for more details.
            //
            // This also ensures a stable sort in V8 and other engines.
            // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


            return object.index - other.index;
          }
          /**
           * Creates an array that is the composition of partially applied arguments,
           * placeholders, and provided arguments into a single array of arguments.
           *
           * @private
           * @param {Array} args The provided arguments.
           * @param {Array} partials The arguments to prepend to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @params {boolean} [isCurried] Specify composing for a curried function.
           * @returns {Array} Returns the new array of composed arguments.
           */


          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1,
                argsLength = args.length,
                holdersLength = holders.length,
                leftIndex = -1,
                leftLength = partials.length,
                rangeLength = nativeMax(argsLength - holdersLength, 0),
                result = Array(leftLength + rangeLength),
                isUncurried = !isCurried;

            while (++leftIndex < leftLength) {
              result[leftIndex] = partials[leftIndex];
            }

            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result[holders[argsIndex]] = args[argsIndex];
              }
            }

            while (rangeLength--) {
              result[leftIndex++] = args[argsIndex++];
            }

            return result;
          }
          /**
           * This function is like `composeArgs` except that the arguments composition
           * is tailored for `_.partialRight`.
           *
           * @private
           * @param {Array} args The provided arguments.
           * @param {Array} partials The arguments to append to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @params {boolean} [isCurried] Specify composing for a curried function.
           * @returns {Array} Returns the new array of composed arguments.
           */


          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1,
                argsLength = args.length,
                holdersIndex = -1,
                holdersLength = holders.length,
                rightIndex = -1,
                rightLength = partials.length,
                rangeLength = nativeMax(argsLength - holdersLength, 0),
                result = Array(rangeLength + rightLength),
                isUncurried = !isCurried;

            while (++argsIndex < rangeLength) {
              result[argsIndex] = args[argsIndex];
            }

            var offset = argsIndex;

            while (++rightIndex < rightLength) {
              result[offset + rightIndex] = partials[rightIndex];
            }

            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }

            return result;
          }
          /**
           * Copies the values of `source` to `array`.
           *
           * @private
           * @param {Array} source The array to copy values from.
           * @param {Array} [array=[]] The array to copy values to.
           * @returns {Array} Returns `array`.
           */


          function copyArray(source, array) {
            var index = -1,
                length = source.length;
            array || (array = Array(length));

            while (++index < length) {
              array[index] = source[index];
            }

            return array;
          }
          /**
           * Copies properties of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy properties from.
           * @param {Array} props The property identifiers to copy.
           * @param {Object} [object={}] The object to copy properties to.
           * @param {Function} [customizer] The function to customize copied values.
           * @returns {Object} Returns `object`.
           */


          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1,
                length = props.length;

            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

              if (newValue === undefined) {
                newValue = source[key];
              }

              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }

            return object;
          }
          /**
           * Copies own symbols of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy symbols from.
           * @param {Object} [object={}] The object to copy symbols to.
           * @returns {Object} Returns `object`.
           */


          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          /**
           * Copies own and inherited symbols of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy symbols from.
           * @param {Object} [object={}] The object to copy symbols to.
           * @returns {Object} Returns `object`.
           */


          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          /**
           * Creates a function like `_.groupBy`.
           *
           * @private
           * @param {Function} setter The function to set accumulator values.
           * @param {Function} [initializer] The accumulator object initializer.
           * @returns {Function} Returns the new aggregator function.
           */


          function createAggregator(setter, initializer) {
            return function (collection, iteratee) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator,
                  accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee, 2), accumulator);
            };
          }
          /**
           * Creates a function like `_.assign`.
           *
           * @private
           * @param {Function} assigner The function to assign values.
           * @returns {Function} Returns the new assigner function.
           */


          function createAssigner(assigner) {
            return baseRest(function (object, sources) {
              var index = -1,
                  length = sources.length,
                  customizer = length > 1 ? sources[length - 1] : undefined,
                  guard = length > 2 ? sources[2] : undefined;
              customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }

              object = Object(object);

              while (++index < length) {
                var source = sources[index];

                if (source) {
                  assigner(object, source, index, customizer);
                }
              }

              return object;
            });
          }
          /**
           * Creates a `baseEach` or `baseEachRight` function.
           *
           * @private
           * @param {Function} eachFunc The function to iterate over a collection.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */


          function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
              if (collection == null) {
                return collection;
              }

              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee);
              }

              var length = collection.length,
                  index = fromRight ? length : -1,
                  iterable = Object(collection);

              while (fromRight ? index-- : ++index < length) {
                if (iteratee(iterable[index], index, iterable) === false) {
                  break;
                }
              }

              return collection;
            };
          }
          /**
           * Creates a base function for methods like `_.forIn` and `_.forOwn`.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */


          function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
              var index = -1,
                  iterable = Object(object),
                  props = keysFunc(object),
                  length = props.length;

              while (length--) {
                var key = props[fromRight ? length : ++index];

                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }

              return object;
            };
          }
          /**
           * Creates a function that wraps `func` to invoke it with the optional `this`
           * binding of `thisArg`.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @returns {Function} Returns the new wrapped function.
           */


          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG,
                Ctor = createCtor(func);

            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }

            return wrapper;
          }
          /**
           * Creates a function like `_.lowerFirst`.
           *
           * @private
           * @param {string} methodName The name of the `String` case method to use.
           * @returns {Function} Returns the new case function.
           */


          function createCaseFirst(methodName) {
            return function (string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          /**
           * Creates a function like `_.camelCase`.
           *
           * @private
           * @param {Function} callback The function to combine each word.
           * @returns {Function} Returns the new compounder function.
           */


          function createCompounder(callback) {
            return function (string) {
              return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
            };
          }
          /**
           * Creates a function that produces an instance of `Ctor` regardless of
           * whether it was invoked as part of a `new` expression or by `call` or `apply`.
           *
           * @private
           * @param {Function} Ctor The constructor to wrap.
           * @returns {Function} Returns the new wrapped function.
           */


          function createCtor(Ctor) {
            return function () {
              // Use a `switch` statement to work with class constructors. See
              // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
              // for more details.
              var args = arguments;

              switch (args.length) {
                case 0:
                  return new Ctor();

                case 1:
                  return new Ctor(args[0]);

                case 2:
                  return new Ctor(args[0], args[1]);

                case 3:
                  return new Ctor(args[0], args[1], args[2]);

                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);

                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);

                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }

              var thisBinding = baseCreate(Ctor.prototype),
                  result = Ctor.apply(thisBinding, args); // Mimic the constructor's `return` behavior.
              // See https://es5.github.io/#x13.2.2 for more details.

              return isObject(result) ? result : thisBinding;
            };
          }
          /**
           * Creates a function that wraps `func` to enable currying.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {number} arity The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */


          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);

            function wrapper() {
              var length = arguments.length,
                  args = Array(length),
                  index = length,
                  placeholder = getHolder(wrapper);

              while (index--) {
                args[index] = arguments[index];
              }

              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;

              if (length < arity) {
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
              }

              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }

            return wrapper;
          }
          /**
           * Creates a `_.find` or `_.findLast` function.
           *
           * @private
           * @param {Function} findIndexFunc The function to find the collection index.
           * @returns {Function} Returns the new find function.
           */


          function createFind(findIndexFunc) {
            return function (collection, predicate, fromIndex) {
              var iterable = Object(collection);

              if (!isArrayLike(collection)) {
                var iteratee = getIteratee(predicate, 3);
                collection = keys(collection);

                predicate = function predicate(key) {
                  return iteratee(iterable[key], key, iterable);
                };
              }

              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
            };
          }
          /**
           * Creates a `_.flow` or `_.flowRight` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new flow function.
           */


          function createFlow(fromRight) {
            return flatRest(function (funcs) {
              var length = funcs.length,
                  index = length,
                  prereq = LodashWrapper.prototype.thru;

              if (fromRight) {
                funcs.reverse();
              }

              while (index--) {
                var func = funcs[index];

                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }

                if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                  var wrapper = new LodashWrapper([], true);
                }
              }

              index = wrapper ? index : length;

              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func),
                    data = funcName == 'wrapper' ? getData(func) : undefined;

                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }

              return function () {
                var args = arguments,
                    value = args[0];

                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }

                var index = 0,
                    result = length ? funcs[index].apply(this, args) : value;

                while (++index < length) {
                  result = funcs[index].call(this, result);
                }

                return result;
              };
            });
          }
          /**
           * Creates a function that wraps `func` to invoke it with optional `this`
           * binding of `thisArg`, partial application, and currying.
           *
           * @private
           * @param {Function|string} func The function or method name to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to prepend to those provided to
           *  the new function.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [partialsRight] The arguments to append to those provided
           *  to the new function.
           * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */


          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG,
                isBind = bitmask & WRAP_BIND_FLAG,
                isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
                isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
                isFlip = bitmask & WRAP_FLIP_FLAG,
                Ctor = isBindKey ? undefined : createCtor(func);

            function wrapper() {
              var length = arguments.length,
                  args = Array(length),
                  index = length;

              while (index--) {
                args[index] = arguments[index];
              }

              if (isCurried) {
                var placeholder = getHolder(wrapper),
                    holdersCount = countHolders(args, placeholder);
              }

              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }

              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }

              length -= holdersCount;

              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
              }

              var thisBinding = isBind ? thisArg : this,
                  fn = isBindKey ? thisBinding[func] : func;
              length = args.length;

              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }

              if (isAry && ary < length) {
                args.length = ary;
              }

              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }

              return fn.apply(thisBinding, args);
            }

            return wrapper;
          }
          /**
           * Creates a function like `_.invertBy`.
           *
           * @private
           * @param {Function} setter The function to set accumulator values.
           * @param {Function} toIteratee The function to resolve iteratees.
           * @returns {Function} Returns the new inverter function.
           */


          function createInverter(setter, toIteratee) {
            return function (object, iteratee) {
              return baseInverter(object, setter, toIteratee(iteratee), {});
            };
          }
          /**
           * Creates a function that performs a mathematical operation on two values.
           *
           * @private
           * @param {Function} operator The function to perform the operation.
           * @param {number} [defaultValue] The value used for `undefined` arguments.
           * @returns {Function} Returns the new mathematical operation function.
           */


          function createMathOperation(operator, defaultValue) {
            return function (value, other) {
              var result;

              if (value === undefined && other === undefined) {
                return defaultValue;
              }

              if (value !== undefined) {
                result = value;
              }

              if (other !== undefined) {
                if (result === undefined) {
                  return other;
                }

                if (typeof value == 'string' || typeof other == 'string') {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }

                result = operator(value, other);
              }

              return result;
            };
          }
          /**
           * Creates a function like `_.over`.
           *
           * @private
           * @param {Function} arrayFunc The function to iterate over iteratees.
           * @returns {Function} Returns the new over function.
           */


          function createOver(arrayFunc) {
            return flatRest(function (iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function (args) {
                var thisArg = this;
                return arrayFunc(iteratees, function (iteratee) {
                  return apply(iteratee, thisArg, args);
                });
              });
            });
          }
          /**
           * Creates the padding for `string` based on `length`. The `chars` string
           * is truncated if the number of characters exceeds `length`.
           *
           * @private
           * @param {number} length The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padding for `string`.
           */


          function createPadding(length, chars) {
            chars = chars === undefined ? ' ' : baseToString(chars);
            var charsLength = chars.length;

            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }

            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
          }
          /**
           * Creates a function that wraps `func` to invoke it with the `this` binding
           * of `thisArg` and `partials` prepended to the arguments it receives.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {Array} partials The arguments to prepend to those provided to
           *  the new function.
           * @returns {Function} Returns the new wrapped function.
           */


          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG,
                Ctor = createCtor(func);

            function wrapper() {
              var argsIndex = -1,
                  argsLength = arguments.length,
                  leftIndex = -1,
                  leftLength = partials.length,
                  args = Array(leftLength + argsLength),
                  fn = this && this !== root && this instanceof wrapper ? Ctor : func;

              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }

              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }

              return apply(fn, isBind ? thisArg : this, args);
            }

            return wrapper;
          }
          /**
           * Creates a `_.range` or `_.rangeRight` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new range function.
           */


          function createRange(fromRight) {
            return function (start, end, step) {
              if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                end = step = undefined;
              } // Ensure the sign of `-0` is preserved.


              start = toFinite(start);

              if (end === undefined) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }

              step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          /**
           * Creates a function that performs a relational operation on two values.
           *
           * @private
           * @param {Function} operator The function to perform the operation.
           * @returns {Function} Returns the new relational operation function.
           */


          function createRelationalOperation(operator) {
            return function (value, other) {
              if (!(typeof value == 'string' && typeof other == 'string')) {
                value = toNumber(value);
                other = toNumber(other);
              }

              return operator(value, other);
            };
          }
          /**
           * Creates a function that wraps `func` to continue currying.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {Function} wrapFunc The function to create the `func` wrapper.
           * @param {*} placeholder The placeholder value.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to prepend to those provided to
           *  the new function.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */


          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG,
                newHolders = isCurry ? holders : undefined,
                newHoldersRight = isCurry ? undefined : holders,
                newPartials = isCurry ? partials : undefined,
                newPartialsRight = isCurry ? undefined : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }

            var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];
            var result = wrapFunc.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }

            result.placeholder = placeholder;
            return setWrapToString(result, func, bitmask);
          }
          /**
           * Creates a function like `_.round`.
           *
           * @private
           * @param {string} methodName The name of the `Math` method to use when rounding.
           * @returns {Function} Returns the new round function.
           */


          function createRound(methodName) {
            var func = Math[methodName];
            return function (number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);

              if (precision && nativeIsFinite(number)) {
                // Shift with exponential notation to avoid floating-point issues.
                // See [MDN](https://mdn.io/round#Examples) for more details.
                var pair = (toString(number) + 'e').split('e'),
                    value = func(pair[0] + 'e' + (+pair[1] + precision));
                pair = (toString(value) + 'e').split('e');
                return +(pair[0] + 'e' + (+pair[1] - precision));
              }

              return func(number);
            };
          }
          /**
           * Creates a set object of `values`.
           *
           * @private
           * @param {Array} values The values to add to the set.
           * @returns {Object} Returns the new set.
           */


          var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
            return new Set(values);
          };
          /**
           * Creates a `_.toPairs` or `_.toPairsIn` function.
           *
           * @private
           * @param {Function} keysFunc The function to get the keys of a given object.
           * @returns {Function} Returns the new pairs function.
           */

          function createToPairs(keysFunc) {
            return function (object) {
              var tag = getTag(object);

              if (tag == mapTag) {
                return mapToArray(object);
              }

              if (tag == setTag) {
                return setToPairs(object);
              }

              return baseToPairs(object, keysFunc(object));
            };
          }
          /**
           * Creates a function that either curries or invokes `func` with optional
           * `this` binding and partially applied arguments.
           *
           * @private
           * @param {Function|string} func The function or method name to wrap.
           * @param {number} bitmask The bitmask flags.
           *    1 - `_.bind`
           *    2 - `_.bindKey`
           *    4 - `_.curry` or `_.curryRight` of a bound function
           *    8 - `_.curry`
           *   16 - `_.curryRight`
           *   32 - `_.partial`
           *   64 - `_.partialRight`
           *  128 - `_.rearg`
           *  256 - `_.ary`
           *  512 - `_.flip`
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to be partially applied.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */


          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;

            if (!isBindKey && typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            var length = partials ? partials.length : 0;

            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined;
            }

            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
            arity = arity === undefined ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;

            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials,
                  holdersRight = holders;
              partials = holders = undefined;
            }

            var data = isBindKey ? undefined : getData(func);
            var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

            if (data) {
              mergeData(newData, data);
            }

            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);

            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }

            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result = createPartial(func, bitmask, thisArg, partials);
            } else {
              result = createHybrid.apply(undefined, newData);
            }

            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result, newData), func, bitmask);
          }
          /**
           * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
           * of source objects to the destination object for all destination properties
           * that resolve to `undefined`.
           *
           * @private
           * @param {*} objValue The destination value.
           * @param {*} srcValue The source value.
           * @param {string} key The key of the property to assign.
           * @param {Object} object The parent object of `objValue`.
           * @returns {*} Returns the value to assign.
           */


          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }

            return objValue;
          }
          /**
           * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
           * objects into destination objects that are passed thru.
           *
           * @private
           * @param {*} objValue The destination value.
           * @param {*} srcValue The source value.
           * @param {string} key The key of the property to merge.
           * @param {Object} object The parent object of `objValue`.
           * @param {Object} source The parent object of `srcValue`.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           * @returns {*} Returns the value to assign.
           */


          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
              stack['delete'](srcValue);
            }

            return objValue;
          }
          /**
           * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
           * objects.
           *
           * @private
           * @param {*} value The value to inspect.
           * @param {string} key The key of the property to inspect.
           * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
           */


          function customOmitClone(value) {
            return isPlainObject(value) ? undefined : value;
          }
          /**
           * A specialized version of `baseIsEqualDeep` for arrays with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Array} array The array to compare.
           * @param {Array} other The other array to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `array` and `other` objects.
           * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
           */


          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                arrLength = array.length,
                othLength = other.length;

            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            } // Assume cyclic values are equal.


            var stacked = stack.get(array);

            if (stacked && stack.get(other)) {
              return stacked == other;
            }

            var index = -1,
                result = true,
                seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
            stack.set(array, other);
            stack.set(other, array); // Ignore non-index properties.

            while (++index < arrLength) {
              var arrValue = array[index],
                  othValue = other[index];

              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }

              if (compared !== undefined) {
                if (compared) {
                  continue;
                }

                result = false;
                break;
              } // Recursively compare arrays (susceptible to call stack limits).


              if (seen) {
                if (!arraySome(other, function (othValue, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result = false;
                break;
              }
            }

            stack['delete'](array);
            stack['delete'](other);
            return result;
          }
          /**
           * A specialized version of `baseIsEqualDeep` for comparing objects of
           * the same `toStringTag`.
           *
           * **Note:** This function only supports comparing values with tags of
           * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {string} tag The `toStringTag` of the objects to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */


          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }

                object = object.buffer;
                other = other.buffer;

              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                  return false;
                }

                return true;

              case boolTag:
              case dateTag:
              case numberTag:
                // Coerce booleans to `1` or `0` and dates to milliseconds.
                // Invalid dates are coerced to `NaN`.
                return eq(+object, +other);

              case errorTag:
                return object.name == other.name && object.message == other.message;

              case regexpTag:
              case stringTag:
                // Coerce regexes to strings and treat strings, primitives and objects,
                // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                // for more details.
                return object == other + '';

              case mapTag:
                var convert = mapToArray;

              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);

                if (object.size != other.size && !isPartial) {
                  return false;
                } // Assume cyclic values are equal.


                var stacked = stack.get(object);

                if (stacked) {
                  return stacked == other;
                }

                bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

                stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack['delete'](object);
                return result;

              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }

            }

            return false;
          }
          /**
           * A specialized version of `baseIsEqualDeep` for objects with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */


          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                objProps = getAllKeys(object),
                objLength = objProps.length,
                othProps = getAllKeys(other),
                othLength = othProps.length;

            if (objLength != othLength && !isPartial) {
              return false;
            }

            var index = objLength;

            while (index--) {
              var key = objProps[index];

              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            } // Assume cyclic values are equal.


            var stacked = stack.get(object);

            if (stacked && stack.get(other)) {
              return stacked == other;
            }

            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;

            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key],
                  othValue = other[key];

              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              } // Recursively compare objects (susceptible to call stack limits).


              if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result = false;
                break;
              }

              skipCtor || (skipCtor = key == 'constructor');
            }

            if (result && !skipCtor) {
              var objCtor = object.constructor,
                  othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

              if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                result = false;
              }
            }

            stack['delete'](object);
            stack['delete'](other);
            return result;
          }
          /**
           * A specialized version of `baseRest` which flattens the rest array.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @returns {Function} Returns the new function.
           */


          function flatRest(func) {
            return setToString(overRest(func, undefined, flatten), func + '');
          }
          /**
           * Creates an array of own enumerable property names and symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names and symbols.
           */


          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          /**
           * Creates an array of own and inherited enumerable property names and
           * symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names and symbols.
           */


          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          /**
           * Gets metadata for `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {*} Returns the metadata for `func`.
           */


          var getData = !metaMap ? noop : function (func) {
            return metaMap.get(func);
          };
          /**
           * Gets the name of `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {string} Returns the function name.
           */

          function getFuncName(func) {
            var result = func.name + '',
                array = realNames[result],
                length = hasOwnProperty.call(realNames, result) ? array.length : 0;

            while (length--) {
              var data = array[length],
                  otherFunc = data.func;

              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }

            return result;
          }
          /**
           * Gets the argument placeholder value for `func`.
           *
           * @private
           * @param {Function} func The function to inspect.
           * @returns {*} Returns the placeholder value.
           */


          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
            return object.placeholder;
          }
          /**
           * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
           * this function returns the custom method, otherwise it returns `baseIteratee`.
           * If arguments are provided, the chosen function is invoked with them and
           * its result is returned.
           *
           * @private
           * @param {*} [value] The value to convert to an iteratee.
           * @param {number} [arity] The arity of the created iteratee.
           * @returns {Function} Returns the chosen function or its result.
           */


          function getIteratee() {
            var result = lodash.iteratee || iteratee;
            result = result === iteratee ? baseIteratee : result;
            return arguments.length ? result(arguments[0], arguments[1]) : result;
          }
          /**
           * Gets the data for `map`.
           *
           * @private
           * @param {Object} map The map to query.
           * @param {string} key The reference key.
           * @returns {*} Returns the map data.
           */


          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
          }
          /**
           * Gets the property names, values, and compare flags of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the match data of `object`.
           */


          function getMatchData(object) {
            var result = keys(object),
                length = result.length;

            while (length--) {
              var key = result[length],
                  value = object[key];
              result[length] = [key, value, isStrictComparable(value)];
            }

            return result;
          }
          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */


          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }
          /**
           * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the raw `toStringTag`.
           */


          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag),
                tag = value[symToStringTag];

            try {
              value[symToStringTag] = undefined;
              var unmasked = true;
            } catch (e) {}

            var result = nativeObjectToString.call(value);

            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }

            return result;
          }
          /**
           * Creates an array of the own enumerable symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of symbols.
           */


          var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
            if (object == null) {
              return [];
            }

            object = Object(object);
            return arrayFilter(nativeGetSymbols(object), function (symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          /**
           * Creates an array of the own and inherited enumerable symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of symbols.
           */

          var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
            var result = [];

            while (object) {
              arrayPush(result, getSymbols(object));
              object = getPrototype(object);
            }

            return result;
          };
          /**
           * Gets the `toStringTag` of `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */

          var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
            getTag = function getTag(value) {
              var result = baseGetTag(value),
                  Ctor = result == objectTag ? value.constructor : undefined,
                  ctorString = Ctor ? toSource(Ctor) : '';

              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;

                  case mapCtorString:
                    return mapTag;

                  case promiseCtorString:
                    return promiseTag;

                  case setCtorString:
                    return setTag;

                  case weakMapCtorString:
                    return weakMapTag;
                }
              }

              return result;
            };
          }
          /**
           * Gets the view, applying any `transforms` to the `start` and `end` positions.
           *
           * @private
           * @param {number} start The start of the view.
           * @param {number} end The end of the view.
           * @param {Array} transforms The transformations to apply to the view.
           * @returns {Object} Returns an object containing the `start` and `end`
           *  positions of the view.
           */


          function getView(start, end, transforms) {
            var index = -1,
                length = transforms.length;

            while (++index < length) {
              var data = transforms[index],
                  size = data.size;

              switch (data.type) {
                case 'drop':
                  start += size;
                  break;

                case 'dropRight':
                  end -= size;
                  break;

                case 'take':
                  end = nativeMin(end, start + size);
                  break;

                case 'takeRight':
                  start = nativeMax(start, end - size);
                  break;
              }
            }

            return {
              'start': start,
              'end': end
            };
          }
          /**
           * Extracts wrapper details from the `source` body comment.
           *
           * @private
           * @param {string} source The source to inspect.
           * @returns {Array} Returns the wrapper details.
           */


          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          /**
           * Checks if `path` exists on `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @param {Function} hasFunc The function to check properties.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           */


          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1,
                length = path.length,
                result = false;

            while (++index < length) {
              var key = toKey(path[index]);

              if (!(result = object != null && hasFunc(object, key))) {
                break;
              }

              object = object[key];
            }

            if (result || ++index != length) {
              return result;
            }

            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          /**
           * Initializes an array clone.
           *
           * @private
           * @param {Array} array The array to clone.
           * @returns {Array} Returns the initialized clone.
           */


          function initCloneArray(array) {
            var length = array.length,
                result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
              result.index = array.index;
              result.input = array.input;
            }

            return result;
          }
          /**
           * Initializes an object clone.
           *
           * @private
           * @param {Object} object The object to clone.
           * @returns {Object} Returns the initialized clone.
           */


          function initCloneObject(object) {
            return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          /**
           * Initializes an object clone based on its `toStringTag`.
           *
           * **Note:** This function only supports cloning values with tags of
           * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
           *
           * @private
           * @param {Object} object The object to clone.
           * @param {string} tag The `toStringTag` of the object to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the initialized clone.
           */


          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;

            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);

              case boolTag:
              case dateTag:
                return new Ctor(+object);

              case dataViewTag:
                return cloneDataView(object, isDeep);

              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);

              case mapTag:
                return new Ctor();

              case numberTag:
              case stringTag:
                return new Ctor(object);

              case regexpTag:
                return cloneRegExp(object);

              case setTag:
                return new Ctor();

              case symbolTag:
                return cloneSymbol(object);
            }
          }
          /**
           * Inserts wrapper `details` in a comment at the top of the `source` body.
           *
           * @private
           * @param {string} source The source to modify.
           * @returns {Array} details The details to insert.
           * @returns {string} Returns the modified source.
           */


          function insertWrapDetails(source, details) {
            var length = details.length;

            if (!length) {
              return source;
            }

            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
            details = details.join(length > 2 ? ', ' : ' ');
            return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
          }
          /**
           * Checks if `value` is a flattenable `arguments` object or array.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
           */


          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          /**
           * Checks if `value` is a valid array-like index.
           *
           * @private
           * @param {*} value The value to check.
           * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
           * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
           */


          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
          }
          /**
           * Checks if the given arguments are from an iteratee call.
           *
           * @private
           * @param {*} value The potential iteratee value argument.
           * @param {*} index The potential iteratee index or key argument.
           * @param {*} object The potential iteratee object argument.
           * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
           *  else `false`.
           */


          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }

            var type = typeof index;

            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
              return eq(object[index], value);
            }

            return false;
          }
          /**
           * Checks if `value` is a property name and not a property path.
           *
           * @private
           * @param {*} value The value to check.
           * @param {Object} [object] The object to query keys on.
           * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
           */


          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }

            var type = typeof value;

            if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
              return true;
            }

            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
          }
          /**
           * Checks if `value` is suitable for use as unique object key.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
           */


          function isKeyable(value) {
            var type = typeof value;
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
          }
          /**
           * Checks if `func` has a lazy counterpart.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
           *  else `false`.
           */


          function isLaziable(func) {
            var funcName = getFuncName(func),
                other = lodash[funcName];

            if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
              return false;
            }

            if (func === other) {
              return true;
            }

            var data = getData(other);
            return !!data && func === data[0];
          }
          /**
           * Checks if `func` has its source masked.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` is masked, else `false`.
           */


          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          /**
           * Checks if `func` is capable of being masked.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
           */


          var isMaskable = coreJsData ? isFunction : stubFalse;
          /**
           * Checks if `value` is likely a prototype object.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
           */

          function isPrototype(value) {
            var Ctor = value && value.constructor,
                proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
            return value === proto;
          }
          /**
           * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` if suitable for strict
           *  equality comparisons, else `false`.
           */


          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          /**
           * A specialized version of `matchesProperty` for source values suitable
           * for strict equality comparisons, i.e. `===`.
           *
           * @private
           * @param {string} key The key of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           */


          function matchesStrictComparable(key, srcValue) {
            return function (object) {
              if (object == null) {
                return false;
              }

              return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
            };
          }
          /**
           * A specialized version of `_.memoize` which clears the memoized function's
           * cache when it exceeds `MAX_MEMOIZE_SIZE`.
           *
           * @private
           * @param {Function} func The function to have its output memoized.
           * @returns {Function} Returns the new memoized function.
           */


          function memoizeCapped(func) {
            var result = memoize(func, function (key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }

              return key;
            });
            var cache = result.cache;
            return result;
          }
          /**
           * Merges the function metadata of `source` into `data`.
           *
           * Merging metadata reduces the number of wrappers used to invoke a function.
           * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
           * may be applied regardless of execution order. Methods like `_.ary` and
           * `_.rearg` modify function arguments, making the order in which they are
           * executed important, preventing the merging of metadata. However, we make
           * an exception for a safe combined case where curried functions have `_.ary`
           * and or `_.rearg` applied.
           *
           * @private
           * @param {Array} data The destination metadata.
           * @param {Array} source The source metadata.
           * @returns {Array} Returns `data`.
           */


          function mergeData(data, source) {
            var bitmask = data[1],
                srcBitmask = source[1],
                newBitmask = bitmask | srcBitmask,
                isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG; // Exit early if metadata can't be merged.

            if (!(isCommon || isCombo)) {
              return data;
            } // Use source `thisArg` if available.


            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2]; // Set when currying a bound function.

              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            } // Compose partial arguments.


            var value = source[3];

            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            } // Compose partial right arguments.


            value = source[5];

            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            } // Use source `argPos` if available.


            value = source[7];

            if (value) {
              data[7] = value;
            } // Use source `ary` if it's smaller.


            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            } // Use source `arity` if one is not provided.


            if (data[9] == null) {
              data[9] = source[9];
            } // Use source `func` and merge bitmasks.


            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          /**
           * This function is like
           * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * except that it includes inherited enumerable properties.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */


          function nativeKeysIn(object) {
            var result = [];

            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }

            return result;
          }
          /**
           * Converts `value` to a string using `Object.prototype.toString`.
           *
           * @private
           * @param {*} value The value to convert.
           * @returns {string} Returns the converted string.
           */


          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          /**
           * A specialized version of `baseRest` which transforms the rest array.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @param {Function} transform The rest array transform.
           * @returns {Function} Returns the new function.
           */


          function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function () {
              var args = arguments,
                  index = -1,
                  length = nativeMax(args.length - start, 0),
                  array = Array(length);

              while (++index < length) {
                array[index] = args[start + index];
              }

              index = -1;
              var otherArgs = Array(start + 1);

              while (++index < start) {
                otherArgs[index] = args[index];
              }

              otherArgs[start] = transform(array);
              return apply(func, this, otherArgs);
            };
          }
          /**
           * Gets the parent value at `path` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array} path The path to get the parent value of.
           * @returns {*} Returns the parent value.
           */


          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          /**
           * Reorder `array` according to the specified indexes where the element at
           * the first index is assigned as the first element, the element at
           * the second index is assigned as the second element, and so on.
           *
           * @private
           * @param {Array} array The array to reorder.
           * @param {Array} indexes The arranged array indexes.
           * @returns {Array} Returns `array`.
           */


          function reorder(array, indexes) {
            var arrLength = array.length,
                length = nativeMin(indexes.length, arrLength),
                oldArray = copyArray(array);

            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }

            return array;
          }
          /**
           * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */


          function safeGet(object, key) {
            if (key === 'constructor' && typeof object[key] === 'function') {
              return;
            }

            if (key == '__proto__') {
              return;
            }

            return object[key];
          }
          /**
           * Sets metadata for `func`.
           *
           * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
           * period of time, it will trip its breaker and transition to an identity
           * function to avoid garbage collection pauses in V8. See
           * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
           * for more details.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */


          var setData = shortOut(baseSetData);
          /**
           * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
           *
           * @private
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @returns {number|Object} Returns the timer id or timeout object.
           */

          var setTimeout = ctxSetTimeout || function (func, wait) {
            return root.setTimeout(func, wait);
          };
          /**
           * Sets the `toString` method of `func` to return `string`.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */


          var setToString = shortOut(baseSetToString);
          /**
           * Sets the `toString` method of `wrapper` to mimic the source of `reference`
           * with wrapper details in a comment at the top of the source body.
           *
           * @private
           * @param {Function} wrapper The function to modify.
           * @param {Function} reference The reference function.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @returns {Function} Returns `wrapper`.
           */

          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + '';
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          /**
           * Creates a function that'll short out and invoke `identity` instead
           * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
           * milliseconds.
           *
           * @private
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new shortable function.
           */


          function shortOut(func) {
            var count = 0,
                lastCalled = 0;
            return function () {
              var stamp = nativeNow(),
                  remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;

              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }

              return func.apply(undefined, arguments);
            };
          }
          /**
           * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
           *
           * @private
           * @param {Array} array The array to shuffle.
           * @param {number} [size=array.length] The size of `array`.
           * @returns {Array} Returns `array`.
           */


          function shuffleSelf(array, size) {
            var index = -1,
                length = array.length,
                lastIndex = length - 1;
            size = size === undefined ? length : size;

            while (++index < size) {
              var rand = baseRandom(index, lastIndex),
                  value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }

            array.length = size;
            return array;
          }
          /**
           * Converts `string` to a property path array.
           *
           * @private
           * @param {string} string The string to convert.
           * @returns {Array} Returns the property path array.
           */


          var stringToPath = memoizeCapped(function (string) {
            var result = [];

            if (string.charCodeAt(0) === 46
            /* . */
            ) {
                result.push('');
              }

            string.replace(rePropName, function (match, number, quote, subString) {
              result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
            });
            return result;
          });
          /**
           * Converts `value` to a string key if it's not a string or symbol.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {string|symbol} Returns the key.
           */

          function toKey(value) {
            if (typeof value == 'string' || isSymbol(value)) {
              return value;
            }

            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
          }
          /**
           * Converts `func` to its source code.
           *
           * @private
           * @param {Function} func The function to convert.
           * @returns {string} Returns the source code.
           */


          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {}

              try {
                return func + '';
              } catch (e) {}
            }

            return '';
          }
          /**
           * Updates wrapper `details` based on `bitmask` flags.
           *
           * @private
           * @returns {Array} details The details to modify.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @returns {Array} Returns `details`.
           */


          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function (pair) {
              var value = '_.' + pair[0];

              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          /**
           * Creates a clone of `wrapper`.
           *
           * @private
           * @param {Object} wrapper The wrapper to clone.
           * @returns {Object} Returns the cloned wrapper.
           */


          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }

            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result.__actions__ = copyArray(wrapper.__actions__);
            result.__index__ = wrapper.__index__;
            result.__values__ = wrapper.__values__;
            return result;
          }
          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of elements split into groups the length of `size`.
           * If `array` can't be split evenly, the final chunk will be the remaining
           * elements.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to process.
           * @param {number} [size=1] The length of each chunk
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the new array of chunks.
           * @example
           *
           * _.chunk(['a', 'b', 'c', 'd'], 2);
           * // => [['a', 'b'], ['c', 'd']]
           *
           * _.chunk(['a', 'b', 'c', 'd'], 3);
           * // => [['a', 'b', 'c'], ['d']]
           */


          function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
              size = 1;
            } else {
              size = nativeMax(toInteger(size), 0);
            }

            var length = array == null ? 0 : array.length;

            if (!length || size < 1) {
              return [];
            }

            var index = 0,
                resIndex = 0,
                result = Array(nativeCeil(length / size));

            while (index < length) {
              result[resIndex++] = baseSlice(array, index, index += size);
            }

            return result;
          }
          /**
           * Creates an array with all falsey values removed. The values `false`, `null`,
           * `0`, `""`, `undefined`, and `NaN` are falsey.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to compact.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.compact([0, 1, false, 2, '', 3]);
           * // => [1, 2, 3]
           */


          function compact(array) {
            var index = -1,
                length = array == null ? 0 : array.length,
                resIndex = 0,
                result = [];

            while (++index < length) {
              var value = array[index];

              if (value) {
                result[resIndex++] = value;
              }
            }

            return result;
          }
          /**
           * Creates a new array concatenating `array` with any additional arrays
           * and/or values.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to concatenate.
           * @param {...*} [values] The values to concatenate.
           * @returns {Array} Returns the new concatenated array.
           * @example
           *
           * var array = [1];
           * var other = _.concat(array, 2, [3], [[4]]);
           *
           * console.log(other);
           * // => [1, 2, 3, [4]]
           *
           * console.log(array);
           * // => [1]
           */


          function concat() {
            var length = arguments.length;

            if (!length) {
              return [];
            }

            var args = Array(length - 1),
                array = arguments[0],
                index = length;

            while (index--) {
              args[index - 1] = arguments[index];
            }

            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          /**
           * Creates an array of `array` values not included in the other given arrays
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. The order and references of result values are
           * determined by the first array.
           *
           * **Note:** Unlike `_.pullAll`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.without, _.xor
           * @example
           *
           * _.difference([2, 1], [2, 3]);
           * // => [1]
           */


          var difference = baseRest(function (array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
          });
          /**
           * This method is like `_.difference` except that it accepts `iteratee` which
           * is invoked for each element of `array` and `values` to generate the criterion
           * by which they're compared. The order and references of result values are
           * determined by the first array. The iteratee is invoked with one argument:
           * (value).
           *
           * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
           * // => [{ 'x': 2 }]
           */

          var differenceBy = baseRest(function (array, values) {
            var iteratee = last(values);

            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined;
            }

            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
          });
          /**
           * This method is like `_.difference` except that it accepts `comparator`
           * which is invoked to compare elements of `array` to `values`. The order and
           * references of result values are determined by the first array. The comparator
           * is invoked with two arguments: (arrVal, othVal).
           *
           * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           *
           * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
           * // => [{ 'x': 2, 'y': 1 }]
           */

          var differenceWith = baseRest(function (array, values) {
            var comparator = last(values);

            if (isArrayLikeObject(comparator)) {
              comparator = undefined;
            }

            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
          });
          /**
           * Creates a slice of `array` with `n` elements dropped from the beginning.
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.drop([1, 2, 3]);
           * // => [2, 3]
           *
           * _.drop([1, 2, 3], 2);
           * // => [3]
           *
           * _.drop([1, 2, 3], 5);
           * // => []
           *
           * _.drop([1, 2, 3], 0);
           * // => [1, 2, 3]
           */

          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          /**
           * Creates a slice of `array` with `n` elements dropped from the end.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.dropRight([1, 2, 3]);
           * // => [1, 2]
           *
           * _.dropRight([1, 2, 3], 2);
           * // => [1]
           *
           * _.dropRight([1, 2, 3], 5);
           * // => []
           *
           * _.dropRight([1, 2, 3], 0);
           * // => [1, 2, 3]
           */


          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          /**
           * Creates a slice of `array` excluding elements dropped from the end.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.dropRightWhile(users, function(o) { return !o.active; });
           * // => objects for ['barney']
           *
           * // The `_.matches` iteratee shorthand.
           * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
           * // => objects for ['barney', 'fred']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.dropRightWhile(users, ['active', false]);
           * // => objects for ['barney']
           *
           * // The `_.property` iteratee shorthand.
           * _.dropRightWhile(users, 'active');
           * // => objects for ['barney', 'fred', 'pebbles']
           */


          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          /**
           * Creates a slice of `array` excluding elements dropped from the beginning.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.dropWhile(users, function(o) { return !o.active; });
           * // => objects for ['pebbles']
           *
           * // The `_.matches` iteratee shorthand.
           * _.dropWhile(users, { 'user': 'barney', 'active': false });
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.dropWhile(users, ['active', false]);
           * // => objects for ['pebbles']
           *
           * // The `_.property` iteratee shorthand.
           * _.dropWhile(users, 'active');
           * // => objects for ['barney', 'fred', 'pebbles']
           */


          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          /**
           * Fills elements of `array` with `value` from `start` up to, but not
           * including, `end`.
           *
           * **Note:** This method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Array
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _.fill(array, 'a');
           * console.log(array);
           * // => ['a', 'a', 'a']
           *
           * _.fill(Array(3), 2);
           * // => [2, 2, 2]
           *
           * _.fill([4, 6, 8, 10], '*', 1, 3);
           * // => [4, '*', '*', 10]
           */


          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }

            return baseFill(array, value, start, end);
          }
          /**
           * This method is like `_.find` except that it returns the index of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.findIndex(users, function(o) { return o.user == 'barney'; });
           * // => 0
           *
           * // The `_.matches` iteratee shorthand.
           * _.findIndex(users, { 'user': 'fred', 'active': false });
           * // => 1
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findIndex(users, ['active', false]);
           * // => 0
           *
           * // The `_.property` iteratee shorthand.
           * _.findIndex(users, 'active');
           * // => 2
           */


          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return -1;
            }

            var index = fromIndex == null ? 0 : toInteger(fromIndex);

            if (index < 0) {
              index = nativeMax(length + index, 0);
            }

            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          /**
           * This method is like `_.findIndex` except that it iterates over elements
           * of `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=array.length-1] The index to search from.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
           * // => 2
           *
           * // The `_.matches` iteratee shorthand.
           * _.findLastIndex(users, { 'user': 'barney', 'active': true });
           * // => 0
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findLastIndex(users, ['active', false]);
           * // => 2
           *
           * // The `_.property` iteratee shorthand.
           * _.findLastIndex(users, 'active');
           * // => 0
           */


          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return -1;
            }

            var index = length - 1;

            if (fromIndex !== undefined) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }

            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          /**
           * Flattens `array` a single level deep.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flatten([1, [2, [3, [4]], 5]]);
           * // => [1, 2, [3, [4]], 5]
           */


          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          /**
           * Recursively flattens `array`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flattenDeep([1, [2, [3, [4]], 5]]);
           * // => [1, 2, 3, 4, 5]
           */


          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          /**
           * Recursively flatten `array` up to `depth` times.
           *
           * @static
           * @memberOf _
           * @since 4.4.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @param {number} [depth=1] The maximum recursion depth.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * var array = [1, [2, [3, [4]], 5]];
           *
           * _.flattenDepth(array, 1);
           * // => [1, 2, [3, [4]], 5]
           *
           * _.flattenDepth(array, 2);
           * // => [1, 2, 3, [4], 5]
           */


          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          /**
           * The inverse of `_.toPairs`; this method returns an object composed
           * from key-value `pairs`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} pairs The key-value pairs.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.fromPairs([['a', 1], ['b', 2]]);
           * // => { 'a': 1, 'b': 2 }
           */


          function fromPairs(pairs) {
            var index = -1,
                length = pairs == null ? 0 : pairs.length,
                result = {};

            while (++index < length) {
              var pair = pairs[index];
              result[pair[0]] = pair[1];
            }

            return result;
          }
          /**
           * Gets the first element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @alias first
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the first element of `array`.
           * @example
           *
           * _.head([1, 2, 3]);
           * // => 1
           *
           * _.head([]);
           * // => undefined
           */


          function head(array) {
            return array && array.length ? array[0] : undefined;
          }
          /**
           * Gets the index at which the first occurrence of `value` is found in `array`
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. If `fromIndex` is negative, it's used as the
           * offset from the end of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.indexOf([1, 2, 1, 2], 2);
           * // => 1
           *
           * // Search from the `fromIndex`.
           * _.indexOf([1, 2, 1, 2], 2, 2);
           * // => 3
           */


          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return -1;
            }

            var index = fromIndex == null ? 0 : toInteger(fromIndex);

            if (index < 0) {
              index = nativeMax(length + index, 0);
            }

            return baseIndexOf(array, value, index);
          }
          /**
           * Gets all but the last element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.initial([1, 2, 3]);
           * // => [1, 2]
           */


          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          /**
           * Creates an array of unique values that are included in all given arrays
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. The order and references of result values are
           * determined by the first array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * _.intersection([2, 1], [2, 3]);
           * // => [2]
           */


          var intersection = baseRest(function (arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          /**
           * This method is like `_.intersection` except that it accepts `iteratee`
           * which is invoked for each element of each `arrays` to generate the criterion
           * by which they're compared. The order and references of result values are
           * determined by the first array. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [2.1]
           *
           * // The `_.property` iteratee shorthand.
           * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }]
           */

          var intersectionBy = baseRest(function (arrays) {
            var iteratee = last(arrays),
                mapped = arrayMap(arrays, castArrayLikeObject);

            if (iteratee === last(mapped)) {
              iteratee = undefined;
            } else {
              mapped.pop();
            }

            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
          });
          /**
           * This method is like `_.intersection` except that it accepts `comparator`
           * which is invoked to compare elements of `arrays`. The order and references
           * of result values are determined by the first array. The comparator is
           * invoked with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.intersectionWith(objects, others, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }]
           */

          var intersectionWith = baseRest(function (arrays) {
            var comparator = last(arrays),
                mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == 'function' ? comparator : undefined;

            if (comparator) {
              mapped.pop();
            }

            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
          });
          /**
           * Converts all elements in `array` into a string separated by `separator`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to convert.
           * @param {string} [separator=','] The element separator.
           * @returns {string} Returns the joined string.
           * @example
           *
           * _.join(['a', 'b', 'c'], '~');
           * // => 'a~b~c'
           */

          function join(array, separator) {
            return array == null ? '' : nativeJoin.call(array, separator);
          }
          /**
           * Gets the last element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the last element of `array`.
           * @example
           *
           * _.last([1, 2, 3]);
           * // => 3
           */


          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined;
          }
          /**
           * This method is like `_.indexOf` except that it iterates over elements of
           * `array` from right to left.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=array.length-1] The index to search from.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.lastIndexOf([1, 2, 1, 2], 2);
           * // => 3
           *
           * // Search from the `fromIndex`.
           * _.lastIndexOf([1, 2, 1, 2], 2, 2);
           * // => 1
           */


          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return -1;
            }

            var index = length;

            if (fromIndex !== undefined) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }

            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          /**
           * Gets the element at index `n` of `array`. If `n` is negative, the nth
           * element from the end is returned.
           *
           * @static
           * @memberOf _
           * @since 4.11.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=0] The index of the element to return.
           * @returns {*} Returns the nth element of `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'd'];
           *
           * _.nth(array, 1);
           * // => 'b'
           *
           * _.nth(array, -2);
           * // => 'c';
           */


          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined;
          }
          /**
           * Removes all given values from `array` using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
           * to remove elements from an array by predicate.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...*} [values] The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
           *
           * _.pull(array, 'a', 'c');
           * console.log(array);
           * // => ['b', 'b']
           */


          var pull = baseRest(pullAll);
          /**
           * This method is like `_.pull` except that it accepts an array of values to remove.
           *
           * **Note:** Unlike `_.difference`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
           *
           * _.pullAll(array, ['a', 'c']);
           * console.log(array);
           * // => ['b', 'b']
           */

          function pullAll(array, values) {
            return array && array.length && values && values.length ? basePullAll(array, values) : array;
          }
          /**
           * This method is like `_.pullAll` except that it accepts `iteratee` which is
           * invoked for each element of `array` and `values` to generate the criterion
           * by which they're compared. The iteratee is invoked with one argument: (value).
           *
           * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
           *
           * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
           * console.log(array);
           * // => [{ 'x': 2 }]
           */


          function pullAllBy(array, values, iteratee) {
            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
          }
          /**
           * This method is like `_.pullAll` except that it accepts `comparator` which
           * is invoked to compare elements of `array` to `values`. The comparator is
           * invoked with two arguments: (arrVal, othVal).
           *
           * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
           *
           * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
           * console.log(array);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
           */


          function pullAllWith(array, values, comparator) {
            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
          }
          /**
           * Removes elements from `array` corresponding to `indexes` and returns an
           * array of removed elements.
           *
           * **Note:** Unlike `_.at`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...(number|number[])} [indexes] The indexes of elements to remove.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = ['a', 'b', 'c', 'd'];
           * var pulled = _.pullAt(array, [1, 3]);
           *
           * console.log(array);
           * // => ['a', 'c']
           *
           * console.log(pulled);
           * // => ['b', 'd']
           */


          var pullAt = flatRest(function (array, indexes) {
            var length = array == null ? 0 : array.length,
                result = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function (index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result;
          });
          /**
           * Removes all elements from `array` that `predicate` returns truthy for
           * and returns an array of the removed elements. The predicate is invoked
           * with three arguments: (value, index, array).
           *
           * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
           * to pull elements from an array by value.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = [1, 2, 3, 4];
           * var evens = _.remove(array, function(n) {
           *   return n % 2 == 0;
           * });
           *
           * console.log(array);
           * // => [1, 3]
           *
           * console.log(evens);
           * // => [2, 4]
           */

          function remove(array, predicate) {
            var result = [];

            if (!(array && array.length)) {
              return result;
            }

            var index = -1,
                indexes = [],
                length = array.length;
            predicate = getIteratee(predicate, 3);

            while (++index < length) {
              var value = array[index];

              if (predicate(value, index, array)) {
                result.push(value);
                indexes.push(index);
              }
            }

            basePullAt(array, indexes);
            return result;
          }
          /**
           * Reverses `array` so that the first element becomes the last, the second
           * element becomes the second to last, and so on.
           *
           * **Note:** This method mutates `array` and is based on
           * [`Array#reverse`](https://mdn.io/Array/reverse).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _.reverse(array);
           * // => [3, 2, 1]
           *
           * console.log(array);
           * // => [3, 2, 1]
           */


          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          /**
           * Creates a slice of `array` from `start` up to, but not including, `end`.
           *
           * **Note:** This method is used instead of
           * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
           * returned.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */


          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined ? length : toInteger(end);
            }

            return baseSlice(array, start, end);
          }
          /**
           * Uses a binary search to determine the lowest index at which `value`
           * should be inserted into `array` in order to maintain its sort order.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedIndex([30, 50], 40);
           * // => 1
           */


          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          /**
           * This method is like `_.sortedIndex` except that it accepts `iteratee`
           * which is invoked for `value` and each element of `array` to compute their
           * sort ranking. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * var objects = [{ 'x': 4 }, { 'x': 5 }];
           *
           * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
           * // => 0
           *
           * // The `_.property` iteratee shorthand.
           * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
           * // => 0
           */


          function sortedIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
          }
          /**
           * This method is like `_.indexOf` except that it performs a binary
           * search on a sorted `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
           * // => 1
           */


          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;

            if (length) {
              var index = baseSortedIndex(array, value);

              if (index < length && eq(array[index], value)) {
                return index;
              }
            }

            return -1;
          }
          /**
           * This method is like `_.sortedIndex` except that it returns the highest
           * index at which `value` should be inserted into `array` in order to
           * maintain its sort order.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
           * // => 4
           */


          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          /**
           * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
           * which is invoked for `value` and each element of `array` to compute their
           * sort ranking. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * var objects = [{ 'x': 4 }, { 'x': 5 }];
           *
           * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
           * // => 1
           *
           * // The `_.property` iteratee shorthand.
           * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
           * // => 1
           */


          function sortedLastIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
          }
          /**
           * This method is like `_.lastIndexOf` except that it performs a binary
           * search on a sorted `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
           * // => 3
           */


          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;

            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;

              if (eq(array[index], value)) {
                return index;
              }
            }

            return -1;
          }
          /**
           * This method is like `_.uniq` except that it's designed and optimized
           * for sorted arrays.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.sortedUniq([1, 1, 2]);
           * // => [1, 2]
           */


          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          /**
           * This method is like `_.uniqBy` except that it's designed and optimized
           * for sorted arrays.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
           * // => [1.1, 2.3]
           */


          function sortedUniqBy(array, iteratee) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
          }
          /**
           * Gets all but the first element of `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.tail([1, 2, 3]);
           * // => [2, 3]
           */


          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          /**
           * Creates a slice of `array` with `n` elements taken from the beginning.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.take([1, 2, 3]);
           * // => [1]
           *
           * _.take([1, 2, 3], 2);
           * // => [1, 2]
           *
           * _.take([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.take([1, 2, 3], 0);
           * // => []
           */


          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }

            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          /**
           * Creates a slice of `array` with `n` elements taken from the end.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.takeRight([1, 2, 3]);
           * // => [3]
           *
           * _.takeRight([1, 2, 3], 2);
           * // => [2, 3]
           *
           * _.takeRight([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.takeRight([1, 2, 3], 0);
           * // => []
           */


          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;

            if (!length) {
              return [];
            }

            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          /**
           * Creates a slice of `array` with elements taken from the end. Elements are
           * taken until `predicate` returns falsey. The predicate is invoked with
           * three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.takeRightWhile(users, function(o) { return !o.active; });
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.matches` iteratee shorthand.
           * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
           * // => objects for ['pebbles']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.takeRightWhile(users, ['active', false]);
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.property` iteratee shorthand.
           * _.takeRightWhile(users, 'active');
           * // => []
           */


          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          /**
           * Creates a slice of `array` with elements taken from the beginning. Elements
           * are taken until `predicate` returns falsey. The predicate is invoked with
           * three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.takeWhile(users, function(o) { return !o.active; });
           * // => objects for ['barney', 'fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.takeWhile(users, { 'user': 'barney', 'active': false });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.takeWhile(users, ['active', false]);
           * // => objects for ['barney', 'fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.takeWhile(users, 'active');
           * // => []
           */


          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          /**
           * Creates an array of unique values, in order, from all given arrays using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * _.union([2], [1, 2]);
           * // => [2, 1]
           */


          var union = baseRest(function (arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          /**
           * This method is like `_.union` except that it accepts `iteratee` which is
           * invoked for each element of each `arrays` to generate the criterion by
           * which uniqueness is computed. Result values are chosen from the first
           * array in which the value occurs. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * _.unionBy([2.1], [1.2, 2.3], Math.floor);
           * // => [2.1, 1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */

          var unionBy = baseRest(function (arrays) {
            var iteratee = last(arrays);

            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined;
            }

            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
          });
          /**
           * This method is like `_.union` except that it accepts `comparator` which
           * is invoked to compare elements of `arrays`. Result values are chosen from
           * the first array in which the value occurs. The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.unionWith(objects, others, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
           */

          var unionWith = baseRest(function (arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
          });
          /**
           * Creates a duplicate-free version of an array, using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons, in which only the first occurrence of each element
           * is kept. The order of result values is determined by the order they occur
           * in the array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.uniq([2, 1, 2]);
           * // => [2, 1]
           */

          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          /**
           * This method is like `_.uniq` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * uniqueness is computed. The order of result values is determined by the
           * order they occur in the array. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
           * // => [2.1, 1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */


          function uniqBy(array, iteratee) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
          }
          /**
           * This method is like `_.uniq` except that it accepts `comparator` which
           * is invoked to compare elements of `array`. The order of result values is
           * determined by the order they occur in the array.The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.uniqWith(objects, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
           */


          function uniqWith(array, comparator) {
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return array && array.length ? baseUniq(array, undefined, comparator) : [];
          }
          /**
           * This method is like `_.zip` except that it accepts an array of grouped
           * elements and creates an array regrouping the elements to their pre-zip
           * configuration.
           *
           * @static
           * @memberOf _
           * @since 1.2.0
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
           * // => [['a', 1, true], ['b', 2, false]]
           *
           * _.unzip(zipped);
           * // => [['a', 'b'], [1, 2], [true, false]]
           */


          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }

            var length = 0;
            array = arrayFilter(array, function (group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function (index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          /**
           * This method is like `_.unzip` except that it accepts `iteratee` to specify
           * how regrouped values should be combined. The iteratee is invoked with the
           * elements of each group: (...group).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @param {Function} [iteratee=_.identity] The function to combine
           *  regrouped values.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
           * // => [[1, 10, 100], [2, 20, 200]]
           *
           * _.unzipWith(zipped, _.add);
           * // => [3, 30, 300]
           */


          function unzipWith(array, iteratee) {
            if (!(array && array.length)) {
              return [];
            }

            var result = unzip(array);

            if (iteratee == null) {
              return result;
            }

            return arrayMap(result, function (group) {
              return apply(iteratee, undefined, group);
            });
          }
          /**
           * Creates an array excluding all given values using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * **Note:** Unlike `_.pull`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...*} [values] The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.difference, _.xor
           * @example
           *
           * _.without([2, 1, 2, 3], 1, 2);
           * // => [3]
           */


          var without = baseRest(function (array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, values) : [];
          });
          /**
           * Creates an array of unique values that is the
           * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
           * of the given arrays. The order of result values is determined by the order
           * they occur in the arrays.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.difference, _.without
           * @example
           *
           * _.xor([2, 1], [2, 3]);
           * // => [1, 3]
           */

          var xor = baseRest(function (arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          /**
           * This method is like `_.xor` except that it accepts `iteratee` which is
           * invoked for each element of each `arrays` to generate the criterion by
           * which by which they're compared. The order of result values is determined
           * by the order they occur in the arrays. The iteratee is invoked with one
           * argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [1.2, 3.4]
           *
           * // The `_.property` iteratee shorthand.
           * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 2 }]
           */

          var xorBy = baseRest(function (arrays) {
            var iteratee = last(arrays);

            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined;
            }

            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
          });
          /**
           * This method is like `_.xor` except that it accepts `comparator` which is
           * invoked to compare elements of `arrays`. The order of result values is
           * determined by the order they occur in the arrays. The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.xorWith(objects, others, _.isEqual);
           * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
           */

          var xorWith = baseRest(function (arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
          });
          /**
           * Creates an array of grouped elements, the first of which contains the
           * first elements of the given arrays, the second of which contains the
           * second elements of the given arrays, and so on.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zip(['a', 'b'], [1, 2], [true, false]);
           * // => [['a', 1, true], ['b', 2, false]]
           */

          var zip = baseRest(unzip);
          /**
           * This method is like `_.fromPairs` except that it accepts two arrays,
           * one of property identifiers and one of corresponding values.
           *
           * @static
           * @memberOf _
           * @since 0.4.0
           * @category Array
           * @param {Array} [props=[]] The property identifiers.
           * @param {Array} [values=[]] The property values.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.zipObject(['a', 'b'], [1, 2]);
           * // => { 'a': 1, 'b': 2 }
           */

          function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue);
          }
          /**
           * This method is like `_.zipObject` except that it supports property paths.
           *
           * @static
           * @memberOf _
           * @since 4.1.0
           * @category Array
           * @param {Array} [props=[]] The property identifiers.
           * @param {Array} [values=[]] The property values.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
           * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
           */


          function zipObjectDeep(props, values) {
            return baseZipObject(props || [], values || [], baseSet);
          }
          /**
           * This method is like `_.zip` except that it accepts `iteratee` to specify
           * how grouped values should be combined. The iteratee is invoked with the
           * elements of each group: (...group).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @param {Function} [iteratee=_.identity] The function to combine
           *  grouped values.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
           *   return a + b + c;
           * });
           * // => [111, 222]
           */


          var zipWith = baseRest(function (arrays) {
            var length = arrays.length,
                iteratee = length > 1 ? arrays[length - 1] : undefined;
            iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
            return unzipWith(arrays, iteratee);
          });
          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` wrapper instance that wraps `value` with explicit method
           * chain sequences enabled. The result of such sequences must be unwrapped
           * with `_#value`.
           *
           * @static
           * @memberOf _
           * @since 1.3.0
           * @category Seq
           * @param {*} value The value to wrap.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36 },
           *   { 'user': 'fred',    'age': 40 },
           *   { 'user': 'pebbles', 'age': 1 }
           * ];
           *
           * var youngest = _
           *   .chain(users)
           *   .sortBy('age')
           *   .map(function(o) {
           *     return o.user + ' is ' + o.age;
           *   })
           *   .head()
           *   .value();
           * // => 'pebbles is 1'
           */

          function chain(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
          }
          /**
           * This method invokes `interceptor` and returns `value`. The interceptor
           * is invoked with one argument; (value). The purpose of this method is to
           * "tap into" a method chain sequence in order to modify intermediate results.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @returns {*} Returns `value`.
           * @example
           *
           * _([1, 2, 3])
           *  .tap(function(array) {
           *    // Mutate input array.
           *    array.pop();
           *  })
           *  .reverse()
           *  .value();
           * // => [2, 1]
           */


          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          /**
           * This method is like `_.tap` except that it returns the result of `interceptor`.
           * The purpose of this method is to "pass thru" values replacing intermediate
           * results in a method chain sequence.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Seq
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @returns {*} Returns the result of `interceptor`.
           * @example
           *
           * _('  abc  ')
           *  .chain()
           *  .trim()
           *  .thru(function(value) {
           *    return [value];
           *  })
           *  .value();
           * // => ['abc']
           */


          function thru(value, interceptor) {
            return interceptor(value);
          }
          /**
           * This method is the wrapper version of `_.at`.
           *
           * @name at
           * @memberOf _
           * @since 1.0.0
           * @category Seq
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
           *
           * _(object).at(['a[0].b.c', 'a[1]']).value();
           * // => [3, 4]
           */


          var wrapperAt = flatRest(function (paths) {
            var length = paths.length,
                start = length ? paths[0] : 0,
                value = this.__wrapped__,
                interceptor = function interceptor(object) {
              return baseAt(object, paths);
            };

            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }

            value = value.slice(start, +start + (length ? 1 : 0));

            value.__actions__.push({
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            });

            return new LodashWrapper(value, this.__chain__).thru(function (array) {
              if (length && !array.length) {
                array.push(undefined);
              }

              return array;
            });
          });
          /**
           * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
           *
           * @name chain
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * // A sequence without explicit chaining.
           * _(users).head();
           * // => { 'user': 'barney', 'age': 36 }
           *
           * // A sequence with explicit chaining.
           * _(users)
           *   .chain()
           *   .head()
           *   .pick('user')
           *   .value();
           * // => { 'user': 'barney' }
           */

          function wrapperChain() {
            return chain(this);
          }
          /**
           * Executes the chain sequence and returns the wrapped result.
           *
           * @name commit
           * @memberOf _
           * @since 3.2.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2];
           * var wrapped = _(array).push(3);
           *
           * console.log(array);
           * // => [1, 2]
           *
           * wrapped = wrapped.commit();
           * console.log(array);
           * // => [1, 2, 3]
           *
           * wrapped.last();
           * // => 3
           *
           * console.log(array);
           * // => [1, 2, 3]
           */


          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          /**
           * Gets the next value on a wrapped object following the
           * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
           *
           * @name next
           * @memberOf _
           * @since 4.0.0
           * @category Seq
           * @returns {Object} Returns the next iterator value.
           * @example
           *
           * var wrapped = _([1, 2]);
           *
           * wrapped.next();
           * // => { 'done': false, 'value': 1 }
           *
           * wrapped.next();
           * // => { 'done': false, 'value': 2 }
           *
           * wrapped.next();
           * // => { 'done': true, 'value': undefined }
           */


          function wrapperNext() {
            if (this.__values__ === undefined) {
              this.__values__ = toArray(this.value());
            }

            var done = this.__index__ >= this.__values__.length,
                value = done ? undefined : this.__values__[this.__index__++];
            return {
              'done': done,
              'value': value
            };
          }
          /**
           * Enables the wrapper to be iterable.
           *
           * @name Symbol.iterator
           * @memberOf _
           * @since 4.0.0
           * @category Seq
           * @returns {Object} Returns the wrapper object.
           * @example
           *
           * var wrapped = _([1, 2]);
           *
           * wrapped[Symbol.iterator]() === wrapped;
           * // => true
           *
           * Array.from(wrapped);
           * // => [1, 2]
           */


          function wrapperToIterator() {
            return this;
          }
          /**
           * Creates a clone of the chain sequence planting `value` as the wrapped value.
           *
           * @name plant
           * @memberOf _
           * @since 3.2.0
           * @category Seq
           * @param {*} value The value to plant.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var wrapped = _([1, 2]).map(square);
           * var other = wrapped.plant([3, 4]);
           *
           * other.value();
           * // => [9, 16]
           *
           * wrapped.value();
           * // => [1, 4]
           */


          function wrapperPlant(value) {
            var result,
                parent = this;

            while (parent instanceof baseLodash) {
              var clone = wrapperClone(parent);
              clone.__index__ = 0;
              clone.__values__ = undefined;

              if (result) {
                previous.__wrapped__ = clone;
              } else {
                result = clone;
              }

              var previous = clone;
              parent = parent.__wrapped__;
            }

            previous.__wrapped__ = value;
            return result;
          }
          /**
           * This method is the wrapper version of `_.reverse`.
           *
           * **Note:** This method mutates the wrapped array.
           *
           * @name reverse
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _(array).reverse().value()
           * // => [3, 2, 1]
           *
           * console.log(array);
           * // => [3, 2, 1]
           */


          function wrapperReverse() {
            var value = this.__wrapped__;

            if (value instanceof LazyWrapper) {
              var wrapped = value;

              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }

              wrapped = wrapped.reverse();

              wrapped.__actions__.push({
                'func': thru,
                'args': [reverse],
                'thisArg': undefined
              });

              return new LodashWrapper(wrapped, this.__chain__);
            }

            return this.thru(reverse);
          }
          /**
           * Executes the chain sequence to resolve the unwrapped value.
           *
           * @name value
           * @memberOf _
           * @since 0.1.0
           * @alias toJSON, valueOf
           * @category Seq
           * @returns {*} Returns the resolved unwrapped value.
           * @example
           *
           * _([1, 2, 3]).value();
           * // => [1, 2, 3]
           */


          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          /*------------------------------------------------------------------------*/

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The corresponding value of
           * each key is the number of times the key was returned by `iteratee`. The
           * iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.countBy([6.1, 4.2, 6.3], Math.floor);
           * // => { '4': 1, '6': 2 }
           *
           * // The `_.property` iteratee shorthand.
           * _.countBy(['one', 'two', 'three'], 'length');
           * // => { '3': 2, '5': 1 }
           */


          var countBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
              ++result[key];
            } else {
              baseAssignValue(result, key, 1);
            }
          });
          /**
           * Checks if `predicate` returns truthy for **all** elements of `collection`.
           * Iteration is stopped once `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index|key, collection).
           *
           * **Note:** This method returns `true` for
           * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
           * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
           * elements of empty collections.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`.
           * @example
           *
           * _.every([true, 1, null, 'yes'], Boolean);
           * // => false
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.every(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.every(users, ['active', false]);
           * // => true
           *
           * // The `_.property` iteratee shorthand.
           * _.every(users, 'active');
           * // => false
           */

          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;

            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined;
            }

            return func(collection, getIteratee(predicate, 3));
          }
          /**
           * Iterates over elements of `collection`, returning an array of all elements
           * `predicate` returns truthy for. The predicate is invoked with three
           * arguments: (value, index|key, collection).
           *
           * **Note:** Unlike `_.remove`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           * @see _.reject
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * _.filter(users, function(o) { return !o.active; });
           * // => objects for ['fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.filter(users, { 'age': 36, 'active': true });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.filter(users, ['active', false]);
           * // => objects for ['fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.filter(users, 'active');
           * // => objects for ['barney']
           */


          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          /**
           * Iterates over elements of `collection`, returning the first element
           * `predicate` returns truthy for. The predicate is invoked with three
           * arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': true },
           *   { 'user': 'fred',    'age': 40, 'active': false },
           *   { 'user': 'pebbles', 'age': 1,  'active': true }
           * ];
           *
           * _.find(users, function(o) { return o.age < 40; });
           * // => object for 'barney'
           *
           * // The `_.matches` iteratee shorthand.
           * _.find(users, { 'age': 1, 'active': true });
           * // => object for 'pebbles'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.find(users, ['active', false]);
           * // => object for 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.find(users, 'active');
           * // => object for 'barney'
           */


          var find = createFind(findIndex);
          /**
           * This method is like `_.find` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=collection.length-1] The index to search from.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * _.findLast([1, 2, 3, 4], function(n) {
           *   return n % 2 == 1;
           * });
           * // => 3
           */

          var findLast = createFind(findLastIndex);
          /**
           * Creates a flattened array of values by running each element in `collection`
           * thru `iteratee` and flattening the mapped results. The iteratee is invoked
           * with three arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [n, n];
           * }
           *
           * _.flatMap([1, 2], duplicate);
           * // => [1, 1, 2, 2]
           */

          function flatMap(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), 1);
          }
          /**
           * This method is like `_.flatMap` except that it recursively flattens the
           * mapped results.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [[[n, n]]];
           * }
           *
           * _.flatMapDeep([1, 2], duplicate);
           * // => [1, 1, 2, 2]
           */


          function flatMapDeep(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), INFINITY);
          }
          /**
           * This method is like `_.flatMap` except that it recursively flattens the
           * mapped results up to `depth` times.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {number} [depth=1] The maximum recursion depth.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [[[n, n]]];
           * }
           *
           * _.flatMapDepth([1, 2], duplicate, 2);
           * // => [[1, 1], [2, 2]]
           */


          function flatMapDepth(collection, iteratee, depth) {
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee), depth);
          }
          /**
           * Iterates over elements of `collection` and invokes `iteratee` for each element.
           * The iteratee is invoked with three arguments: (value, index|key, collection).
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * **Note:** As with other "Collections" methods, objects with a "length"
           * property are iterated like arrays. To avoid this behavior use `_.forIn`
           * or `_.forOwn` for object iteration.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @alias each
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           * @see _.forEachRight
           * @example
           *
           * _.forEach([1, 2], function(value) {
           *   console.log(value);
           * });
           * // => Logs `1` then `2`.
           *
           * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a' then 'b' (iteration order is not guaranteed).
           */


          function forEach(collection, iteratee) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee, 3));
          }
          /**
           * This method is like `_.forEach` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @alias eachRight
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           * @see _.forEach
           * @example
           *
           * _.forEachRight([1, 2], function(value) {
           *   console.log(value);
           * });
           * // => Logs `2` then `1`.
           */


          function forEachRight(collection, iteratee) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee, 3));
          }
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The order of grouped values
           * is determined by the order they occur in `collection`. The corresponding
           * value of each key is an array of elements responsible for generating the
           * key. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.groupBy([6.1, 4.2, 6.3], Math.floor);
           * // => { '4': [4.2], '6': [6.1, 6.3] }
           *
           * // The `_.property` iteratee shorthand.
           * _.groupBy(['one', 'two', 'three'], 'length');
           * // => { '3': ['one', 'two'], '5': ['three'] }
           */


          var groupBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
              result[key].push(value);
            } else {
              baseAssignValue(result, key, [value]);
            }
          });
          /**
           * Checks if `value` is in `collection`. If `collection` is a string, it's
           * checked for a substring of `value`, otherwise
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * is used for equality comparisons. If `fromIndex` is negative, it's used as
           * the offset from the end of `collection`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object|string} collection The collection to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=0] The index to search from.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
           * @returns {boolean} Returns `true` if `value` is found, else `false`.
           * @example
           *
           * _.includes([1, 2, 3], 1);
           * // => true
           *
           * _.includes([1, 2, 3], 1, 2);
           * // => false
           *
           * _.includes({ 'a': 1, 'b': 2 }, 1);
           * // => true
           *
           * _.includes('abcd', 'bc');
           * // => true
           */

          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;

            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }

            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          /**
           * Invokes the method at `path` of each element in `collection`, returning
           * an array of the results of each invoked method. Any additional arguments
           * are provided to each invoked method. If `path` is a function, it's invoked
           * for, and `this` bound to, each element in `collection`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Array|Function|string} path The path of the method to invoke or
           *  the function invoked per iteration.
           * @param {...*} [args] The arguments to invoke each method with.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
           * // => [[1, 5, 7], [1, 2, 3]]
           *
           * _.invokeMap([123, 456], String.prototype.split, '');
           * // => [['1', '2', '3'], ['4', '5', '6']]
           */


          var invokeMap = baseRest(function (collection, path, args) {
            var index = -1,
                isFunc = typeof path == 'function',
                result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function (value) {
              result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result;
          });
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The corresponding value of
           * each key is the last element responsible for generating the key. The
           * iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * var array = [
           *   { 'dir': 'left', 'code': 97 },
           *   { 'dir': 'right', 'code': 100 }
           * ];
           *
           * _.keyBy(array, function(o) {
           *   return String.fromCharCode(o.code);
           * });
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           *
           * _.keyBy(array, 'dir');
           * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
           */

          var keyBy = createAggregator(function (result, value, key) {
            baseAssignValue(result, key, value);
          });
          /**
           * Creates an array of values by running each element in `collection` thru
           * `iteratee`. The iteratee is invoked with three arguments:
           * (value, index|key, collection).
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
           *
           * The guarded methods are:
           * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
           * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
           * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
           * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * _.map([4, 8], square);
           * // => [16, 64]
           *
           * _.map({ 'a': 4, 'b': 8 }, square);
           * // => [16, 64] (iteration order is not guaranteed)
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * // The `_.property` iteratee shorthand.
           * _.map(users, 'user');
           * // => ['barney', 'fred']
           */

          function map(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee, 3));
          }
          /**
           * This method is like `_.sortBy` except that it allows specifying the sort
           * orders of the iteratees to sort by. If `orders` is unspecified, all values
           * are sorted in ascending order. Otherwise, specify an order of "desc" for
           * descending or "asc" for ascending sort order of corresponding values.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
           *  The iteratees to sort by.
           * @param {string[]} [orders] The sort orders of `iteratees`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 34 },
           *   { 'user': 'fred',   'age': 40 },
           *   { 'user': 'barney', 'age': 36 }
           * ];
           *
           * // Sort by `user` in ascending order and by `age` in descending order.
           * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
           * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
           */


          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }

            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }

            orders = guard ? undefined : orders;

            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }

            return baseOrderBy(collection, iteratees, orders);
          }
          /**
           * Creates an array of elements split into two groups, the first of which
           * contains elements `predicate` returns truthy for, the second of which
           * contains elements `predicate` returns falsey for. The predicate is
           * invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the array of grouped elements.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': false },
           *   { 'user': 'fred',    'age': 40, 'active': true },
           *   { 'user': 'pebbles', 'age': 1,  'active': false }
           * ];
           *
           * _.partition(users, function(o) { return o.active; });
           * // => objects for [['fred'], ['barney', 'pebbles']]
           *
           * // The `_.matches` iteratee shorthand.
           * _.partition(users, { 'age': 1, 'active': false });
           * // => objects for [['pebbles'], ['barney', 'fred']]
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.partition(users, ['active', false]);
           * // => objects for [['barney', 'pebbles'], ['fred']]
           *
           * // The `_.property` iteratee shorthand.
           * _.partition(users, 'active');
           * // => objects for [['fred'], ['barney', 'pebbles']]
           */


          var partition = createAggregator(function (result, value, key) {
            result[key ? 0 : 1].push(value);
          }, function () {
            return [[], []];
          });
          /**
           * Reduces `collection` to a value which is the accumulated result of running
           * each element in `collection` thru `iteratee`, where each successive
           * invocation is supplied the return value of the previous. If `accumulator`
           * is not given, the first element of `collection` is used as the initial
           * value. The iteratee is invoked with four arguments:
           * (accumulator, value, index|key, collection).
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.reduce`, `_.reduceRight`, and `_.transform`.
           *
           * The guarded methods are:
           * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
           * and `sortBy`
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @returns {*} Returns the accumulated value.
           * @see _.reduceRight
           * @example
           *
           * _.reduce([1, 2], function(sum, n) {
           *   return sum + n;
           * }, 0);
           * // => 3
           *
           * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
           *   (result[value] || (result[value] = [])).push(key);
           *   return result;
           * }, {});
           * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
           */

          function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce,
                initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
          }
          /**
           * This method is like `_.reduce` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @returns {*} Returns the accumulated value.
           * @see _.reduce
           * @example
           *
           * var array = [[0, 1], [2, 3], [4, 5]];
           *
           * _.reduceRight(array, function(flattened, other) {
           *   return flattened.concat(other);
           * }, []);
           * // => [4, 5, 2, 3, 0, 1]
           */


          function reduceRight(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce,
                initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
          }
          /**
           * The opposite of `_.filter`; this method returns the elements of `collection`
           * that `predicate` does **not** return truthy for.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           * @see _.filter
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false },
           *   { 'user': 'fred',   'age': 40, 'active': true }
           * ];
           *
           * _.reject(users, function(o) { return !o.active; });
           * // => objects for ['fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.reject(users, { 'age': 40, 'active': true });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.reject(users, ['active', false]);
           * // => objects for ['fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.reject(users, 'active');
           * // => objects for ['barney']
           */


          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          /**
           * Gets a random element from `collection`.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to sample.
           * @returns {*} Returns the random element.
           * @example
           *
           * _.sample([1, 2, 3, 4]);
           * // => 2
           */


          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          /**
           * Gets `n` random elements at unique keys from `collection` up to the
           * size of `collection`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to sample.
           * @param {number} [n=1] The number of elements to sample.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the random elements.
           * @example
           *
           * _.sampleSize([1, 2, 3], 2);
           * // => [3, 1]
           *
           * _.sampleSize([1, 2, 3], 4);
           * // => [2, 3, 1]
           */


          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
              n = 1;
            } else {
              n = toInteger(n);
            }

            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          /**
           * Creates an array of shuffled values, using a version of the
           * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to shuffle.
           * @returns {Array} Returns the new shuffled array.
           * @example
           *
           * _.shuffle([1, 2, 3, 4]);
           * // => [4, 1, 3, 2]
           */


          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          /**
           * Gets the size of `collection` by returning its length for array-like
           * values or the number of own enumerable string keyed properties for objects.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object|string} collection The collection to inspect.
           * @returns {number} Returns the collection size.
           * @example
           *
           * _.size([1, 2, 3]);
           * // => 3
           *
           * _.size({ 'a': 1, 'b': 2 });
           * // => 2
           *
           * _.size('pebbles');
           * // => 7
           */


          function size(collection) {
            if (collection == null) {
              return 0;
            }

            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }

            var tag = getTag(collection);

            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }

            return baseKeys(collection).length;
          }
          /**
           * Checks if `predicate` returns truthy for **any** element of `collection`.
           * Iteration is stopped once `predicate` returns truthy. The predicate is
           * invoked with three arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           * @example
           *
           * _.some([null, 0, 'yes', false], Boolean);
           * // => true
           *
           * var users = [
           *   { 'user': 'barney', 'active': true },
           *   { 'user': 'fred',   'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.some(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.some(users, ['active', false]);
           * // => true
           *
           * // The `_.property` iteratee shorthand.
           * _.some(users, 'active');
           * // => true
           */


          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;

            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined;
            }

            return func(collection, getIteratee(predicate, 3));
          }
          /**
           * Creates an array of elements, sorted in ascending order by the results of
           * running each element in a collection thru each iteratee. This method
           * performs a stable sort, that is, it preserves the original sort order of
           * equal elements. The iteratees are invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {...(Function|Function[])} [iteratees=[_.identity]]
           *  The iteratees to sort by.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 },
           *   { 'user': 'barney', 'age': 34 }
           * ];
           *
           * _.sortBy(users, [function(o) { return o.user; }]);
           * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
           *
           * _.sortBy(users, ['user', 'age']);
           * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
           */


          var sortBy = baseRest(function (collection, iteratees) {
            if (collection == null) {
              return [];
            }

            var length = iteratees.length;

            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }

            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          /*------------------------------------------------------------------------*/

          /**
           * Gets the timestamp of the number of milliseconds that have elapsed since
           * the Unix epoch (1 January 1970 00:00:00 UTC).
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Date
           * @returns {number} Returns the timestamp.
           * @example
           *
           * _.defer(function(stamp) {
           *   console.log(_.now() - stamp);
           * }, _.now());
           * // => Logs the number of milliseconds it took for the deferred invocation.
           */

          var now = ctxNow || function () {
            return root.Date.now();
          };
          /*------------------------------------------------------------------------*/

          /**
           * The opposite of `_.before`; this method creates a function that invokes
           * `func` once it's called `n` or more times.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {number} n The number of calls before `func` is invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var saves = ['profile', 'settings'];
           *
           * var done = _.after(saves.length, function() {
           *   console.log('done saving!');
           * });
           *
           * _.forEach(saves, function(type) {
           *   asyncSave({ 'type': type, 'complete': done });
           * });
           * // => Logs 'done saving!' after the two async saves have completed.
           */


          function after(n, func) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            n = toInteger(n);
            return function () {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          /**
           * Creates a function that invokes `func`, with up to `n` arguments,
           * ignoring any additional arguments.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to cap arguments for.
           * @param {number} [n=func.length] The arity cap.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new capped function.
           * @example
           *
           * _.map(['6', '8', '10'], _.ary(parseInt, 1));
           * // => [6, 8, 10]
           */


          function ary(func, n, guard) {
            n = guard ? undefined : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
          }
          /**
           * Creates a function that invokes `func`, with the `this` binding and arguments
           * of the created function, while it's called less than `n` times. Subsequent
           * calls to the created function return the result of the last `func` invocation.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {number} n The number of calls at which `func` is no longer invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * jQuery(element).on('click', _.before(5, addContactToList));
           * // => Allows adding up to 4 contacts to the list.
           */


          function before(n, func) {
            var result;

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            n = toInteger(n);
            return function () {
              if (--n > 0) {
                result = func.apply(this, arguments);
              }

              if (n <= 1) {
                func = undefined;
              }

              return result;
            };
          }
          /**
           * Creates a function that invokes `func` with the `this` binding of `thisArg`
           * and `partials` prepended to the arguments it receives.
           *
           * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for partially applied arguments.
           *
           * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
           * property of bound functions.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to bind.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * function greet(greeting, punctuation) {
           *   return greeting + ' ' + this.user + punctuation;
           * }
           *
           * var object = { 'user': 'fred' };
           *
           * var bound = _.bind(greet, object, 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * // Bound with placeholders.
           * var bound = _.bind(greet, object, _, '!');
           * bound('hi');
           * // => 'hi fred!'
           */


          var bind = baseRest(function (func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;

            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }

            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          /**
           * Creates a function that invokes the method at `object[key]` with `partials`
           * prepended to the arguments it receives.
           *
           * This method differs from `_.bind` by allowing bound functions to reference
           * methods that may be redefined or don't yet exist. See
           * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
           * for more details.
           *
           * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * @static
           * @memberOf _
           * @since 0.10.0
           * @category Function
           * @param {Object} object The object to invoke the method on.
           * @param {string} key The key of the method.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var object = {
           *   'user': 'fred',
           *   'greet': function(greeting, punctuation) {
           *     return greeting + ' ' + this.user + punctuation;
           *   }
           * };
           *
           * var bound = _.bindKey(object, 'greet', 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * object.greet = function(greeting, punctuation) {
           *   return greeting + 'ya ' + this.user + punctuation;
           * };
           *
           * bound('!');
           * // => 'hiya fred!'
           *
           * // Bound with placeholders.
           * var bound = _.bindKey(object, 'greet', _, '!');
           * bound('hi');
           * // => 'hiya fred!'
           */

          var bindKey = baseRest(function (object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;

            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }

            return createWrap(key, bitmask, object, partials, holders);
          });
          /**
           * Creates a function that accepts arguments of `func` and either invokes
           * `func` returning its result, if at least `arity` number of arguments have
           * been provided, or returns a function that accepts the remaining `func`
           * arguments, and so on. The arity of `func` may be specified if `func.length`
           * is not sufficient.
           *
           * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for provided arguments.
           *
           * **Note:** This method doesn't set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curry(abc);
           *
           * curried(1)(2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // Curried with placeholders.
           * curried(1)(_, 3)(2);
           * // => [1, 2, 3]
           */

          function curry(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curry.placeholder;
            return result;
          }
          /**
           * This method is like `_.curry` except that arguments are applied to `func`
           * in the manner of `_.partialRight` instead of `_.partial`.
           *
           * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for provided arguments.
           *
           * **Note:** This method doesn't set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curryRight(abc);
           *
           * curried(3)(2)(1);
           * // => [1, 2, 3]
           *
           * curried(2, 3)(1);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // Curried with placeholders.
           * curried(3)(1, _)(2);
           * // => [1, 2, 3]
           */


          function curryRight(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryRight.placeholder;
            return result;
          }
          /**
           * Creates a debounced function that delays invoking `func` until after `wait`
           * milliseconds have elapsed since the last time the debounced function was
           * invoked. The debounced function comes with a `cancel` method to cancel
           * delayed `func` invocations and a `flush` method to immediately invoke them.
           * Provide `options` to indicate whether `func` should be invoked on the
           * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
           * with the last arguments provided to the debounced function. Subsequent
           * calls to the debounced function return the result of the last `func`
           * invocation.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is
           * invoked on the trailing edge of the timeout only if the debounced function
           * is invoked more than once during the `wait` timeout.
           *
           * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
           * until to the next tick, similar to `setTimeout` with a timeout of `0`.
           *
           * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
           * for details over the differences between `_.debounce` and `_.throttle`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to debounce.
           * @param {number} [wait=0] The number of milliseconds to delay.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.leading=false]
           *  Specify invoking on the leading edge of the timeout.
           * @param {number} [options.maxWait]
           *  The maximum time `func` is allowed to be delayed before it's invoked.
           * @param {boolean} [options.trailing=true]
           *  Specify invoking on the trailing edge of the timeout.
           * @returns {Function} Returns the new debounced function.
           * @example
           *
           * // Avoid costly calculations while the window size is in flux.
           * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
           *
           * // Invoke `sendMail` when clicked, debouncing subsequent calls.
           * jQuery(element).on('click', _.debounce(sendMail, 300, {
           *   'leading': true,
           *   'trailing': false
           * }));
           *
           * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
           * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
           * var source = new EventSource('/stream');
           * jQuery(source).on('message', debounced);
           *
           * // Cancel the trailing debounced invocation.
           * jQuery(window).on('popstate', debounced.cancel);
           */


          function debounce(func, wait, options) {
            var lastArgs,
                lastThis,
                maxWait,
                result,
                timerId,
                lastCallTime,
                lastInvokeTime = 0,
                leading = false,
                maxing = false,
                trailing = true;

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            wait = toNumber(wait) || 0;

            if (isObject(options)) {
              leading = !!options.leading;
              maxing = 'maxWait' in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = 'trailing' in options ? !!options.trailing : trailing;
            }

            function invokeFunc(time) {
              var args = lastArgs,
                  thisArg = lastThis;
              lastArgs = lastThis = undefined;
              lastInvokeTime = time;
              result = func.apply(thisArg, args);
              return result;
            }

            function leadingEdge(time) {
              // Reset any `maxWait` timer.
              lastInvokeTime = time; // Start the timer for the trailing edge.

              timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

              return leading ? invokeFunc(time) : result;
            }

            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime,
                  timeSinceLastInvoke = time - lastInvokeTime,
                  timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }

            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime,
                  timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
              // trailing edge, the system time has gone backwards and we're treating
              // it as the trailing edge, or we've hit the `maxWait` limit.

              return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }

            function timerExpired() {
              var time = now();

              if (shouldInvoke(time)) {
                return trailingEdge(time);
              } // Restart the timer.


              timerId = setTimeout(timerExpired, remainingWait(time));
            }

            function trailingEdge(time) {
              timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
              // debounced at least once.

              if (trailing && lastArgs) {
                return invokeFunc(time);
              }

              lastArgs = lastThis = undefined;
              return result;
            }

            function cancel() {
              if (timerId !== undefined) {
                clearTimeout(timerId);
              }

              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined;
            }

            function flush() {
              return timerId === undefined ? result : trailingEdge(now());
            }

            function debounced() {
              var time = now(),
                  isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;

              if (isInvoking) {
                if (timerId === undefined) {
                  return leadingEdge(lastCallTime);
                }

                if (maxing) {
                  // Handle invocations in a tight loop.
                  clearTimeout(timerId);
                  timerId = setTimeout(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }

              if (timerId === undefined) {
                timerId = setTimeout(timerExpired, wait);
              }

              return result;
            }

            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          /**
           * Defers invoking the `func` until the current call stack has cleared. Any
           * additional arguments are provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to defer.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.defer(function(text) {
           *   console.log(text);
           * }, 'deferred');
           * // => Logs 'deferred' after one millisecond.
           */


          var defer = baseRest(function (func, args) {
            return baseDelay(func, 1, args);
          });
          /**
           * Invokes `func` after `wait` milliseconds. Any additional arguments are
           * provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.delay(function(text) {
           *   console.log(text);
           * }, 1000, 'later');
           * // => Logs 'later' after one second.
           */

          var delay = baseRest(function (func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          /**
           * Creates a function that invokes `func` with arguments reversed.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to flip arguments for.
           * @returns {Function} Returns the new flipped function.
           * @example
           *
           * var flipped = _.flip(function() {
           *   return _.toArray(arguments);
           * });
           *
           * flipped('a', 'b', 'c', 'd');
           * // => ['d', 'c', 'b', 'a']
           */

          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          /**
           * Creates a function that memoizes the result of `func`. If `resolver` is
           * provided, it determines the cache key for storing the result based on the
           * arguments provided to the memoized function. By default, the first argument
           * provided to the memoized function is used as the map cache key. The `func`
           * is invoked with the `this` binding of the memoized function.
           *
           * **Note:** The cache is exposed as the `cache` property on the memoized
           * function. Its creation may be customized by replacing the `_.memoize.Cache`
           * constructor with one whose instances implement the
           * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
           * method interface of `clear`, `delete`, `get`, `has`, and `set`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to have its output memoized.
           * @param {Function} [resolver] The function to resolve the cache key.
           * @returns {Function} Returns the new memoized function.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           * var other = { 'c': 3, 'd': 4 };
           *
           * var values = _.memoize(_.values);
           * values(object);
           * // => [1, 2]
           *
           * values(other);
           * // => [3, 4]
           *
           * object.a = 2;
           * values(object);
           * // => [1, 2]
           *
           * // Modify the result cache.
           * values.cache.set(object, ['a', 'b']);
           * values(object);
           * // => ['a', 'b']
           *
           * // Replace `_.memoize.Cache`.
           * _.memoize.Cache = WeakMap;
           */


          function memoize(func, resolver) {
            if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            var memoized = function memoized() {
              var args = arguments,
                  key = resolver ? resolver.apply(this, args) : args[0],
                  cache = memoized.cache;

              if (cache.has(key)) {
                return cache.get(key);
              }

              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result) || cache;
              return result;
            };

            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          } // Expose `MapCache`.


          memoize.Cache = MapCache;
          /**
           * Creates a function that negates the result of the predicate `func`. The
           * `func` predicate is invoked with the `this` binding and arguments of the
           * created function.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} predicate The predicate to negate.
           * @returns {Function} Returns the new negated function.
           * @example
           *
           * function isEven(n) {
           *   return n % 2 == 0;
           * }
           *
           * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
           * // => [1, 3, 5]
           */

          function negate(predicate) {
            if (typeof predicate != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            return function () {
              var args = arguments;

              switch (args.length) {
                case 0:
                  return !predicate.call(this);

                case 1:
                  return !predicate.call(this, args[0]);

                case 2:
                  return !predicate.call(this, args[0], args[1]);

                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }

              return !predicate.apply(this, args);
            };
          }
          /**
           * Creates a function that is restricted to invoking `func` once. Repeat calls
           * to the function return the value of the first invocation. The `func` is
           * invoked with the `this` binding and arguments of the created function.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var initialize = _.once(createApplication);
           * initialize();
           * initialize();
           * // => `createApplication` is invoked once
           */


          function once(func) {
            return before(2, func);
          }
          /**
           * Creates a function that invokes `func` with its arguments transformed.
           *
           * @static
           * @since 4.0.0
           * @memberOf _
           * @category Function
           * @param {Function} func The function to wrap.
           * @param {...(Function|Function[])} [transforms=[_.identity]]
           *  The argument transforms.
           * @returns {Function} Returns the new function.
           * @example
           *
           * function doubled(n) {
           *   return n * 2;
           * }
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var func = _.overArgs(function(x, y) {
           *   return [x, y];
           * }, [square, doubled]);
           *
           * func(9, 3);
           * // => [81, 6]
           *
           * func(10, 5);
           * // => [100, 10]
           */


          var overArgs = castRest(function (func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function (args) {
              var index = -1,
                  length = nativeMin(args.length, funcsLength);

              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }

              return apply(func, this, args);
            });
          });
          /**
           * Creates a function that invokes `func` with `partials` prepended to the
           * arguments it receives. This method is like `_.bind` except it does **not**
           * alter the `this` binding.
           *
           * The `_.partial.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method doesn't set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @since 0.2.0
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * function greet(greeting, name) {
           *   return greeting + ' ' + name;
           * }
           *
           * var sayHelloTo = _.partial(greet, 'hello');
           * sayHelloTo('fred');
           * // => 'hello fred'
           *
           * // Partially applied with placeholders.
           * var greetFred = _.partial(greet, _, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           */

          var partial = baseRest(function (func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
          });
          /**
           * This method is like `_.partial` except that partially applied arguments
           * are appended to the arguments it receives.
           *
           * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method doesn't set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * function greet(greeting, name) {
           *   return greeting + ' ' + name;
           * }
           *
           * var greetFred = _.partialRight(greet, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           *
           * // Partially applied with placeholders.
           * var sayHelloTo = _.partialRight(greet, 'hello', _);
           * sayHelloTo('fred');
           * // => 'hello fred'
           */

          var partialRight = baseRest(function (func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
          });
          /**
           * Creates a function that invokes `func` with arguments arranged according
           * to the specified `indexes` where the argument value at the first index is
           * provided as the first argument, the argument value at the second index is
           * provided as the second argument, and so on.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to rearrange arguments for.
           * @param {...(number|number[])} indexes The arranged argument indexes.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var rearged = _.rearg(function(a, b, c) {
           *   return [a, b, c];
           * }, [2, 0, 1]);
           *
           * rearged('b', 'c', 'a')
           * // => ['a', 'b', 'c']
           */

          var rearg = flatRest(function (func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
          });
          /**
           * Creates a function that invokes `func` with the `this` binding of the
           * created function and arguments from `start` and beyond provided as
           * an array.
           *
           * **Note:** This method is based on the
           * [rest parameter](https://mdn.io/rest_parameters).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.rest(function(what, names) {
           *   return what + ' ' + _.initial(names).join(', ') +
           *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
           * });
           *
           * say('hello', 'fred', 'barney', 'pebbles');
           * // => 'hello fred, barney, & pebbles'
           */

          function rest(func, start) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            start = start === undefined ? start : toInteger(start);
            return baseRest(func, start);
          }
          /**
           * Creates a function that invokes `func` with the `this` binding of the
           * create function and an array of arguments much like
           * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
           *
           * **Note:** This method is based on the
           * [spread operator](https://mdn.io/spread_operator).
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Function
           * @param {Function} func The function to spread arguments over.
           * @param {number} [start=0] The start position of the spread.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.spread(function(who, what) {
           *   return who + ' says ' + what;
           * });
           *
           * say(['fred', 'hello']);
           * // => 'fred says hello'
           *
           * var numbers = Promise.all([
           *   Promise.resolve(40),
           *   Promise.resolve(36)
           * ]);
           *
           * numbers.then(_.spread(function(x, y) {
           *   return x + y;
           * }));
           * // => a Promise of 76
           */


          function spread(func, start) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function (args) {
              var array = args[start],
                  otherArgs = castSlice(args, 0, start);

              if (array) {
                arrayPush(otherArgs, array);
              }

              return apply(func, this, otherArgs);
            });
          }
          /**
           * Creates a throttled function that only invokes `func` at most once per
           * every `wait` milliseconds. The throttled function comes with a `cancel`
           * method to cancel delayed `func` invocations and a `flush` method to
           * immediately invoke them. Provide `options` to indicate whether `func`
           * should be invoked on the leading and/or trailing edge of the `wait`
           * timeout. The `func` is invoked with the last arguments provided to the
           * throttled function. Subsequent calls to the throttled function return the
           * result of the last `func` invocation.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is
           * invoked on the trailing edge of the timeout only if the throttled function
           * is invoked more than once during the `wait` timeout.
           *
           * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
           * until to the next tick, similar to `setTimeout` with a timeout of `0`.
           *
           * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
           * for details over the differences between `_.throttle` and `_.debounce`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to throttle.
           * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.leading=true]
           *  Specify invoking on the leading edge of the timeout.
           * @param {boolean} [options.trailing=true]
           *  Specify invoking on the trailing edge of the timeout.
           * @returns {Function} Returns the new throttled function.
           * @example
           *
           * // Avoid excessively updating the position while scrolling.
           * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
           *
           * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
           * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
           * jQuery(element).on('click', throttled);
           *
           * // Cancel the trailing throttled invocation.
           * jQuery(window).on('popstate', throttled.cancel);
           */


          function throttle(func, wait, options) {
            var leading = true,
                trailing = true;

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }

            if (isObject(options)) {
              leading = 'leading' in options ? !!options.leading : leading;
              trailing = 'trailing' in options ? !!options.trailing : trailing;
            }

            return debounce(func, wait, {
              'leading': leading,
              'maxWait': wait,
              'trailing': trailing
            });
          }
          /**
           * Creates a function that accepts up to one argument, ignoring any
           * additional arguments.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to cap arguments for.
           * @returns {Function} Returns the new capped function.
           * @example
           *
           * _.map(['6', '8', '10'], _.unary(parseInt));
           * // => [6, 8, 10]
           */


          function unary(func) {
            return ary(func, 1);
          }
          /**
           * Creates a function that provides `value` to `wrapper` as its first
           * argument. Any additional arguments provided to the function are appended
           * to those provided to the `wrapper`. The wrapper is invoked with the `this`
           * binding of the created function.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {*} value The value to wrap.
           * @param {Function} [wrapper=identity] The wrapper function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var p = _.wrap(_.escape, function(func, text) {
           *   return '<p>' + func(text) + '</p>';
           * });
           *
           * p('fred, barney, & pebbles');
           * // => '<p>fred, barney, &amp; pebbles</p>'
           */


          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          /*------------------------------------------------------------------------*/

          /**
           * Casts `value` as an array if it's not one.
           *
           * @static
           * @memberOf _
           * @since 4.4.0
           * @category Lang
           * @param {*} value The value to inspect.
           * @returns {Array} Returns the cast array.
           * @example
           *
           * _.castArray(1);
           * // => [1]
           *
           * _.castArray({ 'a': 1 });
           * // => [{ 'a': 1 }]
           *
           * _.castArray('abc');
           * // => ['abc']
           *
           * _.castArray(null);
           * // => [null]
           *
           * _.castArray(undefined);
           * // => [undefined]
           *
           * _.castArray();
           * // => []
           *
           * var array = [1, 2, 3];
           * console.log(_.castArray(array) === array);
           * // => true
           */


          function castArray() {
            if (!arguments.length) {
              return [];
            }

            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          /**
           * Creates a shallow clone of `value`.
           *
           * **Note:** This method is loosely based on the
           * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
           * and supports cloning arrays, array buffers, booleans, date objects, maps,
           * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
           * arrays. The own enumerable properties of `arguments` objects are cloned
           * as plain objects. An empty object is returned for uncloneable values such
           * as error objects, functions, DOM nodes, and WeakMaps.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to clone.
           * @returns {*} Returns the cloned value.
           * @see _.cloneDeep
           * @example
           *
           * var objects = [{ 'a': 1 }, { 'b': 2 }];
           *
           * var shallow = _.clone(objects);
           * console.log(shallow[0] === objects[0]);
           * // => true
           */


          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          /**
           * This method is like `_.clone` except that it accepts `customizer` which
           * is invoked to produce the cloned value. If `customizer` returns `undefined`,
           * cloning is handled by the method instead. The `customizer` is invoked with
           * up to four arguments; (value [, index|key, object, stack]).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to clone.
           * @param {Function} [customizer] The function to customize cloning.
           * @returns {*} Returns the cloned value.
           * @see _.cloneDeepWith
           * @example
           *
           * function customizer(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(false);
           *   }
           * }
           *
           * var el = _.cloneWith(document.body, customizer);
           *
           * console.log(el === document.body);
           * // => false
           * console.log(el.nodeName);
           * // => 'BODY'
           * console.log(el.childNodes.length);
           * // => 0
           */


          function cloneWith(value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          /**
           * This method is like `_.clone` except that it recursively clones `value`.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Lang
           * @param {*} value The value to recursively clone.
           * @returns {*} Returns the deep cloned value.
           * @see _.clone
           * @example
           *
           * var objects = [{ 'a': 1 }, { 'b': 2 }];
           *
           * var deep = _.cloneDeep(objects);
           * console.log(deep[0] === objects[0]);
           * // => false
           */


          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          /**
           * This method is like `_.cloneWith` except that it recursively clones `value`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to recursively clone.
           * @param {Function} [customizer] The function to customize cloning.
           * @returns {*} Returns the deep cloned value.
           * @see _.cloneWith
           * @example
           *
           * function customizer(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(true);
           *   }
           * }
           *
           * var el = _.cloneDeepWith(document.body, customizer);
           *
           * console.log(el === document.body);
           * // => false
           * console.log(el.nodeName);
           * // => 'BODY'
           * console.log(el.childNodes.length);
           * // => 20
           */


          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          /**
           * Checks if `object` conforms to `source` by invoking the predicate
           * properties of `source` with the corresponding property values of `object`.
           *
           * **Note:** This method is equivalent to `_.conforms` when `source` is
           * partially applied.
           *
           * @static
           * @memberOf _
           * @since 4.14.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property predicates to conform to.
           * @returns {boolean} Returns `true` if `object` conforms, else `false`.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           *
           * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
           * // => true
           *
           * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
           * // => false
           */


          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          /**
           * Performs a
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * comparison between two values to determine if they are equivalent.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.eq(object, object);
           * // => true
           *
           * _.eq(object, other);
           * // => false
           *
           * _.eq('a', 'a');
           * // => true
           *
           * _.eq('a', Object('a'));
           * // => false
           *
           * _.eq(NaN, NaN);
           * // => true
           */


          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          /**
           * Checks if `value` is greater than `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than `other`,
           *  else `false`.
           * @see _.lt
           * @example
           *
           * _.gt(3, 1);
           * // => true
           *
           * _.gt(3, 3);
           * // => false
           *
           * _.gt(1, 3);
           * // => false
           */


          var gt = createRelationalOperation(baseGt);
          /**
           * Checks if `value` is greater than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than or equal to
           *  `other`, else `false`.
           * @see _.lte
           * @example
           *
           * _.gte(3, 1);
           * // => true
           *
           * _.gte(3, 3);
           * // => true
           *
           * _.gte(1, 3);
           * // => false
           */

          var gte = createRelationalOperation(function (value, other) {
            return value >= other;
          });
          /**
           * Checks if `value` is likely an `arguments` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           *  else `false`.
           * @example
           *
           * _.isArguments(function() { return arguments; }());
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */

          var isArguments = baseIsArguments(function () {
            return arguments;
          }()) ? baseIsArguments : function (value) {
            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
          };
          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(document.body.children);
           * // => false
           *
           * _.isArray('abc');
           * // => false
           *
           * _.isArray(_.noop);
           * // => false
           */

          var isArray = Array.isArray;
          /**
           * Checks if `value` is classified as an `ArrayBuffer` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
           * @example
           *
           * _.isArrayBuffer(new ArrayBuffer(2));
           * // => true
           *
           * _.isArrayBuffer(new Array(2));
           * // => false
           */

          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          /**
           * Checks if `value` is array-like. A value is considered array-like if it's
           * not a function and has a `value.length` that's an integer greater than or
           * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
           * @example
           *
           * _.isArrayLike([1, 2, 3]);
           * // => true
           *
           * _.isArrayLike(document.body.children);
           * // => true
           *
           * _.isArrayLike('abc');
           * // => true
           *
           * _.isArrayLike(_.noop);
           * // => false
           */

          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          /**
           * This method is like `_.isArrayLike` except that it also checks if `value`
           * is an object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array-like object,
           *  else `false`.
           * @example
           *
           * _.isArrayLikeObject([1, 2, 3]);
           * // => true
           *
           * _.isArrayLikeObject(document.body.children);
           * // => true
           *
           * _.isArrayLikeObject('abc');
           * // => false
           *
           * _.isArrayLikeObject(_.noop);
           * // => false
           */


          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          /**
           * Checks if `value` is classified as a boolean primitive or object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
           * @example
           *
           * _.isBoolean(false);
           * // => true
           *
           * _.isBoolean(null);
           * // => false
           */


          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */


          var isBuffer = nativeIsBuffer || stubFalse;
          /**
           * Checks if `value` is classified as a `Date` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
           * @example
           *
           * _.isDate(new Date);
           * // => true
           *
           * _.isDate('Mon April 23 2012');
           * // => false
           */

          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          /**
           * Checks if `value` is likely a DOM element.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
           * @example
           *
           * _.isElement(document.body);
           * // => true
           *
           * _.isElement('<body>');
           * // => false
           */

          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }
          /**
           * Checks if `value` is an empty object, collection, map, or set.
           *
           * Objects are considered empty if they have no own enumerable string keyed
           * properties.
           *
           * Array-like values such as `arguments` objects, arrays, buffers, strings, or
           * jQuery-like collections are considered empty if they have a `length` of `0`.
           * Similarly, maps and sets are considered empty if they have a `size` of `0`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is empty, else `false`.
           * @example
           *
           * _.isEmpty(null);
           * // => true
           *
           * _.isEmpty(true);
           * // => true
           *
           * _.isEmpty(1);
           * // => true
           *
           * _.isEmpty([1, 2, 3]);
           * // => false
           *
           * _.isEmpty({ 'a': 1 });
           * // => false
           */


          function isEmpty(value) {
            if (value == null) {
              return true;
            }

            if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }

            var tag = getTag(value);

            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }

            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }

            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }

            return true;
          }
          /**
           * Performs a deep comparison between two values to determine if they are
           * equivalent.
           *
           * **Note:** This method supports comparing arrays, array buffers, booleans,
           * date objects, error objects, maps, numbers, `Object` objects, regexes,
           * sets, strings, symbols, and typed arrays. `Object` objects are compared
           * by their own, not inherited, enumerable properties. Functions and DOM
           * nodes are compared by strict equality, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.isEqual(object, other);
           * // => true
           *
           * object === other;
           * // => false
           */


          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          /**
           * This method is like `_.isEqual` except that it accepts `customizer` which
           * is invoked to compare values. If `customizer` returns `undefined`, comparisons
           * are handled by the method instead. The `customizer` is invoked with up to
           * six arguments: (objValue, othValue [, index|key, object, other, stack]).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * function isGreeting(value) {
           *   return /^h(?:i|ello)$/.test(value);
           * }
           *
           * function customizer(objValue, othValue) {
           *   if (isGreeting(objValue) && isGreeting(othValue)) {
           *     return true;
           *   }
           * }
           *
           * var array = ['hello', 'goodbye'];
           * var other = ['hi', 'goodbye'];
           *
           * _.isEqualWith(array, other, customizer);
           * // => true
           */


          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
          }
          /**
           * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
           * `SyntaxError`, `TypeError`, or `URIError` object.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
           * @example
           *
           * _.isError(new Error);
           * // => true
           *
           * _.isError(Error);
           * // => false
           */


          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }

            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
          }
          /**
           * Checks if `value` is a finite primitive number.
           *
           * **Note:** This method is based on
           * [`Number.isFinite`](https://mdn.io/Number/isFinite).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
           * @example
           *
           * _.isFinite(3);
           * // => true
           *
           * _.isFinite(Number.MIN_VALUE);
           * // => true
           *
           * _.isFinite(Infinity);
           * // => false
           *
           * _.isFinite('3');
           * // => false
           */


          function isFinite(value) {
            return typeof value == 'number' && nativeIsFinite(value);
          }
          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */


          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            } // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 9 which returns 'object' for typed arrays and other constructors.


            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          /**
           * Checks if `value` is an integer.
           *
           * **Note:** This method is based on
           * [`Number.isInteger`](https://mdn.io/Number/isInteger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
           * @example
           *
           * _.isInteger(3);
           * // => true
           *
           * _.isInteger(Number.MIN_VALUE);
           * // => false
           *
           * _.isInteger(Infinity);
           * // => false
           *
           * _.isInteger('3');
           * // => false
           */


          function isInteger(value) {
            return typeof value == 'number' && value == toInteger(value);
          }
          /**
           * Checks if `value` is a valid array-like length.
           *
           * **Note:** This method is loosely based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
           * @example
           *
           * _.isLength(3);
           * // => true
           *
           * _.isLength(Number.MIN_VALUE);
           * // => false
           *
           * _.isLength(Infinity);
           * // => false
           *
           * _.isLength('3');
           * // => false
           */


          function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          /**
           * Checks if `value` is the
           * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
           * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(_.noop);
           * // => true
           *
           * _.isObject(null);
           * // => false
           */


          function isObject(value) {
            var type = typeof value;
            return value != null && (type == 'object' || type == 'function');
          }
          /**
           * Checks if `value` is object-like. A value is object-like if it's not `null`
           * and has a `typeof` result of "object".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
           * @example
           *
           * _.isObjectLike({});
           * // => true
           *
           * _.isObjectLike([1, 2, 3]);
           * // => true
           *
           * _.isObjectLike(_.noop);
           * // => false
           *
           * _.isObjectLike(null);
           * // => false
           */


          function isObjectLike(value) {
            return value != null && typeof value == 'object';
          }
          /**
           * Checks if `value` is classified as a `Map` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a map, else `false`.
           * @example
           *
           * _.isMap(new Map);
           * // => true
           *
           * _.isMap(new WeakMap);
           * // => false
           */


          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          /**
           * Performs a partial deep comparison between `object` and `source` to
           * determine if `object` contains equivalent property values.
           *
           * **Note:** This method is equivalent to `_.matches` when `source` is
           * partially applied.
           *
           * Partial comparisons will match empty array and empty object `source`
           * values against any array or object value, respectively. See `_.isEqual`
           * for a list of supported value comparisons.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           *
           * _.isMatch(object, { 'b': 2 });
           * // => true
           *
           * _.isMatch(object, { 'b': 1 });
           * // => false
           */

          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          /**
           * This method is like `_.isMatch` except that it accepts `customizer` which
           * is invoked to compare values. If `customizer` returns `undefined`, comparisons
           * are handled by the method instead. The `customizer` is invoked with five
           * arguments: (objValue, srcValue, index|key, object, source).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           * @example
           *
           * function isGreeting(value) {
           *   return /^h(?:i|ello)$/.test(value);
           * }
           *
           * function customizer(objValue, srcValue) {
           *   if (isGreeting(objValue) && isGreeting(srcValue)) {
           *     return true;
           *   }
           * }
           *
           * var object = { 'greeting': 'hello' };
           * var source = { 'greeting': 'hi' };
           *
           * _.isMatchWith(object, source, customizer);
           * // => true
           */


          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          /**
           * Checks if `value` is `NaN`.
           *
           * **Note:** This method is based on
           * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
           * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
           * `undefined` and other non-number values.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
           * @example
           *
           * _.isNaN(NaN);
           * // => true
           *
           * _.isNaN(new Number(NaN));
           * // => true
           *
           * isNaN(undefined);
           * // => true
           *
           * _.isNaN(undefined);
           * // => false
           */


          function isNaN(value) {
            // An `NaN` primitive is the only value that is not equal to itself.
            // Perform the `toStringTag` check first to avoid errors with some
            // ActiveX objects in IE.
            return isNumber(value) && value != +value;
          }
          /**
           * Checks if `value` is a pristine native function.
           *
           * **Note:** This method can't reliably detect native functions in the presence
           * of the core-js package because core-js circumvents this kind of detection.
           * Despite multiple requests, the core-js maintainer has made it clear: any
           * attempt to fix the detection will be obstructed. As a result, we're left
           * with little choice but to throw an error. Unfortunately, this also affects
           * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
           * which rely on core-js.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           * @example
           *
           * _.isNative(Array.prototype.push);
           * // => true
           *
           * _.isNative(_);
           * // => false
           */


          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error(CORE_ERROR_TEXT);
            }

            return baseIsNative(value);
          }
          /**
           * Checks if `value` is `null`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
           * @example
           *
           * _.isNull(null);
           * // => true
           *
           * _.isNull(void 0);
           * // => false
           */


          function isNull(value) {
            return value === null;
          }
          /**
           * Checks if `value` is `null` or `undefined`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
           * @example
           *
           * _.isNil(null);
           * // => true
           *
           * _.isNil(void 0);
           * // => true
           *
           * _.isNil(NaN);
           * // => false
           */


          function isNil(value) {
            return value == null;
          }
          /**
           * Checks if `value` is classified as a `Number` primitive or object.
           *
           * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
           * classified as numbers, use the `_.isFinite` method.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a number, else `false`.
           * @example
           *
           * _.isNumber(3);
           * // => true
           *
           * _.isNumber(Number.MIN_VALUE);
           * // => true
           *
           * _.isNumber(Infinity);
           * // => true
           *
           * _.isNumber('3');
           * // => false
           */


          function isNumber(value) {
            return typeof value == 'number' || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          /**
           * Checks if `value` is a plain object, that is, an object created by the
           * `Object` constructor or one with a `[[Prototype]]` of `null`.
           *
           * @static
           * @memberOf _
           * @since 0.8.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * _.isPlainObject(new Foo);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           *
           * _.isPlainObject(Object.create(null));
           * // => true
           */


          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }

            var proto = getPrototype(value);

            if (proto === null) {
              return true;
            }

            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          /**
           * Checks if `value` is classified as a `RegExp` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
           * @example
           *
           * _.isRegExp(/abc/);
           * // => true
           *
           * _.isRegExp('/abc/');
           * // => false
           */


          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          /**
           * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
           * double precision number which isn't the result of a rounded unsafe integer.
           *
           * **Note:** This method is based on
           * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
           * @example
           *
           * _.isSafeInteger(3);
           * // => true
           *
           * _.isSafeInteger(Number.MIN_VALUE);
           * // => false
           *
           * _.isSafeInteger(Infinity);
           * // => false
           *
           * _.isSafeInteger('3');
           * // => false
           */

          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          /**
           * Checks if `value` is classified as a `Set` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a set, else `false`.
           * @example
           *
           * _.isSet(new Set);
           * // => true
           *
           * _.isSet(new WeakSet);
           * // => false
           */


          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          /**
           * Checks if `value` is classified as a `String` primitive or object.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a string, else `false`.
           * @example
           *
           * _.isString('abc');
           * // => true
           *
           * _.isString(1);
           * // => false
           */

          function isString(value) {
            return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          /**
           * Checks if `value` is classified as a `Symbol` primitive or object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
           * @example
           *
           * _.isSymbol(Symbol.iterator);
           * // => true
           *
           * _.isSymbol('abc');
           * // => false
           */


          function isSymbol(value) {
            return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          /**
           * Checks if `value` is classified as a typed array.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           * @example
           *
           * _.isTypedArray(new Uint8Array);
           * // => true
           *
           * _.isTypedArray([]);
           * // => false
           */


          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          /**
           * Checks if `value` is `undefined`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
           * @example
           *
           * _.isUndefined(void 0);
           * // => true
           *
           * _.isUndefined(null);
           * // => false
           */

          function isUndefined(value) {
            return value === undefined;
          }
          /**
           * Checks if `value` is classified as a `WeakMap` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
           * @example
           *
           * _.isWeakMap(new WeakMap);
           * // => true
           *
           * _.isWeakMap(new Map);
           * // => false
           */


          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          /**
           * Checks if `value` is classified as a `WeakSet` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
           * @example
           *
           * _.isWeakSet(new WeakSet);
           * // => true
           *
           * _.isWeakSet(new Set);
           * // => false
           */


          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          /**
           * Checks if `value` is less than `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than `other`,
           *  else `false`.
           * @see _.gt
           * @example
           *
           * _.lt(1, 3);
           * // => true
           *
           * _.lt(3, 3);
           * // => false
           *
           * _.lt(3, 1);
           * // => false
           */


          var lt = createRelationalOperation(baseLt);
          /**
           * Checks if `value` is less than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than or equal to
           *  `other`, else `false`.
           * @see _.gte
           * @example
           *
           * _.lte(1, 3);
           * // => true
           *
           * _.lte(3, 3);
           * // => true
           *
           * _.lte(3, 1);
           * // => false
           */

          var lte = createRelationalOperation(function (value, other) {
            return value <= other;
          });
          /**
           * Converts `value` to an array.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Array} Returns the converted array.
           * @example
           *
           * _.toArray({ 'a': 1, 'b': 2 });
           * // => [1, 2]
           *
           * _.toArray('abc');
           * // => ['a', 'b', 'c']
           *
           * _.toArray(1);
           * // => []
           *
           * _.toArray(null);
           * // => []
           */

          function toArray(value) {
            if (!value) {
              return [];
            }

            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }

            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }

            var tag = getTag(value),
                func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          /**
           * Converts `value` to a finite number.
           *
           * @static
           * @memberOf _
           * @since 4.12.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted number.
           * @example
           *
           * _.toFinite(3.2);
           * // => 3.2
           *
           * _.toFinite(Number.MIN_VALUE);
           * // => 5e-324
           *
           * _.toFinite(Infinity);
           * // => 1.7976931348623157e+308
           *
           * _.toFinite('3.2');
           * // => 3.2
           */


          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }

            value = toNumber(value);

            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }

            return value === value ? value : 0;
          }
          /**
           * Converts `value` to an integer.
           *
           * **Note:** This method is loosely based on
           * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toInteger(3.2);
           * // => 3
           *
           * _.toInteger(Number.MIN_VALUE);
           * // => 0
           *
           * _.toInteger(Infinity);
           * // => 1.7976931348623157e+308
           *
           * _.toInteger('3.2');
           * // => 3
           */


          function toInteger(value) {
            var result = toFinite(value),
                remainder = result % 1;
            return result === result ? remainder ? result - remainder : result : 0;
          }
          /**
           * Converts `value` to an integer suitable for use as the length of an
           * array-like object.
           *
           * **Note:** This method is based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toLength(3.2);
           * // => 3
           *
           * _.toLength(Number.MIN_VALUE);
           * // => 0
           *
           * _.toLength(Infinity);
           * // => 4294967295
           *
           * _.toLength('3.2');
           * // => 3
           */


          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          /**
           * Converts `value` to a number.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to process.
           * @returns {number} Returns the number.
           * @example
           *
           * _.toNumber(3.2);
           * // => 3.2
           *
           * _.toNumber(Number.MIN_VALUE);
           * // => 5e-324
           *
           * _.toNumber(Infinity);
           * // => Infinity
           *
           * _.toNumber('3.2');
           * // => 3.2
           */


          function toNumber(value) {
            if (typeof value == 'number') {
              return value;
            }

            if (isSymbol(value)) {
              return NAN;
            }

            if (isObject(value)) {
              var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
              value = isObject(other) ? other + '' : other;
            }

            if (typeof value != 'string') {
              return value === 0 ? value : +value;
            }

            value = value.replace(reTrim, '');
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          /**
           * Converts `value` to a plain object flattening inherited enumerable string
           * keyed properties of `value` to own properties of the plain object.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Object} Returns the converted plain object.
           * @example
           *
           * function Foo() {
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.assign({ 'a': 1 }, new Foo);
           * // => { 'a': 1, 'b': 2 }
           *
           * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
           * // => { 'a': 1, 'b': 2, 'c': 3 }
           */


          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          /**
           * Converts `value` to a safe integer. A safe integer can be compared and
           * represented correctly.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toSafeInteger(3.2);
           * // => 3
           *
           * _.toSafeInteger(Number.MIN_VALUE);
           * // => 0
           *
           * _.toSafeInteger(Infinity);
           * // => 9007199254740991
           *
           * _.toSafeInteger('3.2');
           * // => 3
           */


          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          /**
           * Converts `value` to a string. An empty string is returned for `null`
           * and `undefined` values. The sign of `-0` is preserved.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.toString(null);
           * // => ''
           *
           * _.toString(-0);
           * // => '-0'
           *
           * _.toString([1, 2, 3]);
           * // => '1,2,3'
           */


          function toString(value) {
            return value == null ? '' : baseToString(value);
          }
          /*------------------------------------------------------------------------*/

          /**
           * Assigns own enumerable string keyed properties of source objects to the
           * destination object. Source objects are applied from left to right.
           * Subsequent sources overwrite property assignments of previous sources.
           *
           * **Note:** This method mutates `object` and is loosely based on
           * [`Object.assign`](https://mdn.io/Object/assign).
           *
           * @static
           * @memberOf _
           * @since 0.10.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.assignIn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * function Bar() {
           *   this.c = 3;
           * }
           *
           * Foo.prototype.b = 2;
           * Bar.prototype.d = 4;
           *
           * _.assign({ 'a': 0 }, new Foo, new Bar);
           * // => { 'a': 1, 'c': 3 }
           */


          var assign = createAssigner(function (object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }

            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          /**
           * This method is like `_.assign` except that it iterates over own and
           * inherited source properties.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias extend
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.assign
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * function Bar() {
           *   this.c = 3;
           * }
           *
           * Foo.prototype.b = 2;
           * Bar.prototype.d = 4;
           *
           * _.assignIn({ 'a': 0 }, new Foo, new Bar);
           * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
           */

          var assignIn = createAssigner(function (object, source) {
            copyObject(source, keysIn(source), object);
          });
          /**
           * This method is like `_.assignIn` except that it accepts `customizer`
           * which is invoked to produce the assigned values. If `customizer` returns
           * `undefined`, assignment is handled by the method instead. The `customizer`
           * is invoked with five arguments: (objValue, srcValue, key, object, source).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias extendWith
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @see _.assignWith
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   return _.isUndefined(objValue) ? srcValue : objValue;
           * }
           *
           * var defaults = _.partialRight(_.assignInWith, customizer);
           *
           * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */

          var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          /**
           * This method is like `_.assign` except that it accepts `customizer`
           * which is invoked to produce the assigned values. If `customizer` returns
           * `undefined`, assignment is handled by the method instead. The `customizer`
           * is invoked with five arguments: (objValue, srcValue, key, object, source).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @see _.assignInWith
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   return _.isUndefined(objValue) ? srcValue : objValue;
           * }
           *
           * var defaults = _.partialRight(_.assignWith, customizer);
           *
           * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */

          var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          /**
           * Creates an array of values corresponding to `paths` of `object`.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Array} Returns the picked values.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
           *
           * _.at(object, ['a[0].b.c', 'a[1]']);
           * // => [3, 4]
           */

          var at = flatRest(baseAt);
          /**
           * Creates an object that inherits from the `prototype` object. If a
           * `properties` object is given, its own enumerable string keyed properties
           * are assigned to the created object.
           *
           * @static
           * @memberOf _
           * @since 2.3.0
           * @category Object
           * @param {Object} prototype The object to inherit from.
           * @param {Object} [properties] The properties to assign to the object.
           * @returns {Object} Returns the new object.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * function Circle() {
           *   Shape.call(this);
           * }
           *
           * Circle.prototype = _.create(Shape.prototype, {
           *   'constructor': Circle
           * });
           *
           * var circle = new Circle;
           * circle instanceof Circle;
           * // => true
           *
           * circle instanceof Shape;
           * // => true
           */

          function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties == null ? result : baseAssign(result, properties);
          }
          /**
           * Assigns own and inherited enumerable string keyed properties of source
           * objects to the destination object for all destination properties that
           * resolve to `undefined`. Source objects are applied from left to right.
           * Once a property is set, additional values of the same property are ignored.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.defaultsDeep
           * @example
           *
           * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */


          var defaults = baseRest(function (object, sources) {
            object = Object(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined;

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }

            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;

              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];

                if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }

            return object;
          });
          /**
           * This method is like `_.defaults` except that it recursively assigns
           * default properties.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.defaults
           * @example
           *
           * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
           * // => { 'a': { 'b': 2, 'c': 3 } }
           */

          var defaultsDeep = baseRest(function (args) {
            args.push(undefined, customDefaultsMerge);
            return apply(mergeWith, undefined, args);
          });
          /**
           * This method is like `_.find` except that it returns the key of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {string|undefined} Returns the key of the matched element,
           *  else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findKey(users, function(o) { return o.age < 40; });
           * // => 'barney' (iteration order is not guaranteed)
           *
           * // The `_.matches` iteratee shorthand.
           * _.findKey(users, { 'age': 1, 'active': true });
           * // => 'pebbles'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findKey(users, ['active', false]);
           * // => 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.findKey(users, 'active');
           * // => 'barney'
           */

          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          /**
           * This method is like `_.findKey` except that it iterates over elements of
           * a collection in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {string|undefined} Returns the key of the matched element,
           *  else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findLastKey(users, function(o) { return o.age < 40; });
           * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
           *
           * // The `_.matches` iteratee shorthand.
           * _.findLastKey(users, { 'age': 36, 'active': true });
           * // => 'barney'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findLastKey(users, ['active', false]);
           * // => 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.findLastKey(users, 'active');
           * // => 'pebbles'
           */


          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          /**
           * Iterates over own and inherited enumerable string keyed properties of an
           * object and invokes `iteratee` for each property. The iteratee is invoked
           * with three arguments: (value, key, object). Iteratee functions may exit
           * iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 0.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forInRight
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forIn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
           */


          function forIn(object, iteratee) {
            return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
          }
          /**
           * This method is like `_.forIn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forIn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forInRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
           */


          function forInRight(object, iteratee) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
          }
          /**
           * Iterates over own enumerable string keyed properties of an object and
           * invokes `iteratee` for each property. The iteratee is invoked with three
           * arguments: (value, key, object). Iteratee functions may exit iteration
           * early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 0.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forOwnRight
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a' then 'b' (iteration order is not guaranteed).
           */


          function forOwn(object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee, 3));
          }
          /**
           * This method is like `_.forOwn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forOwn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwnRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
           */


          function forOwnRight(object, iteratee) {
            return object && baseForOwnRight(object, getIteratee(iteratee, 3));
          }
          /**
           * Creates an array of function property names from own enumerable properties
           * of `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns the function names.
           * @see _.functionsIn
           * @example
           *
           * function Foo() {
           *   this.a = _.constant('a');
           *   this.b = _.constant('b');
           * }
           *
           * Foo.prototype.c = _.constant('c');
           *
           * _.functions(new Foo);
           * // => ['a', 'b']
           */


          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          /**
           * Creates an array of function property names from own and inherited
           * enumerable properties of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns the function names.
           * @see _.functions
           * @example
           *
           * function Foo() {
           *   this.a = _.constant('a');
           *   this.b = _.constant('b');
           * }
           *
           * Foo.prototype.c = _.constant('c');
           *
           * _.functionsIn(new Foo);
           * // => ['a', 'b', 'c']
           */


          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          /**
           * Gets the value at `path` of `object`. If the resolved value is
           * `undefined`, the `defaultValue` is returned in its place.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @param {*} [defaultValue] The value returned for `undefined` resolved values.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.get(object, 'a[0].b.c');
           * // => 3
           *
           * _.get(object, ['a', '0', 'b', 'c']);
           * // => 3
           *
           * _.get(object, 'a.b.c', 'default');
           * // => 'default'
           */


          function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
          }
          /**
           * Checks if `path` is a direct property of `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           * @example
           *
           * var object = { 'a': { 'b': 2 } };
           * var other = _.create({ 'a': _.create({ 'b': 2 }) });
           *
           * _.has(object, 'a');
           * // => true
           *
           * _.has(object, 'a.b');
           * // => true
           *
           * _.has(object, ['a', 'b']);
           * // => true
           *
           * _.has(other, 'a');
           * // => false
           */


          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          /**
           * Checks if `path` is a direct or inherited property of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           * @example
           *
           * var object = _.create({ 'a': _.create({ 'b': 2 }) });
           *
           * _.hasIn(object, 'a');
           * // => true
           *
           * _.hasIn(object, 'a.b');
           * // => true
           *
           * _.hasIn(object, ['a', 'b']);
           * // => true
           *
           * _.hasIn(object, 'b');
           * // => false
           */


          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          /**
           * Creates an object composed of the inverted keys and values of `object`.
           * If `object` contains duplicate values, subsequent values overwrite
           * property assignments of previous values.
           *
           * @static
           * @memberOf _
           * @since 0.7.0
           * @category Object
           * @param {Object} object The object to invert.
           * @returns {Object} Returns the new inverted object.
           * @example
           *
           * var object = { 'a': 1, 'b': 2, 'c': 1 };
           *
           * _.invert(object);
           * // => { '1': 'c', '2': 'b' }
           */


          var invert = createInverter(function (result, value, key) {
            if (value != null && typeof value.toString != 'function') {
              value = nativeObjectToString.call(value);
            }

            result[value] = key;
          }, constant(identity));
          /**
           * This method is like `_.invert` except that the inverted object is generated
           * from the results of running each element of `object` thru `iteratee`. The
           * corresponding inverted value of each inverted key is an array of keys
           * responsible for generating the inverted value. The iteratee is invoked
           * with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.1.0
           * @category Object
           * @param {Object} object The object to invert.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Object} Returns the new inverted object.
           * @example
           *
           * var object = { 'a': 1, 'b': 2, 'c': 1 };
           *
           * _.invertBy(object);
           * // => { '1': ['a', 'c'], '2': ['b'] }
           *
           * _.invertBy(object, function(value) {
           *   return 'group' + value;
           * });
           * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
           */

          var invertBy = createInverter(function (result, value, key) {
            if (value != null && typeof value.toString != 'function') {
              value = nativeObjectToString.call(value);
            }

            if (hasOwnProperty.call(result, value)) {
              result[value].push(key);
            } else {
              result[value] = [key];
            }
          }, getIteratee);
          /**
           * Invokes the method at `path` of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the method to invoke.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {*} Returns the result of the invoked method.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
           *
           * _.invoke(object, 'a[0].b.c.slice', 1, 3);
           * // => [2, 3]
           */

          var invoke = baseRest(baseInvoke);
          /**
           * Creates an array of the own enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects. See the
           * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * for more details.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keys(new Foo);
           * // => ['a', 'b'] (iteration order is not guaranteed)
           *
           * _.keys('hi');
           * // => ['0', '1']
           */

          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          /**
           * Creates an array of the own and inherited enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keysIn(new Foo);
           * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
           */


          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          /**
           * The opposite of `_.mapValues`; this method creates an object with the
           * same values as `object` and keys generated by running each own enumerable
           * string keyed property of `object` thru `iteratee`. The iteratee is invoked
           * with three arguments: (value, key, object).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns the new mapped object.
           * @see _.mapValues
           * @example
           *
           * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
           *   return key + value;
           * });
           * // => { 'a1': 1, 'b2': 2 }
           */


          function mapKeys(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, iteratee(value, key, object), value);
            });
            return result;
          }
          /**
           * Creates an object with the same keys as `object` and values generated
           * by running each own enumerable string keyed property of `object` thru
           * `iteratee`. The iteratee is invoked with three arguments:
           * (value, key, object).
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns the new mapped object.
           * @see _.mapKeys
           * @example
           *
           * var users = {
           *   'fred':    { 'user': 'fred',    'age': 40 },
           *   'pebbles': { 'user': 'pebbles', 'age': 1 }
           * };
           *
           * _.mapValues(users, function(o) { return o.age; });
           * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
           *
           * // The `_.property` iteratee shorthand.
           * _.mapValues(users, 'age');
           * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
           */


          function mapValues(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, key, iteratee(value, key, object));
            });
            return result;
          }
          /**
           * This method is like `_.assign` except that it recursively merges own and
           * inherited enumerable string keyed properties of source objects into the
           * destination object. Source properties that resolve to `undefined` are
           * skipped if a destination value exists. Array and plain object properties
           * are merged recursively. Other objects and value types are overridden by
           * assignment. Source objects are applied from left to right. Subsequent
           * sources overwrite property assignments of previous sources.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {
           *   'a': [{ 'b': 2 }, { 'd': 4 }]
           * };
           *
           * var other = {
           *   'a': [{ 'c': 3 }, { 'e': 5 }]
           * };
           *
           * _.merge(object, other);
           * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
           */


          var merge = createAssigner(function (object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          /**
           * This method is like `_.merge` except that it accepts `customizer` which
           * is invoked to produce the merged values of the destination and source
           * properties. If `customizer` returns `undefined`, merging is handled by the
           * method instead. The `customizer` is invoked with six arguments:
           * (objValue, srcValue, key, object, source, stack).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} customizer The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   if (_.isArray(objValue)) {
           *     return objValue.concat(srcValue);
           *   }
           * }
           *
           * var object = { 'a': [1], 'b': [2] };
           * var other = { 'a': [3], 'b': [4] };
           *
           * _.mergeWith(object, other, customizer);
           * // => { 'a': [1, 3], 'b': [2, 4] }
           */

          var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          /**
           * The opposite of `_.pick`; this method creates an object composed of the
           * own and inherited enumerable property paths of `object` that are not omitted.
           *
           * **Note:** This method is considerably slower than `_.pick`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {...(string|string[])} [paths] The property paths to omit.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.omit(object, ['a', 'c']);
           * // => { 'b': '2' }
           */

          var omit = flatRest(function (object, paths) {
            var result = {};

            if (object == null) {
              return result;
            }

            var isDeep = false;
            paths = arrayMap(paths, function (path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result);

            if (isDeep) {
              result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }

            var length = paths.length;

            while (length--) {
              baseUnset(result, paths[length]);
            }

            return result;
          });
          /**
           * The opposite of `_.pickBy`; this method creates an object composed of
           * the own and inherited enumerable string keyed properties of `object` that
           * `predicate` doesn't return truthy for. The predicate is invoked with two
           * arguments: (value, key).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The source object.
           * @param {Function} [predicate=_.identity] The function invoked per property.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.omitBy(object, _.isNumber);
           * // => { 'b': '2' }
           */

          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          /**
           * Creates an object composed of the picked `object` properties.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.pick(object, ['a', 'c']);
           * // => { 'a': 1, 'c': 3 }
           */


          var pick = flatRest(function (object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          /**
           * Creates an object composed of the `object` properties `predicate` returns
           * truthy for. The predicate is invoked with two arguments: (value, key).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The source object.
           * @param {Function} [predicate=_.identity] The function invoked per property.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.pickBy(object, _.isNumber);
           * // => { 'a': 1, 'c': 3 }
           */

          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }

            var props = arrayMap(getAllKeysIn(object), function (prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function (value, path) {
              return predicate(value, path[0]);
            });
          }
          /**
           * This method is like `_.get` except that if the resolved value is a
           * function it's invoked with the `this` binding of its parent object and
           * its result is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to resolve.
           * @param {*} [defaultValue] The value returned for `undefined` resolved values.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
           *
           * _.result(object, 'a[0].b.c1');
           * // => 3
           *
           * _.result(object, 'a[0].b.c2');
           * // => 4
           *
           * _.result(object, 'a[0].b.c3', 'default');
           * // => 'default'
           *
           * _.result(object, 'a[0].b.c3', _.constant('default'));
           * // => 'default'
           */


          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1,
                length = path.length; // Ensure the loop is entered when path is empty.

            if (!length) {
              length = 1;
              object = undefined;
            }

            while (++index < length) {
              var value = object == null ? undefined : object[toKey(path[index])];

              if (value === undefined) {
                index = length;
                value = defaultValue;
              }

              object = isFunction(value) ? value.call(object) : value;
            }

            return object;
          }
          /**
           * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
           * it's created. Arrays are created for missing index properties while objects
           * are created for all other missing properties. Use `_.setWith` to customize
           * `path` creation.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.set(object, 'a[0].b.c', 4);
           * console.log(object.a[0].b.c);
           * // => 4
           *
           * _.set(object, ['x', '0', 'y', 'z'], 5);
           * console.log(object.x[0].y.z);
           * // => 5
           */


          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          /**
           * This method is like `_.set` except that it accepts `customizer` which is
           * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
           * path creation is handled by the method instead. The `customizer` is invoked
           * with three arguments: (nsValue, key, nsObject).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {};
           *
           * _.setWith(object, '[0][1]', 'a', Object);
           * // => { '0': { '1': 'a' } }
           */


          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          /**
           * Creates an array of own enumerable string keyed-value pairs for `object`
           * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
           * entries are returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias entries
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the key-value pairs.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.toPairs(new Foo);
           * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
           */


          var toPairs = createToPairs(keys);
          /**
           * Creates an array of own and inherited enumerable string keyed-value pairs
           * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
           * or set, its entries are returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias entriesIn
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the key-value pairs.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.toPairsIn(new Foo);
           * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
           */

          var toPairsIn = createToPairs(keysIn);
          /**
           * An alternative to `_.reduce`; this method transforms `object` to a new
           * `accumulator` object which is the result of running each of its own
           * enumerable string keyed properties thru `iteratee`, with each invocation
           * potentially mutating the `accumulator` object. If `accumulator` is not
           * provided, a new object with the same `[[Prototype]]` will be used. The
           * iteratee is invoked with four arguments: (accumulator, value, key, object).
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 1.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The custom accumulator value.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * _.transform([2, 3, 4], function(result, n) {
           *   result.push(n *= n);
           *   return n % 2 == 0;
           * }, []);
           * // => [4, 9]
           *
           * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
           *   (result[value] || (result[value] = [])).push(key);
           * }, {});
           * // => { '1': ['a', 'c'], '2': ['b'] }
           */

          function transform(object, iteratee, accumulator) {
            var isArr = isArray(object),
                isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee = getIteratee(iteratee, 4);

            if (accumulator == null) {
              var Ctor = object && object.constructor;

              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }

            (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
              return iteratee(accumulator, value, index, object);
            });
            return accumulator;
          }
          /**
           * Removes the property at `path` of `object`.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to unset.
           * @returns {boolean} Returns `true` if the property is deleted, else `false`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 7 } }] };
           * _.unset(object, 'a[0].b.c');
           * // => true
           *
           * console.log(object);
           * // => { 'a': [{ 'b': {} }] };
           *
           * _.unset(object, ['a', '0', 'b', 'c']);
           * // => true
           *
           * console.log(object);
           * // => { 'a': [{ 'b': {} }] };
           */


          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          /**
           * This method is like `_.set` except that accepts `updater` to produce the
           * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
           * is invoked with one argument: (value).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {Function} updater The function to produce the updated value.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.update(object, 'a[0].b.c', function(n) { return n * n; });
           * console.log(object.a[0].b.c);
           * // => 9
           *
           * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
           * console.log(object.x[0].y.z);
           * // => 0
           */


          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          /**
           * This method is like `_.update` except that it accepts `customizer` which is
           * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
           * path creation is handled by the method instead. The `customizer` is invoked
           * with three arguments: (nsValue, key, nsObject).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {Function} updater The function to produce the updated value.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {};
           *
           * _.updateWith(object, '[0][1]', _.constant('a'), Object);
           * // => { '0': { '1': 'a' } }
           */


          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          /**
           * Creates an array of the own enumerable string keyed property values of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.values(new Foo);
           * // => [1, 2] (iteration order is not guaranteed)
           *
           * _.values('hi');
           * // => ['h', 'i']
           */


          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          /**
           * Creates an array of the own and inherited enumerable string keyed property
           * values of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.valuesIn(new Foo);
           * // => [1, 2, 3] (iteration order is not guaranteed)
           */


          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          /*------------------------------------------------------------------------*/

          /**
           * Clamps `number` within the inclusive `lower` and `upper` bounds.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Number
           * @param {number} number The number to clamp.
           * @param {number} [lower] The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the clamped number.
           * @example
           *
           * _.clamp(-10, -5, 5);
           * // => -5
           *
           * _.clamp(10, -5, 5);
           * // => 5
           */


          function clamp(number, lower, upper) {
            if (upper === undefined) {
              upper = lower;
              lower = undefined;
            }

            if (upper !== undefined) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }

            if (lower !== undefined) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }

            return baseClamp(toNumber(number), lower, upper);
          }
          /**
           * Checks if `n` is between `start` and up to, but not including, `end`. If
           * `end` is not specified, it's set to `start` with `start` then set to `0`.
           * If `start` is greater than `end` the params are swapped to support
           * negative ranges.
           *
           * @static
           * @memberOf _
           * @since 3.3.0
           * @category Number
           * @param {number} number The number to check.
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
           * @see _.range, _.rangeRight
           * @example
           *
           * _.inRange(3, 2, 4);
           * // => true
           *
           * _.inRange(4, 8);
           * // => true
           *
           * _.inRange(4, 2);
           * // => false
           *
           * _.inRange(2, 2);
           * // => false
           *
           * _.inRange(1.2, 2);
           * // => true
           *
           * _.inRange(5.2, 4);
           * // => false
           *
           * _.inRange(-3, -2, -6);
           * // => true
           */


          function inRange(number, start, end) {
            start = toFinite(start);

            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }

            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          /**
           * Produces a random number between the inclusive `lower` and `upper` bounds.
           * If only one argument is provided a number between `0` and the given number
           * is returned. If `floating` is `true`, or either `lower` or `upper` are
           * floats, a floating-point number is returned instead of an integer.
           *
           * **Note:** JavaScript follows the IEEE-754 standard for resolving
           * floating-point values which can produce unexpected results.
           *
           * @static
           * @memberOf _
           * @since 0.7.0
           * @category Number
           * @param {number} [lower=0] The lower bound.
           * @param {number} [upper=1] The upper bound.
           * @param {boolean} [floating] Specify returning a floating-point number.
           * @returns {number} Returns the random number.
           * @example
           *
           * _.random(0, 5);
           * // => an integer between 0 and 5
           *
           * _.random(5);
           * // => also an integer between 0 and 5
           *
           * _.random(5, true);
           * // => a floating-point number between 0 and 5
           *
           * _.random(1.2, 5.2);
           * // => a floating-point number between 1.2 and 5.2
           */


          function random(lower, upper, floating) {
            if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined;
            }

            if (floating === undefined) {
              if (typeof upper == 'boolean') {
                floating = upper;
                upper = undefined;
              } else if (typeof lower == 'boolean') {
                floating = lower;
                lower = undefined;
              }
            }

            if (lower === undefined && upper === undefined) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);

              if (upper === undefined) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }

            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }

            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
            }

            return baseRandom(lower, upper);
          }
          /*------------------------------------------------------------------------*/

          /**
           * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the camel cased string.
           * @example
           *
           * _.camelCase('Foo Bar');
           * // => 'fooBar'
           *
           * _.camelCase('--foo-bar--');
           * // => 'fooBar'
           *
           * _.camelCase('__FOO_BAR__');
           * // => 'fooBar'
           */


          var camelCase = createCompounder(function (result, word, index) {
            word = word.toLowerCase();
            return result + (index ? capitalize(word) : word);
          });
          /**
           * Converts the first character of `string` to upper case and the remaining
           * to lower case.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to capitalize.
           * @returns {string} Returns the capitalized string.
           * @example
           *
           * _.capitalize('FRED');
           * // => 'Fred'
           */

          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          /**
           * Deburrs `string` by converting
           * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
           * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
           * letters to basic Latin letters and removing
           * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to deburr.
           * @returns {string} Returns the deburred string.
           * @example
           *
           * _.deburr('déjà vu');
           * // => 'deja vu'
           */


          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
          }
          /**
           * Checks if `string` ends with the given target string.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {string} [target] The string to search for.
           * @param {number} [position=string.length] The position to search up to.
           * @returns {boolean} Returns `true` if `string` ends with `target`,
           *  else `false`.
           * @example
           *
           * _.endsWith('abc', 'c');
           * // => true
           *
           * _.endsWith('abc', 'b');
           * // => false
           *
           * _.endsWith('abc', 'b', 2);
           * // => true
           */


          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          /**
           * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
           * corresponding HTML entities.
           *
           * **Note:** No other characters are escaped. To escape additional
           * characters use a third-party library like [_he_](https://mths.be/he).
           *
           * Though the ">" character is escaped for symmetry, characters like
           * ">" and "/" don't need escaping in HTML and have no special meaning
           * unless they're part of a tag or unquoted attribute value. See
           * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
           * (under "semi-related fun fact") for more details.
           *
           * When working with HTML you should always
           * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
           * XSS vectors.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escape('fred, barney, & pebbles');
           * // => 'fred, barney, &amp; pebbles'
           */


          function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          /**
           * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
           * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escapeRegExp('[lodash](https://lodash.com/)');
           * // => '\[lodash\]\(https://lodash\.com/\)'
           */


          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
          }
          /**
           * Converts `string` to
           * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the kebab cased string.
           * @example
           *
           * _.kebabCase('Foo Bar');
           * // => 'foo-bar'
           *
           * _.kebabCase('fooBar');
           * // => 'foo-bar'
           *
           * _.kebabCase('__FOO_BAR__');
           * // => 'foo-bar'
           */


          var kebabCase = createCompounder(function (result, word, index) {
            return result + (index ? '-' : '') + word.toLowerCase();
          });
          /**
           * Converts `string`, as space separated words, to lower case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the lower cased string.
           * @example
           *
           * _.lowerCase('--Foo-Bar--');
           * // => 'foo bar'
           *
           * _.lowerCase('fooBar');
           * // => 'foo bar'
           *
           * _.lowerCase('__FOO_BAR__');
           * // => 'foo bar'
           */

          var lowerCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + word.toLowerCase();
          });
          /**
           * Converts the first character of `string` to lower case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.lowerFirst('Fred');
           * // => 'fred'
           *
           * _.lowerFirst('FRED');
           * // => 'fRED'
           */

          var lowerFirst = createCaseFirst('toLowerCase');
          /**
           * Pads `string` on the left and right sides if it's shorter than `length`.
           * Padding characters are truncated if they can't be evenly divided by `length`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.pad('abc', 8);
           * // => '  abc   '
           *
           * _.pad('abc', 8, '_-');
           * // => '_-abc_-_'
           *
           * _.pad('abc', 3);
           * // => 'abc'
           */

          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;

            if (!length || strLength >= length) {
              return string;
            }

            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          /**
           * Pads `string` on the right side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padEnd('abc', 6);
           * // => 'abc   '
           *
           * _.padEnd('abc', 6, '_-');
           * // => 'abc_-_'
           *
           * _.padEnd('abc', 3);
           * // => 'abc'
           */


          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          /**
           * Pads `string` on the left side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padStart('abc', 6);
           * // => '   abc'
           *
           * _.padStart('abc', 6, '_-');
           * // => '_-_abc'
           *
           * _.padStart('abc', 3);
           * // => 'abc'
           */


          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          /**
           * Converts `string` to an integer of the specified radix. If `radix` is
           * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
           * hexadecimal, in which case a `radix` of `16` is used.
           *
           * **Note:** This method aligns with the
           * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category String
           * @param {string} string The string to convert.
           * @param {number} [radix=10] The radix to interpret `value` by.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.parseInt('08');
           * // => 8
           *
           * _.map(['6', '08', '10'], _.parseInt);
           * // => [6, 8, 10]
           */


          function parseInt(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }

            return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
          }
          /**
           * Repeats the given string `n` times.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to repeat.
           * @param {number} [n=1] The number of times to repeat the string.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the repeated string.
           * @example
           *
           * _.repeat('*', 3);
           * // => '***'
           *
           * _.repeat('abc', 2);
           * // => 'abcabc'
           *
           * _.repeat('abc', 0);
           * // => ''
           */


          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
              n = 1;
            } else {
              n = toInteger(n);
            }

            return baseRepeat(toString(string), n);
          }
          /**
           * Replaces matches for `pattern` in `string` with `replacement`.
           *
           * **Note:** This method is based on
           * [`String#replace`](https://mdn.io/String/replace).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to modify.
           * @param {RegExp|string} pattern The pattern to replace.
           * @param {Function|string} replacement The match replacement.
           * @returns {string} Returns the modified string.
           * @example
           *
           * _.replace('Hi Fred', 'Fred', 'Barney');
           * // => 'Hi Barney'
           */


          function replace() {
            var args = arguments,
                string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          /**
           * Converts `string` to
           * [snake case](https://en.wikipedia.org/wiki/Snake_case).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the snake cased string.
           * @example
           *
           * _.snakeCase('Foo Bar');
           * // => 'foo_bar'
           *
           * _.snakeCase('fooBar');
           * // => 'foo_bar'
           *
           * _.snakeCase('--FOO-BAR--');
           * // => 'foo_bar'
           */


          var snakeCase = createCompounder(function (result, word, index) {
            return result + (index ? '_' : '') + word.toLowerCase();
          });
          /**
           * Splits `string` by `separator`.
           *
           * **Note:** This method is based on
           * [`String#split`](https://mdn.io/String/split).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to split.
           * @param {RegExp|string} separator The separator pattern to split by.
           * @param {number} [limit] The length to truncate results to.
           * @returns {Array} Returns the string segments.
           * @example
           *
           * _.split('a-b-c', '-', 2);
           * // => ['a', 'b']
           */

          function split(string, separator, limit) {
            if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined;
            }

            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;

            if (!limit) {
              return [];
            }

            string = toString(string);

            if (string && (typeof separator == 'string' || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);

              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }

            return string.split(separator, limit);
          }
          /**
           * Converts `string` to
           * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
           *
           * @static
           * @memberOf _
           * @since 3.1.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the start cased string.
           * @example
           *
           * _.startCase('--foo-bar--');
           * // => 'Foo Bar'
           *
           * _.startCase('fooBar');
           * // => 'Foo Bar'
           *
           * _.startCase('__FOO_BAR__');
           * // => 'FOO BAR'
           */


          var startCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + upperFirst(word);
          });
          /**
           * Checks if `string` starts with the given target string.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {string} [target] The string to search for.
           * @param {number} [position=0] The position to search from.
           * @returns {boolean} Returns `true` if `string` starts with `target`,
           *  else `false`.
           * @example
           *
           * _.startsWith('abc', 'a');
           * // => true
           *
           * _.startsWith('abc', 'b');
           * // => false
           *
           * _.startsWith('abc', 'b', 1);
           * // => true
           */

          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          /**
           * Creates a compiled template function that can interpolate data properties
           * in "interpolate" delimiters, HTML-escape interpolated data properties in
           * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
           * properties may be accessed as free variables in the template. If a setting
           * object is given, it takes precedence over `_.templateSettings` values.
           *
           * **Note:** In the development build `_.template` utilizes
           * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
           * for easier debugging.
           *
           * For more information on precompiling templates see
           * [lodash's custom builds documentation](https://lodash.com/custom-builds).
           *
           * For more information on Chrome extension sandboxes see
           * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category String
           * @param {string} [string=''] The template string.
           * @param {Object} [options={}] The options object.
           * @param {RegExp} [options.escape=_.templateSettings.escape]
           *  The HTML "escape" delimiter.
           * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
           *  The "evaluate" delimiter.
           * @param {Object} [options.imports=_.templateSettings.imports]
           *  An object to import into the template as free variables.
           * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
           *  The "interpolate" delimiter.
           * @param {string} [options.sourceURL='lodash.templateSources[n]']
           *  The sourceURL of the compiled template.
           * @param {string} [options.variable='obj']
           *  The data object variable name.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the compiled template function.
           * @example
           *
           * // Use the "interpolate" delimiter to create a compiled template.
           * var compiled = _.template('hello <%= user %>!');
           * compiled({ 'user': 'fred' });
           * // => 'hello fred!'
           *
           * // Use the HTML "escape" delimiter to escape data property values.
           * var compiled = _.template('<b><%- value %></b>');
           * compiled({ 'value': '<script>' });
           * // => '<b>&lt;script&gt;</b>'
           *
           * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
           * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // Use the internal `print` function in "evaluate" delimiters.
           * var compiled = _.template('<% print("hello " + user); %>!');
           * compiled({ 'user': 'barney' });
           * // => 'hello barney!'
           *
           * // Use the ES template literal delimiter as an "interpolate" delimiter.
           * // Disable support by replacing the "interpolate" delimiter.
           * var compiled = _.template('hello ${ user }!');
           * compiled({ 'user': 'pebbles' });
           * // => 'hello pebbles!'
           *
           * // Use backslashes to treat delimiters as plain text.
           * var compiled = _.template('<%= "\\<%- value %\\>" %>');
           * compiled({ 'value': 'ignored' });
           * // => '<%- value %>'
           *
           * // Use the `imports` option to import `jQuery` as `jq`.
           * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
           * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // Use the `sourceURL` option to specify a custom sourceURL for the template.
           * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
           * compiled(data);
           * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
           *
           * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
           * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
           * compiled.source;
           * // => function(data) {
           * //   var __t, __p = '';
           * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
           * //   return __p;
           * // }
           *
           * // Use custom template delimiters.
           * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
           * var compiled = _.template('hello {{ user }}!');
           * compiled({ 'user': 'mustache' });
           * // => 'hello mustache!'
           *
           * // Use the `source` property to inline compiled templates for meaningful
           * // line numbers in error messages and stack traces.
           * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
           *   var JST = {\
           *     "main": ' + _.template(mainText).source + '\
           *   };\
           * ');
           */


          function template(string, options, guard) {
            // Based on John Resig's `tmpl` implementation
            // (http://ejohn.org/blog/javascript-micro-templating/)
            // and Laura Doktorova's doT.js (https://github.com/olado/doT).
            var settings = lodash.templateSettings;

            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined;
            }

            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
                importsKeys = keys(imports),
                importsValues = baseValues(imports, importsKeys);
            var isEscaping,
                isEvaluating,
                index = 0,
                interpolate = options.interpolate || reNoMatch,
                source = "__p += '"; // Compile the regexp to match each delimiter.

            var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
            // The sourceURL gets injected into the source that's eval-ed, so be careful
            // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
            // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.

            var sourceURL = '//# sourceURL=' + (hasOwnProperty.call(options, 'sourceURL') ? (options.sourceURL + '').replace(/[\r\n]/g, ' ') : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';
            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets.

              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }

              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }

              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }

              index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
              // order to produce the correct `offset` value.

              return match;
            });
            source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain.
            // Like with sourceURL, we take care to not check the option's prototype,
            // as this configuration is a code injection vector.

            var variable = hasOwnProperty.call(options, 'variable') && options.variable;

            if (!variable) {
              source = 'with (obj) {\n' + source + '\n}\n';
            } // Cleanup code by stripping empty strings.


            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

            source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
            var result = attempt(function () {
              return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
            }); // Provide the compiled function's source by its `toString` method or
            // the `source` property as a convenience for inlining compiled templates.

            result.source = source;

            if (isError(result)) {
              throw result;
            }

            return result;
          }
          /**
           * Converts `string`, as a whole, to lower case just like
           * [String#toLowerCase](https://mdn.io/toLowerCase).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the lower cased string.
           * @example
           *
           * _.toLower('--Foo-Bar--');
           * // => '--foo-bar--'
           *
           * _.toLower('fooBar');
           * // => 'foobar'
           *
           * _.toLower('__FOO_BAR__');
           * // => '__foo_bar__'
           */


          function toLower(value) {
            return toString(value).toLowerCase();
          }
          /**
           * Converts `string`, as a whole, to upper case just like
           * [String#toUpperCase](https://mdn.io/toUpperCase).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the upper cased string.
           * @example
           *
           * _.toUpper('--foo-bar--');
           * // => '--FOO-BAR--'
           *
           * _.toUpper('fooBar');
           * // => 'FOOBAR'
           *
           * _.toUpper('__foo_bar__');
           * // => '__FOO_BAR__'
           */


          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          /**
           * Removes leading and trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trim('  abc  ');
           * // => 'abc'
           *
           * _.trim('-_-abc-_-', '_-');
           * // => 'abc'
           *
           * _.map(['  foo  ', '  bar  '], _.trim);
           * // => ['foo', 'bar']
           */


          function trim(string, chars, guard) {
            string = toString(string);

            if (string && (guard || chars === undefined)) {
              return string.replace(reTrim, '');
            }

            if (!string || !(chars = baseToString(chars))) {
              return string;
            }

            var strSymbols = stringToArray(string),
                chrSymbols = stringToArray(chars),
                start = charsStartIndex(strSymbols, chrSymbols),
                end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join('');
          }
          /**
           * Removes trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimEnd('  abc  ');
           * // => '  abc'
           *
           * _.trimEnd('-_-abc-_-', '_-');
           * // => '-_-abc'
           */


          function trimEnd(string, chars, guard) {
            string = toString(string);

            if (string && (guard || chars === undefined)) {
              return string.replace(reTrimEnd, '');
            }

            if (!string || !(chars = baseToString(chars))) {
              return string;
            }

            var strSymbols = stringToArray(string),
                end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join('');
          }
          /**
           * Removes leading whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimStart('  abc  ');
           * // => 'abc  '
           *
           * _.trimStart('-_-abc-_-', '_-');
           * // => 'abc-_-'
           */


          function trimStart(string, chars, guard) {
            string = toString(string);

            if (string && (guard || chars === undefined)) {
              return string.replace(reTrimStart, '');
            }

            if (!string || !(chars = baseToString(chars))) {
              return string;
            }

            var strSymbols = stringToArray(string),
                start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join('');
          }
          /**
           * Truncates `string` if it's longer than the given maximum string length.
           * The last characters of the truncated string are replaced with the omission
           * string which defaults to "...".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to truncate.
           * @param {Object} [options={}] The options object.
           * @param {number} [options.length=30] The maximum string length.
           * @param {string} [options.omission='...'] The string to indicate text is omitted.
           * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
           * @returns {string} Returns the truncated string.
           * @example
           *
           * _.truncate('hi-diddly-ho there, neighborino');
           * // => 'hi-diddly-ho there, neighbo...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': ' '
           * });
           * // => 'hi-diddly-ho there,...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': /,? +/
           * });
           * // => 'hi-diddly-ho there...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'omission': ' [...]'
           * });
           * // => 'hi-diddly-ho there, neig [...]'
           */


          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH,
                omission = DEFAULT_TRUNC_OMISSION;

            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? toInteger(options.length) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            }

            string = toString(string);
            var strLength = string.length;

            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }

            if (length >= strLength) {
              return string;
            }

            var end = length - stringSize(omission);

            if (end < 1) {
              return omission;
            }

            var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);

            if (separator === undefined) {
              return result + omission;
            }

            if (strSymbols) {
              end += result.length - end;
            }

            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match,
                    substring = result;

                if (!separator.global) {
                  separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                }

                separator.lastIndex = 0;

                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }

                result = result.slice(0, newEnd === undefined ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result.lastIndexOf(separator);

              if (index > -1) {
                result = result.slice(0, index);
              }
            }

            return result + omission;
          }
          /**
           * The inverse of `_.escape`; this method converts the HTML entities
           * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
           * their corresponding characters.
           *
           * **Note:** No other HTML entities are unescaped. To unescape additional
           * HTML entities use a third-party library like [_he_](https://mths.be/he).
           *
           * @static
           * @memberOf _
           * @since 0.6.0
           * @category String
           * @param {string} [string=''] The string to unescape.
           * @returns {string} Returns the unescaped string.
           * @example
           *
           * _.unescape('fred, barney, &amp; pebbles');
           * // => 'fred, barney, & pebbles'
           */


          function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          /**
           * Converts `string`, as space separated words, to upper case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the upper cased string.
           * @example
           *
           * _.upperCase('--foo-bar');
           * // => 'FOO BAR'
           *
           * _.upperCase('fooBar');
           * // => 'FOO BAR'
           *
           * _.upperCase('__foo_bar__');
           * // => 'FOO BAR'
           */


          var upperCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + word.toUpperCase();
          });
          /**
           * Converts the first character of `string` to upper case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.upperFirst('fred');
           * // => 'Fred'
           *
           * _.upperFirst('FRED');
           * // => 'FRED'
           */

          var upperFirst = createCaseFirst('toUpperCase');
          /**
           * Splits `string` into an array of its words.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {RegExp|string} [pattern] The pattern to match words.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the words of `string`.
           * @example
           *
           * _.words('fred, barney, & pebbles');
           * // => ['fred', 'barney', 'pebbles']
           *
           * _.words('fred, barney, & pebbles', /[^, ]+/g);
           * // => ['fred', 'barney', '&', 'pebbles']
           */

          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined : pattern;

            if (pattern === undefined) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }

            return string.match(pattern) || [];
          }
          /*------------------------------------------------------------------------*/

          /**
           * Attempts to invoke `func`, returning either the result or the caught error
           * object. Any additional arguments are provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Function} func The function to attempt.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {*} Returns the `func` result or error object.
           * @example
           *
           * // Avoid throwing errors for invalid selectors.
           * var elements = _.attempt(function(selector) {
           *   return document.querySelectorAll(selector);
           * }, '>_>');
           *
           * if (_.isError(elements)) {
           *   elements = [];
           * }
           */


          var attempt = baseRest(function (func, args) {
            try {
              return apply(func, undefined, args);
            } catch (e) {
              return isError(e) ? e : new Error(e);
            }
          });
          /**
           * Binds methods of an object to the object itself, overwriting the existing
           * method.
           *
           * **Note:** This method doesn't set the "length" property of bound functions.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {Object} object The object to bind and assign the bound methods to.
           * @param {...(string|string[])} methodNames The object method names to bind.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var view = {
           *   'label': 'docs',
           *   'click': function() {
           *     console.log('clicked ' + this.label);
           *   }
           * };
           *
           * _.bindAll(view, ['click']);
           * jQuery(element).on('click', view.click);
           * // => Logs 'clicked docs' when clicked.
           */

          var bindAll = flatRest(function (object, methodNames) {
            arrayEach(methodNames, function (key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          /**
           * Creates a function that iterates over `pairs` and invokes the corresponding
           * function of the first predicate to return truthy. The predicate-function
           * pairs are invoked with the `this` binding and arguments of the created
           * function.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {Array} pairs The predicate-function pairs.
           * @returns {Function} Returns the new composite function.
           * @example
           *
           * var func = _.cond([
           *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
           *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
           *   [_.stubTrue,                      _.constant('no match')]
           * ]);
           *
           * func({ 'a': 1, 'b': 2 });
           * // => 'matches A'
           *
           * func({ 'a': 0, 'b': 1 });
           * // => 'matches B'
           *
           * func({ 'a': '1', 'b': '2' });
           * // => 'no match'
           */

          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length,
                toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function (pair) {
              if (typeof pair[1] != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }

              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function (args) {
              var index = -1;

              while (++index < length) {
                var pair = pairs[index];

                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          /**
           * Creates a function that invokes the predicate properties of `source` with
           * the corresponding property values of a given object, returning `true` if
           * all predicates return truthy, else `false`.
           *
           * **Note:** The created function is equivalent to `_.conformsTo` with
           * `source` partially applied.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {Object} source The object of property predicates to conform to.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 2, 'b': 1 },
           *   { 'a': 1, 'b': 2 }
           * ];
           *
           * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
           * // => [{ 'a': 1, 'b': 2 }]
           */


          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Util
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new constant function.
           * @example
           *
           * var objects = _.times(2, _.constant({ 'a': 1 }));
           *
           * console.log(objects);
           * // => [{ 'a': 1 }, { 'a': 1 }]
           *
           * console.log(objects[0] === objects[1]);
           * // => true
           */


          function constant(value) {
            return function () {
              return value;
            };
          }
          /**
           * Checks `value` to determine whether a default value should be returned in
           * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
           * or `undefined`.
           *
           * @static
           * @memberOf _
           * @since 4.14.0
           * @category Util
           * @param {*} value The value to check.
           * @param {*} defaultValue The default value.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * _.defaultTo(1, 10);
           * // => 1
           *
           * _.defaultTo(undefined, 10);
           * // => 10
           */


          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          /**
           * Creates a function that returns the result of invoking the given functions
           * with the `this` binding of the created function, where each successive
           * invocation is supplied the return value of the previous.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {...(Function|Function[])} [funcs] The functions to invoke.
           * @returns {Function} Returns the new composite function.
           * @see _.flowRight
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flow([_.add, square]);
           * addSquare(1, 2);
           * // => 9
           */


          var flow = createFlow();
          /**
           * This method is like `_.flow` except that it creates a function that
           * invokes the given functions from right to left.
           *
           * @static
           * @since 3.0.0
           * @memberOf _
           * @category Util
           * @param {...(Function|Function[])} [funcs] The functions to invoke.
           * @returns {Function} Returns the new composite function.
           * @see _.flow
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flowRight([square, _.add]);
           * addSquare(1, 2);
           * // => 9
           */

          var flowRight = createFlow(true);
          /**
           * This method returns the first argument it receives.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'a': 1 };
           *
           * console.log(_.identity(object) === object);
           * // => true
           */

          function identity(value) {
            return value;
          }
          /**
           * Creates a function that invokes `func` with the arguments of the created
           * function. If `func` is a property name, the created function returns the
           * property value for a given element. If `func` is an array or object, the
           * created function returns `true` for elements that contain the equivalent
           * source properties, otherwise it returns `false`.
           *
           * @static
           * @since 4.0.0
           * @memberOf _
           * @category Util
           * @param {*} [func=_.identity] The value to convert to a callback.
           * @returns {Function} Returns the callback.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
           * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.filter(users, _.iteratee(['user', 'fred']));
           * // => [{ 'user': 'fred', 'age': 40 }]
           *
           * // The `_.property` iteratee shorthand.
           * _.map(users, _.iteratee('user'));
           * // => ['barney', 'fred']
           *
           * // Create custom iteratee shorthands.
           * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
           *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
           *     return func.test(string);
           *   };
           * });
           *
           * _.filter(['abc', 'def'], /ef/);
           * // => ['def']
           */


          function iteratee(func) {
            return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          /**
           * Creates a function that performs a partial deep comparison between a given
           * object and `source`, returning `true` if the given object has equivalent
           * property values, else `false`.
           *
           * **Note:** The created function is equivalent to `_.isMatch` with `source`
           * partially applied.
           *
           * Partial comparisons will match empty array and empty object `source`
           * values against any array or object value, respectively. See `_.isEqual`
           * for a list of supported value comparisons.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 1, 'b': 2, 'c': 3 },
           *   { 'a': 4, 'b': 5, 'c': 6 }
           * ];
           *
           * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
           * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
           */


          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          /**
           * Creates a function that performs a partial deep comparison between the
           * value at `path` of a given object to `srcValue`, returning `true` if the
           * object value is equivalent, else `false`.
           *
           * **Note:** Partial comparisons will match empty array and empty object
           * `srcValue` values against any array or object value, respectively. See
           * `_.isEqual` for a list of supported value comparisons.
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Util
           * @param {Array|string} path The path of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 1, 'b': 2, 'c': 3 },
           *   { 'a': 4, 'b': 5, 'c': 6 }
           * ];
           *
           * _.find(objects, _.matchesProperty('a', 4));
           * // => { 'a': 4, 'b': 5, 'c': 6 }
           */


          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          /**
           * Creates a function that invokes the method at `path` of a given object.
           * Any additional arguments are provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Util
           * @param {Array|string} path The path of the method to invoke.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new invoker function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': _.constant(2) } },
           *   { 'a': { 'b': _.constant(1) } }
           * ];
           *
           * _.map(objects, _.method('a.b'));
           * // => [2, 1]
           *
           * _.map(objects, _.method(['a', 'b']));
           * // => [2, 1]
           */


          var method = baseRest(function (path, args) {
            return function (object) {
              return baseInvoke(object, path, args);
            };
          });
          /**
           * The opposite of `_.method`; this method creates a function that invokes
           * the method at a given path of `object`. Any additional arguments are
           * provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Util
           * @param {Object} object The object to query.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new invoker function.
           * @example
           *
           * var array = _.times(3, _.constant),
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.methodOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
           * // => [2, 0]
           */

          var methodOf = baseRest(function (object, args) {
            return function (path) {
              return baseInvoke(object, path, args);
            };
          });
          /**
           * Adds all own enumerable string keyed function properties of a source
           * object to the destination object. If `object` is a function, then methods
           * are added to its prototype as well.
           *
           * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
           * avoid conflicts caused by modifying the original.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {Function|Object} [object=lodash] The destination object.
           * @param {Object} source The object of functions to add.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
           * @returns {Function|Object} Returns `object`.
           * @example
           *
           * function vowels(string) {
           *   return _.filter(string, function(v) {
           *     return /[aeiou]/i.test(v);
           *   });
           * }
           *
           * _.mixin({ 'vowels': vowels });
           * _.vowels('fred');
           * // => ['e']
           *
           * _('fred').vowels().value();
           * // => ['e']
           *
           * _.mixin({ 'vowels': vowels }, { 'chain': false });
           * _('fred').vowels();
           * // => ['e']
           */

          function mixin(object, source, options) {
            var props = keys(source),
                methodNames = baseFunctions(source, props);

            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }

            var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
                isFunc = isFunction(object);
            arrayEach(methodNames, function (methodName) {
              var func = source[methodName];
              object[methodName] = func;

              if (isFunc) {
                object.prototype[methodName] = function () {
                  var chainAll = this.__chain__;

                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                        actions = result.__actions__ = copyArray(this.__actions__);
                    actions.push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }

                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          /**
           * Reverts the `_` variable to its previous value and returns a reference to
           * the `lodash` function.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @returns {Function} Returns the `lodash` function.
           * @example
           *
           * var lodash = _.noConflict();
           */


          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }

            return this;
          }
          /**
           * This method returns `undefined`.
           *
           * @static
           * @memberOf _
           * @since 2.3.0
           * @category Util
           * @example
           *
           * _.times(2, _.noop);
           * // => [undefined, undefined]
           */


          function noop() {} // No operation performed.

          /**
           * Creates a function that gets the argument at index `n`. If `n` is negative,
           * the nth argument from the end is returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {number} [n=0] The index of the argument to return.
           * @returns {Function} Returns the new pass-thru function.
           * @example
           *
           * var func = _.nthArg(1);
           * func('a', 'b', 'c', 'd');
           * // => 'b'
           *
           * var func = _.nthArg(-2);
           * func('a', 'b', 'c', 'd');
           * // => 'c'
           */


          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function (args) {
              return baseNth(args, n);
            });
          }
          /**
           * Creates a function that invokes `iteratees` with the arguments it receives
           * and returns their results.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [iteratees=[_.identity]]
           *  The iteratees to invoke.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.over([Math.max, Math.min]);
           *
           * func(1, 2, 3, 4);
           * // => [4, 1]
           */


          var over = createOver(arrayMap);
          /**
           * Creates a function that checks if **all** of the `predicates` return
           * truthy when invoked with the arguments it receives.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [predicates=[_.identity]]
           *  The predicates to check.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.overEvery([Boolean, isFinite]);
           *
           * func('1');
           * // => true
           *
           * func(null);
           * // => false
           *
           * func(NaN);
           * // => false
           */

          var overEvery = createOver(arrayEvery);
          /**
           * Creates a function that checks if **any** of the `predicates` return
           * truthy when invoked with the arguments it receives.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [predicates=[_.identity]]
           *  The predicates to check.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.overSome([Boolean, isFinite]);
           *
           * func('1');
           * // => true
           *
           * func(null);
           * // => true
           *
           * func(NaN);
           * // => false
           */

          var overSome = createOver(arraySome);
          /**
           * Creates a function that returns the value at `path` of a given object.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Util
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new accessor function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': 2 } },
           *   { 'a': { 'b': 1 } }
           * ];
           *
           * _.map(objects, _.property('a.b'));
           * // => [2, 1]
           *
           * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
           * // => [1, 2]
           */

          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          /**
           * The opposite of `_.property`; this method creates a function that returns
           * the value at a given path of `object`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Object} object The object to query.
           * @returns {Function} Returns the new accessor function.
           * @example
           *
           * var array = [0, 1, 2],
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
           * // => [2, 0]
           */


          function propertyOf(object) {
            return function (path) {
              return object == null ? undefined : baseGet(object, path);
            };
          }
          /**
           * Creates an array of numbers (positive and/or negative) progressing from
           * `start` up to, but not including, `end`. A step of `-1` is used if a negative
           * `start` is specified without an `end` or `step`. If `end` is not specified,
           * it's set to `start` with `start` then set to `0`.
           *
           * **Note:** JavaScript follows the IEEE-754 standard for resolving
           * floating-point values which can produce unexpected results.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns the range of numbers.
           * @see _.inRange, _.rangeRight
           * @example
           *
           * _.range(4);
           * // => [0, 1, 2, 3]
           *
           * _.range(-4);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 5);
           * // => [1, 2, 3, 4]
           *
           * _.range(0, 20, 5);
           * // => [0, 5, 10, 15]
           *
           * _.range(0, -4, -1);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.range(0);
           * // => []
           */


          var range = createRange();
          /**
           * This method is like `_.range` except that it populates values in
           * descending order.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns the range of numbers.
           * @see _.inRange, _.range
           * @example
           *
           * _.rangeRight(4);
           * // => [3, 2, 1, 0]
           *
           * _.rangeRight(-4);
           * // => [-3, -2, -1, 0]
           *
           * _.rangeRight(1, 5);
           * // => [4, 3, 2, 1]
           *
           * _.rangeRight(0, 20, 5);
           * // => [15, 10, 5, 0]
           *
           * _.rangeRight(0, -4, -1);
           * // => [-3, -2, -1, 0]
           *
           * _.rangeRight(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.rangeRight(0);
           * // => []
           */

          var rangeRight = createRange(true);
          /**
           * This method returns a new empty array.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {Array} Returns the new empty array.
           * @example
           *
           * var arrays = _.times(2, _.stubArray);
           *
           * console.log(arrays);
           * // => [[], []]
           *
           * console.log(arrays[0] === arrays[1]);
           * // => false
           */

          function stubArray() {
            return [];
          }
          /**
           * This method returns `false`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `false`.
           * @example
           *
           * _.times(2, _.stubFalse);
           * // => [false, false]
           */


          function stubFalse() {
            return false;
          }
          /**
           * This method returns a new empty object.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {Object} Returns the new empty object.
           * @example
           *
           * var objects = _.times(2, _.stubObject);
           *
           * console.log(objects);
           * // => [{}, {}]
           *
           * console.log(objects[0] === objects[1]);
           * // => false
           */


          function stubObject() {
            return {};
          }
          /**
           * This method returns an empty string.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {string} Returns the empty string.
           * @example
           *
           * _.times(2, _.stubString);
           * // => ['', '']
           */


          function stubString() {
            return '';
          }
          /**
           * This method returns `true`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `true`.
           * @example
           *
           * _.times(2, _.stubTrue);
           * // => [true, true]
           */


          function stubTrue() {
            return true;
          }
          /**
           * Invokes the iteratee `n` times, returning an array of the results of
           * each invocation. The iteratee is invoked with one argument; (index).
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {number} n The number of times to invoke `iteratee`.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * _.times(3, String);
           * // => ['0', '1', '2']
           *
           *  _.times(4, _.constant(0));
           * // => [0, 0, 0, 0]
           */


          function times(n, iteratee) {
            n = toInteger(n);

            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }

            var index = MAX_ARRAY_LENGTH,
                length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = getIteratee(iteratee);
            n -= MAX_ARRAY_LENGTH;
            var result = baseTimes(length, iteratee);

            while (++index < n) {
              iteratee(index);
            }

            return result;
          }
          /**
           * Converts `value` to a property path array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {*} value The value to convert.
           * @returns {Array} Returns the new property path array.
           * @example
           *
           * _.toPath('a.b.c');
           * // => ['a', 'b', 'c']
           *
           * _.toPath('a[0].b.c');
           * // => ['a', '0', 'b', 'c']
           */


          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }

            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          /**
           * Generates a unique ID. If `prefix` is given, the ID is appended to it.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {string} [prefix=''] The value to prefix the ID with.
           * @returns {string} Returns the unique ID.
           * @example
           *
           * _.uniqueId('contact_');
           * // => 'contact_104'
           *
           * _.uniqueId();
           * // => '105'
           */


          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
          }
          /*------------------------------------------------------------------------*/

          /**
           * Adds two numbers.
           *
           * @static
           * @memberOf _
           * @since 3.4.0
           * @category Math
           * @param {number} augend The first number in an addition.
           * @param {number} addend The second number in an addition.
           * @returns {number} Returns the total.
           * @example
           *
           * _.add(6, 4);
           * // => 10
           */


          var add = createMathOperation(function (augend, addend) {
            return augend + addend;
          }, 0);
          /**
           * Computes `number` rounded up to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round up.
           * @param {number} [precision=0] The precision to round up to.
           * @returns {number} Returns the rounded up number.
           * @example
           *
           * _.ceil(4.006);
           * // => 5
           *
           * _.ceil(6.004, 2);
           * // => 6.01
           *
           * _.ceil(6040, -2);
           * // => 6100
           */

          var ceil = createRound('ceil');
          /**
           * Divide two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {number} dividend The first number in a division.
           * @param {number} divisor The second number in a division.
           * @returns {number} Returns the quotient.
           * @example
           *
           * _.divide(6, 4);
           * // => 1.5
           */

          var divide = createMathOperation(function (dividend, divisor) {
            return dividend / divisor;
          }, 1);
          /**
           * Computes `number` rounded down to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round down.
           * @param {number} [precision=0] The precision to round down to.
           * @returns {number} Returns the rounded down number.
           * @example
           *
           * _.floor(4.006);
           * // => 4
           *
           * _.floor(0.046, 2);
           * // => 0.04
           *
           * _.floor(4060, -2);
           * // => 4000
           */

          var floor = createRound('floor');
          /**
           * Computes the maximum value of `array`. If `array` is empty or falsey,
           * `undefined` is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * _.max([4, 2, 8, 6]);
           * // => 8
           *
           * _.max([]);
           * // => undefined
           */

          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
          }
          /**
           * This method is like `_.max` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * the value is ranked. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * var objects = [{ 'n': 1 }, { 'n': 2 }];
           *
           * _.maxBy(objects, function(o) { return o.n; });
           * // => { 'n': 2 }
           *
           * // The `_.property` iteratee shorthand.
           * _.maxBy(objects, 'n');
           * // => { 'n': 2 }
           */


          function maxBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
          }
          /**
           * Computes the mean of the values in `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {number} Returns the mean.
           * @example
           *
           * _.mean([4, 2, 8, 6]);
           * // => 5
           */


          function mean(array) {
            return baseMean(array, identity);
          }
          /**
           * This method is like `_.mean` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the value to be averaged.
           * The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the mean.
           * @example
           *
           * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
           *
           * _.meanBy(objects, function(o) { return o.n; });
           * // => 5
           *
           * // The `_.property` iteratee shorthand.
           * _.meanBy(objects, 'n');
           * // => 5
           */


          function meanBy(array, iteratee) {
            return baseMean(array, getIteratee(iteratee, 2));
          }
          /**
           * Computes the minimum value of `array`. If `array` is empty or falsey,
           * `undefined` is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * _.min([4, 2, 8, 6]);
           * // => 2
           *
           * _.min([]);
           * // => undefined
           */


          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
          }
          /**
           * This method is like `_.min` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * the value is ranked. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * var objects = [{ 'n': 1 }, { 'n': 2 }];
           *
           * _.minBy(objects, function(o) { return o.n; });
           * // => { 'n': 1 }
           *
           * // The `_.property` iteratee shorthand.
           * _.minBy(objects, 'n');
           * // => { 'n': 1 }
           */


          function minBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
          }
          /**
           * Multiply two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {number} multiplier The first number in a multiplication.
           * @param {number} multiplicand The second number in a multiplication.
           * @returns {number} Returns the product.
           * @example
           *
           * _.multiply(6, 4);
           * // => 24
           */


          var multiply = createMathOperation(function (multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          /**
           * Computes `number` rounded to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round.
           * @param {number} [precision=0] The precision to round to.
           * @returns {number} Returns the rounded number.
           * @example
           *
           * _.round(4.006);
           * // => 4
           *
           * _.round(4.006, 2);
           * // => 4.01
           *
           * _.round(4060, -2);
           * // => 4100
           */

          var round = createRound('round');
          /**
           * Subtract two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {number} minuend The first number in a subtraction.
           * @param {number} subtrahend The second number in a subtraction.
           * @returns {number} Returns the difference.
           * @example
           *
           * _.subtract(6, 4);
           * // => 2
           */

          var subtract = createMathOperation(function (minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          /**
           * Computes the sum of the values in `array`.
           *
           * @static
           * @memberOf _
           * @since 3.4.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {number} Returns the sum.
           * @example
           *
           * _.sum([4, 2, 8, 6]);
           * // => 20
           */

          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          /**
           * This method is like `_.sum` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the value to be summed.
           * The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the sum.
           * @example
           *
           * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
           *
           * _.sumBy(objects, function(o) { return o.n; });
           * // => 20
           *
           * // The `_.property` iteratee shorthand.
           * _.sumBy(objects, 'n');
           * // => 20
           */


          function sumBy(array, iteratee) {
            return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
          }
          /*------------------------------------------------------------------------*/
          // Add methods that return wrapped values in chain sequences.


          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith; // Add aliases.

          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith; // Add methods to `lodash.prototype`.

          mixin(lodash, lodash);
          /*------------------------------------------------------------------------*/
          // Add methods that return unwrapped values in chain sequences.

          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst; // Add aliases.

          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function () {
            var source = {};
            baseForOwn(lodash, function (func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), {
            'chain': false
          });
          /*------------------------------------------------------------------------*/

          /**
           * The semantic version number.
           *
           * @static
           * @memberOf _
           * @type {string}
           */

          lodash.VERSION = VERSION; // Assign default placeholders.

          arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
            lodash[methodName].placeholder = lodash;
          }); // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.

          arrayEach(['drop', 'take'], function (methodName, index) {
            LazyWrapper.prototype[methodName] = function (n) {
              n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
              var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();

              if (result.__filtered__) {
                result.__takeCount__ = nativeMin(n, result.__takeCount__);
              } else {
                result.__views__.push({
                  'size': nativeMin(n, MAX_ARRAY_LENGTH),
                  'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                });
              }

              return result;
            };

            LazyWrapper.prototype[methodName + 'Right'] = function (n) {
              return this.reverse()[methodName](n).reverse();
            };
          }); // Add `LazyWrapper` methods that accept an `iteratee` value.

          arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
            var type = index + 1,
                isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

            LazyWrapper.prototype[methodName] = function (iteratee) {
              var result = this.clone();

              result.__iteratees__.push({
                'iteratee': getIteratee(iteratee, 3),
                'type': type
              });

              result.__filtered__ = result.__filtered__ || isFilter;
              return result;
            };
          }); // Add `LazyWrapper` methods for `_.head` and `_.last`.

          arrayEach(['head', 'last'], function (methodName, index) {
            var takeName = 'take' + (index ? 'Right' : '');

            LazyWrapper.prototype[methodName] = function () {
              return this[takeName](1).value()[0];
            };
          }); // Add `LazyWrapper` methods for `_.initial` and `_.tail`.

          arrayEach(['initial', 'tail'], function (methodName, index) {
            var dropName = 'drop' + (index ? '' : 'Right');

            LazyWrapper.prototype[methodName] = function () {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });

          LazyWrapper.prototype.compact = function () {
            return this.filter(identity);
          };

          LazyWrapper.prototype.find = function (predicate) {
            return this.filter(predicate).head();
          };

          LazyWrapper.prototype.findLast = function (predicate) {
            return this.reverse().find(predicate);
          };

          LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
            if (typeof path == 'function') {
              return new LazyWrapper(this);
            }

            return this.map(function (value) {
              return baseInvoke(value, path, args);
            });
          });

          LazyWrapper.prototype.reject = function (predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };

          LazyWrapper.prototype.slice = function (start, end) {
            start = toInteger(start);
            var result = this;

            if (result.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result);
            }

            if (start < 0) {
              result = result.takeRight(-start);
            } else if (start) {
              result = result.drop(start);
            }

            if (end !== undefined) {
              end = toInteger(end);
              result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }

            return result;
          };

          LazyWrapper.prototype.takeRightWhile = function (predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };

          LazyWrapper.prototype.toArray = function () {
            return this.take(MAX_ARRAY_LENGTH);
          }; // Add `LazyWrapper` methods to `lodash.prototype`.


          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
                isTaker = /^(?:head|last)$/.test(methodName),
                lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName],
                retUnwrapped = isTaker || /^find/.test(methodName);

            if (!lodashFunc) {
              return;
            }

            lodash.prototype[methodName] = function () {
              var value = this.__wrapped__,
                  args = isTaker ? [1] : arguments,
                  isLazy = value instanceof LazyWrapper,
                  iteratee = args[0],
                  useLazy = isLazy || isArray(value);

              var interceptor = function interceptor(value) {
                var result = lodashFunc.apply(lodash, arrayPush([value], args));
                return isTaker && chainAll ? result[0] : result;
              };

              if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                // Avoid lazy use if the iteratee has a "length" value other than `1`.
                isLazy = useLazy = false;
              }

              var chainAll = this.__chain__,
                  isHybrid = !!this.__actions__.length,
                  isUnwrapped = retUnwrapped && !chainAll,
                  onlyLazy = isLazy && !isHybrid;

              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result = func.apply(value, args);

                result.__actions__.push({
                  'func': thru,
                  'args': [interceptor],
                  'thisArg': undefined
                });

                return new LodashWrapper(result, chainAll);
              }

              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }

              result = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
            };
          }); // Add `Array` methods to `lodash.prototype`.

          arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
            var func = arrayProto[methodName],
                chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
                retUnwrapped = /^(?:pop|shift)$/.test(methodName);

            lodash.prototype[methodName] = function () {
              var args = arguments;

              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }

              return this[chainName](function (value) {
                return func.apply(isArray(value) ? value : [], args);
              });
            };
          }); // Map minified method names to their real names.

          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var lodashFunc = lodash[methodName];

            if (lodashFunc) {
              var key = lodashFunc.name + '';

              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }

              realNames[key].push({
                'name': methodName,
                'func': lodashFunc
              });
            }
          });
          realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
            'name': 'wrapper',
            'func': undefined
          }]; // Add methods to `LazyWrapper`.

          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue; // Add chain sequence methods to the `lodash` wrapper.

          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue; // Add lazy aliases.

          lodash.prototype.first = lodash.prototype.head;

          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }

          return lodash;
        };
        /*--------------------------------------------------------------------------*/
        // Export lodash.


        var _ = runInContext(); // Some AMD build optimizers, like r.js, check for condition patterns like:


        if (true) {
          // Expose Lodash on the global object to prevent errors when Lodash is
          // loaded by a script tag in the presence of an AMD loader.
          // See http://requirejs.org/docs/errors.html#mismatch for more details.
          // Use `_.noConflict` to remove Lodash from the global object.
          root._ = _; // Define as an anonymous module so, through path mapping, it can be
          // referenced as the "underscore" module.

          !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return _;
          }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } // Check for `exports` after `define` in case a build optimizer adds it.
        else {}
      }).call(this);
      /* WEBPACK VAR INJECTION */
    }).call(this, __webpack_require__(
    /*! ./../webpack/buildin/module.js */
    "./node_modules/webpack/buildin/module.js")(module));
    /***/
  },

  /***/
  "./node_modules/ng-select2/__ivy_ngcc__/fesm2015/ng-select2.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/ng-select2/__ivy_ngcc__/fesm2015/ng-select2.js ***!
    \*********************************************************************/

  /*! exports provided: NgSelect2Component, NgSelect2Module */

  /***/
  function node_modulesNgSelect2__ivy_ngcc__Fesm2015NgSelect2Js(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgSelect2Component", function () {
      return NgSelect2Component;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgSelect2Module", function () {
      return NgSelect2Module;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/forms */
    "./node_modules/@angular/forms/__ivy_ngcc__/fesm2015/forms.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js");

    var _c0 = ["selector"];
    var _c1 = [[["option"], ["optgroup"]]];
    var _c2 = ["option, optgroup"];
    var NgSelect2Component_1;

    var NgSelect2Component = NgSelect2Component_1 = /*#__PURE__*/function () {
      // private style = `CSS`;
      function NgSelect2Component(renderer, zone, _element) {
        _classCallCheck(this, NgSelect2Component);

        this.renderer = renderer;
        this.zone = zone;
        this._element = _element; // value for placeholder

        this.placeholder = '';
        this.dropdownParent = '';
        this.allowClear = false; // enable / disable select2

        this.disabled = false; // emitter when value is changed

        this.valueChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.element = undefined;
        this.check = false;

        this.propagateChange = function (value) {};
      }

      _createClass(NgSelect2Component, [{
        key: "ngDoCheck",
        value: function ngDoCheck() {
          if (!this.element) {
            return;
          }
        }
      }, {
        key: "ngOnInit",
        value: function ngOnInit() {// if (this.cssImport) {
          //   const head = document.getElementsByTagName('head')[0];
          //   const link: any = head.children[head.children.length - 1];
          //   if (!link.version) {
          //     const newLink = this.renderer.createElement(head, 'style');
          //     this.renderer.setElementProperty(newLink, 'type', 'text/css');
          //     this.renderer.setElementProperty(newLink, 'version', 'select2');
          //     this.renderer.setElementProperty(newLink, 'innerHTML', this.style);
          //   }
          // }
        }
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          if (!this.element) {
            return;
          }

          if (changes['data'] && JSON.stringify(changes['data'].previousValue) !== JSON.stringify(changes['data'].currentValue)) {
            this.initPlugin();
            var newValue = this.value;
            this.setElementValue(newValue);
            this.valueChanged.emit(newValue);
            this.propagateChange(newValue);
          }

          if (changes['value'] && changes['value'].previousValue !== changes['value'].currentValue) {
            var _newValue = changes['value'].currentValue;
            this.setElementValue(_newValue);
            this.valueChanged.emit(_newValue);
            this.propagateChange(_newValue);
          }

          if (changes['disabled'] && changes['disabled'].previousValue !== changes['disabled'].currentValue) {
            this.renderer.setProperty(this.selector.nativeElement, 'disabled', this.disabled);
          }

          if (changes['placeholder'] && changes['placeholder'].previousValue !== changes['placeholder'].currentValue) {
            this.element.data('select2').$container.find('.select2-selection__placeholder').text(this.placeholder);
          }

          if (changes['dropdownParent'] && changes['dropdownParent'].previousValue !== changes['dropdownParent'].currentValue) {
            this.renderer.setAttribute(this.selector.nativeElement, 'data-dropdownParent', this.dropdownParent);
          }

          if (changes['allowClear'] && changes['allowClear'].previousValue !== changes['allowClear'].currentValue) {
            this.renderer.setAttribute(this.selector.nativeElement, 'data-allow-clear', this.allowClear.toString());
          }
        }
      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this = this;

          this.element = jQuery(this.selector.nativeElement);
          this.renderer.setAttribute(this.selector.nativeElement, 'data-dropdownParent', this.dropdownParent);
          this.renderer.setAttribute(this.selector.nativeElement, 'data-allow-clear', this.allowClear.toString()); // console.log(this.selector.nativeElement);

          this.initPlugin();

          if (typeof this.value !== 'undefined') {
            this.setElementValue(this.value);
          }

          this.element.on('select2:select select2:unselect', function (e) {
            // const newValue: string = (e.type === 'select2:unselect') ? '' : this.element.val();
            var newValue = _this.element.val();

            _this.valueChanged.emit(newValue);

            _this.propagateChange(newValue);
          });
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.element) {
            this.element.off('select2:select');
          }
        }
      }, {
        key: "initPlugin",
        value: function initPlugin() {
          var _this2 = this;

          if (!this.element.select2) {
            if (!this.check) {
              this.check = true;
              console.log('Please add Select2 library (js file) to the project.' + 'You can download it from https://github.com/select2/select2/tree/master/dist/js.');
            }

            return;
          } // If select2 already initialized remove him and remove all tags inside


          if (this.element.hasClass('select2-hidden-accessible') === true) {
            this.element.select2('destroy');
            this.renderer.setProperty(this.selector.nativeElement, 'innerHTML', '');
          }

          var options = {
            data: this.data,
            width: this.width ? this.width : 'resolve',
            placeholder: this.placeholder
          };

          if (this.dropdownParent) {
            options = {
              data: this.data,
              width: this.width ? this.width : 'resolve',
              dropdownParent: jQuery('#' + this.dropdownParent)
            };
          }

          Object.assign(options, this.options);

          if (options.matcher) {
            jQuery.fn.select2.amd.require(['select2/compat/matcher'], function (oldMatcher) {
              options.matcher = oldMatcher(options.matcher);

              _this2.element.select2(options);

              if (typeof _this2.value !== 'undefined') {
                _this2.setElementValue(_this2.value);
              }
            });
          } else {
            this.element.select2(options);
          }

          this.renderer.setProperty(this.selector.nativeElement, 'disabled', this.disabled);
        }
      }, {
        key: "setElementValue",
        value: function setElementValue(newValue) {
          // this.zone.run(() => {
          if (Array.isArray(newValue)) {
            var _iterator = _createForOfIteratorHelper(this.selector.nativeElement.options),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var option = _step.value;
                this.renderer.setProperty(option, 'selected', newValue.indexOf(option.value) > -1);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          } else {
            this.renderer.setProperty(this.selector.nativeElement, 'value', newValue);
          }

          if (this.element) {
            this.element.trigger('change.select2');
          } // });

        }
      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (value !== undefined) {
            this.value = value;
            this.setElementValue(value);
          }
        }
      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this.propagateChange = fn;
        }
      }, {
        key: "registerOnTouched",
        value: function registerOnTouched() {}
      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
          this.renderer.setProperty(this.selector.nativeElement, 'disabled', this.disabled);
        }
      }]);

      return NgSelect2Component;
    }();

    NgSelect2Component.ɵfac = function NgSelect2Component_Factory(t) {
      return new (t || NgSelect2Component)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]));
    };

    NgSelect2Component.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
      type: NgSelect2Component,
      selectors: [["ng-select2"]],
      viewQuery: function NgSelect2Component_Query(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵstaticViewQuery"](_c0, true);
        }

        if (rf & 2) {
          var _t;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵloadQuery"]()) && (ctx.selector = _t.first);
        }
      },
      inputs: {
        placeholder: "placeholder",
        dropdownParent: "dropdownParent",
        allowClear: "allowClear",
        disabled: "disabled",
        value: "value",
        data: "data",
        width: "width",
        options: "options"
      },
      outputs: {
        valueChanged: "valueChanged"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([{
        provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
        useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return NgSelect2Component_1;
        }),
        multi: true
      }]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]],
      ngContentSelectors: _c2,
      decls: 3,
      vars: 0,
      consts: [["selector", ""]],
      template: function NgSelect2Component_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵprojectionDef"](_c1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "select", null, 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵprojection"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });

    NgSelect2Component.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('selector', {
      "static": true
    })], NgSelect2Component.prototype, "selector", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], NgSelect2Component.prototype, "data", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], NgSelect2Component.prototype, "placeholder", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], NgSelect2Component.prototype, "dropdownParent", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], NgSelect2Component.prototype, "allowClear", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], NgSelect2Component.prototype, "value", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], NgSelect2Component.prototype, "width", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], NgSelect2Component.prototype, "disabled", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], NgSelect2Component.prototype, "options", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()], NgSelect2Component.prototype, "valueChanged", void 0);

    var NgSelect2Module = function NgSelect2Module() {
      _classCallCheck(this, NgSelect2Module);
    };

    NgSelect2Module.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
      type: NgSelect2Module
    });
    NgSelect2Module.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
      factory: function NgSelect2Module_Factory(t) {
        return new (t || NgSelect2Module)();
      },
      imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]]
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](NgSelect2Component, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
        args: [{
          selector: 'ng-select2',
          template: "<select #selector>\n  <ng-content select=\"option, optgroup\">\n  </ng-content>\n</select>\n",
          encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
          changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
          providers: [{
            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
            useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
              return NgSelect2Component_1;
            }),
            multi: true
          }]
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
        }];
      }, {
        placeholder: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        dropdownParent: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        allowClear: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        disabled: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        valueChanged: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
        }],
        value: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        selector: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
          args: ['selector', {
            "static": true
          }]
        }],
        data: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        width: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        options: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }]
      });
    })();

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](NgSelect2Module, {
        declarations: function declarations() {
          return [NgSelect2Component];
        },
        imports: function imports() {
          return [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]];
        },
        exports: function exports() {
          return [NgSelect2Component];
        }
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](NgSelect2Module, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
        args: [{
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]],
          declarations: [NgSelect2Component],
          exports: [NgSelect2Component]
        }]
      }], null, null);
    })();
    /*
     * Public API Surface of ng-select2
     */

    /**
     * Generated bundle index. Do not edit.
     */
    //# sourceMappingURL=ng-select2.js.map

    /***/

  },

  /***/
  "./node_modules/ng2-pdf-viewer/__ivy_ngcc__/fesm2015/ng2-pdf-viewer.js":
  /*!*****************************************************************************!*\
    !*** ./node_modules/ng2-pdf-viewer/__ivy_ngcc__/fesm2015/ng2-pdf-viewer.js ***!
    \*****************************************************************************/

  /*! exports provided: PdfViewerComponent, PdfViewerModule, RenderTextMode */

  /***/
  function node_modulesNg2PdfViewer__ivy_ngcc__Fesm2015Ng2PdfViewerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PdfViewerComponent", function () {
      return PdfViewerComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PdfViewerModule", function () {
      return PdfViewerModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RenderTextMode", function () {
      return RenderTextMode;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var _c0 = ["pdfViewerContainer"];

    function _createEventBus(pdfJsViewer) {
      var globalEventBus = new pdfJsViewer.EventBus(true);
      attachDOMEventsToEventBus(globalEventBus);
      return globalEventBus;
    }

    function attachDOMEventsToEventBus(eventBus) {
      eventBus.on('documentload', function () {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('documentload', true, true, {});
        window.dispatchEvent(event);
      });
      eventBus.on('pagerendered', function (evt) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('pagerendered', true, true, {
          pageNumber: evt.pageNumber,
          cssTransform: evt.cssTransform
        });
        evt.source.div.dispatchEvent(event);
      });
      eventBus.on('textlayerrendered', function (evt) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('textlayerrendered', true, true, {
          pageNumber: evt.pageNumber
        });
        evt.source.textLayerDiv.dispatchEvent(event);
      });
      eventBus.on('pagechanging', function (evt) {
        var event = document.createEvent('UIEvents');
        event.initEvent('pagechanging', true, true);
        event['pageNumber'] = evt.pageNumber;
        evt.source.container.dispatchEvent(event);
      });
      eventBus.on('pagesinit', function (evt) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('pagesinit', true, true, null);
        evt.source.container.dispatchEvent(event);
      });
      eventBus.on('pagesloaded', function (evt) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('pagesloaded', true, true, {
          pagesCount: evt.pagesCount
        });
        evt.source.container.dispatchEvent(event);
      });
      eventBus.on('scalechange', function (evt) {
        var event = document.createEvent('UIEvents');
        event.initEvent('scalechange', true, true);
        event['scale'] = evt.scale;
        event['presetValue'] = evt.presetValue;
        evt.source.container.dispatchEvent(event);
      });
      eventBus.on('updateviewarea', function (evt) {
        var event = document.createEvent('UIEvents');
        event.initEvent('updateviewarea', true, true);
        event['location'] = evt.location;
        evt.source.container.dispatchEvent(event);
      });
      eventBus.on('find', function (evt) {
        if (evt.source === window) {
          return; // event comes from FirefoxCom, no need to replicate
        }

        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('find' + evt.type, true, true, {
          query: evt.query,
          phraseSearch: evt.phraseSearch,
          caseSensitive: evt.caseSensitive,
          highlightAll: evt.highlightAll,
          findPrevious: evt.findPrevious
        });
        window.dispatchEvent(event);
      });
      eventBus.on('attachmentsloaded', function (evt) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('attachmentsloaded', true, true, {
          attachmentsCount: evt.attachmentsCount
        });
        evt.source.container.dispatchEvent(event);
      });
      eventBus.on('sidebarviewchanged', function (evt) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('sidebarviewchanged', true, true, {
          view: evt.view
        });
        evt.source.outerContainer.dispatchEvent(event);
      });
      eventBus.on('pagemode', function (evt) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('pagemode', true, true, {
          mode: evt.mode
        });
        evt.source.pdfViewer.container.dispatchEvent(event);
      });
      eventBus.on('namedaction', function (evt) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('namedaction', true, true, {
          action: evt.action
        });
        evt.source.pdfViewer.container.dispatchEvent(event);
      });
      eventBus.on('presentationmodechanged', function (evt) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('presentationmodechanged', true, true, {
          active: evt.active,
          switchInProgress: evt.switchInProgress
        });
        window.dispatchEvent(event);
      });
      eventBus.on('outlineloaded', function (evt) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent('outlineloaded', true, true, {
          outlineCount: evt.outlineCount
        });
        evt.source.container.dispatchEvent(event);
      });
    }

    var createEventBus = _createEventBus;
    var PdfViewerComponent_1;
    var PDFJS;
    var PDFJSViewer;

    function isSSR() {
      return typeof window === 'undefined';
    }

    if (!isSSR()) {
      PDFJS = __webpack_require__(
      /*! pdfjs-dist/build/pdf */
      "./node_modules/pdfjs-dist/build/pdf.js");
      PDFJSViewer = __webpack_require__(
      /*! pdfjs-dist/web/pdf_viewer */
      "./node_modules/pdfjs-dist/web/pdf_viewer.js");
      PDFJS.verbosity = PDFJS.VerbosityLevel.ERRORS;
    }

    var RenderTextMode;

    (function (RenderTextMode) {
      RenderTextMode[RenderTextMode["DISABLED"] = 0] = "DISABLED";
      RenderTextMode[RenderTextMode["ENABLED"] = 1] = "ENABLED";
      RenderTextMode[RenderTextMode["ENHANCED"] = 2] = "ENHANCED";
    })(RenderTextMode || (RenderTextMode = {}));

    var PdfViewerComponent = PdfViewerComponent_1 = /*#__PURE__*/function () {
      function PdfViewerComponent(element) {
        _classCallCheck(this, PdfViewerComponent);

        this.element = element;
        this.isVisible = false;
        this._cMapsUrl = typeof PDFJS !== 'undefined' ? "https://unpkg.com/pdfjs-dist@".concat(PDFJS.version, "/cmaps/") : null;
        this._renderText = true;
        this._renderTextMode = RenderTextMode.ENABLED;
        this._stickToPage = false;
        this._originalSize = true;
        this._page = 1;
        this._zoom = 1;
        this._rotation = 0;
        this._showAll = true;
        this._canAutoResize = true;
        this._fitToPage = false;
        this._externalLinkTarget = 'blank';
        this._showBorders = false;
        this.isInitialized = false;
        this.afterLoadComplete = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.pageRendered = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.textLayerRendered = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onError = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onProgress = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.pageChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"](true);

        if (isSSR()) {
          return;
        }

        var pdfWorkerSrc;

        if (window.hasOwnProperty('pdfWorkerSrc') && typeof window.pdfWorkerSrc === 'string' && window.pdfWorkerSrc) {
          pdfWorkerSrc = window.pdfWorkerSrc;
        } else {
          pdfWorkerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/".concat(PDFJS.version, "/pdf.worker.min.js");
        }

        PDFJS.GlobalWorkerOptions.workerSrc = pdfWorkerSrc;
      }

      _createClass(PdfViewerComponent, [{
        key: "ngAfterViewChecked",
        value: function ngAfterViewChecked() {
          var _this3 = this;

          if (this.isInitialized) {
            return;
          }

          var offset = this.pdfViewerContainer.nativeElement.offsetParent;

          if (this.isVisible === true && offset == null) {
            this.isVisible = false;
            return;
          }

          if (this.isVisible === false && offset != null) {
            this.isVisible = true;
            setTimeout(function () {
              _this3.ngOnInit();

              _this3.ngOnChanges({
                src: _this3.src
              });
            });
          }
        }
      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          if (!isSSR() && this.isVisible) {
            this.isInitialized = true;
            this.setupMultiPageViewer();
            this.setupSinglePageViewer();
          }
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._pdf) {
            this._pdf.destroy();
          }
        }
      }, {
        key: "onPageResize",
        value: function onPageResize() {
          var _this4 = this;

          if (!this._canAutoResize || !this._pdf) {
            return;
          }

          if (this.resizeTimeout) {
            clearTimeout(this.resizeTimeout);
          }

          this.resizeTimeout = setTimeout(function () {
            _this4.updateSize();
          }, 100);
        }
      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          if (isSSR() || !this.isVisible) {
            return;
          }

          if ('src' in changes) {
            this.loadPDF();
          } else if (this._pdf) {
            if ('renderText' in changes) {
              this.getCurrentViewer().textLayerMode = this._renderText ? this._renderTextMode : RenderTextMode.DISABLED;
              this.resetPdfDocument();
            } else if ('showAll' in changes) {
              this.resetPdfDocument();
            }

            if ('page' in changes) {
              if (changes['page'].currentValue === this._latestScrolledPage) {
                return;
              } // New form of page changing: The viewer will now jump to the specified page when it is changed.
              // This behavior is introducedby using the PDFSinglePageViewer


              this.getCurrentViewer().scrollPageIntoView({
                pageNumber: this._page
              });
            }

            this.update();
          }
        }
      }, {
        key: "updateSize",
        value: function updateSize() {
          var _this5 = this;

          var currentViewer = this.getCurrentViewer();

          this._pdf.getPage(currentViewer.currentPageNumber).then(function (page) {
            var rotation = _this5._rotation || page.rotate;
            var viewportWidth = page.getViewport({
              scale: _this5._zoom,
              rotation: rotation
            }).width * PdfViewerComponent_1.CSS_UNITS;
            var scale = _this5._zoom;
            var stickToPage = true; // Scale the document when it shouldn't be in original size or doesn't fit into the viewport

            if (!_this5._originalSize || _this5._fitToPage && viewportWidth > _this5.pdfViewerContainer.nativeElement.clientWidth) {
              scale = _this5.getScale(page.getViewport({
                scale: 1,
                rotation: rotation
              }).width);
              stickToPage = !_this5._stickToPage;
            }

            currentViewer._setScale(scale, stickToPage);
          });
        }
      }, {
        key: "clear",
        value: function clear() {
          if (this.loadingTask && !this.loadingTask.destroyed) {
            this.loadingTask.destroy();
          }

          if (this._pdf) {
            this._pdf.destroy();

            this._pdf = null;
            this.pdfMultiPageViewer.setDocument(null);
            this.pdfSinglePageViewer.setDocument(null);
            this.pdfMultiPageLinkService.setDocument(null, null);
            this.pdfSinglePageLinkService.setDocument(null, null);
            this.pdfMultiPageFindController.setDocument(null);
            this.pdfSinglePageFindController.setDocument(null);
          }
        }
      }, {
        key: "setupMultiPageViewer",
        value: function setupMultiPageViewer() {
          var _this6 = this;

          PDFJS.disableTextLayer = !this._renderText;
          PdfViewerComponent_1.setExternalLinkTarget(this._externalLinkTarget);
          var eventBus = createEventBus(PDFJSViewer);
          eventBus.on('pagerendered', function (e) {
            _this6.pageRendered.emit(e);
          });
          eventBus.on('pagechanging', function (e) {
            if (_this6.pageScrollTimeout) {
              clearTimeout(_this6.pageScrollTimeout);
            }

            _this6.pageScrollTimeout = setTimeout(function () {
              _this6._latestScrolledPage = e.pageNumber;

              _this6.pageChange.emit(e.pageNumber);
            }, 100);
          });
          eventBus.on('textlayerrendered', function (e) {
            _this6.textLayerRendered.emit(e);
          });
          this.pdfMultiPageLinkService = new PDFJSViewer.PDFLinkService({
            eventBus: eventBus
          });
          this.pdfMultiPageFindController = new PDFJSViewer.PDFFindController({
            linkService: this.pdfMultiPageLinkService,
            eventBus: eventBus
          });
          var pdfOptions = {
            eventBus: eventBus,
            container: this.element.nativeElement.querySelector('div'),
            removePageBorders: !this._showBorders,
            linkService: this.pdfMultiPageLinkService,
            textLayerMode: this._renderText ? this._renderTextMode : RenderTextMode.DISABLED,
            findController: this.pdfMultiPageFindController
          };
          this.pdfMultiPageViewer = new PDFJSViewer.PDFViewer(pdfOptions);
          this.pdfMultiPageLinkService.setViewer(this.pdfMultiPageViewer);
          this.pdfMultiPageFindController.setDocument(this._pdf);
        }
      }, {
        key: "setupSinglePageViewer",
        value: function setupSinglePageViewer() {
          var _this7 = this;

          PDFJS.disableTextLayer = !this._renderText;
          PdfViewerComponent_1.setExternalLinkTarget(this._externalLinkTarget);
          var eventBus = createEventBus(PDFJSViewer);
          eventBus.on('pagechanging', function (e) {
            if (e.pageNumber != _this7._page) {
              _this7.page = e.pageNumber;
            }
          });
          eventBus.on('pagerendered', function (e) {
            _this7.pageRendered.emit(e);
          });
          eventBus.on('textlayerrendered', function (e) {
            _this7.textLayerRendered.emit(e);
          });
          this.pdfSinglePageLinkService = new PDFJSViewer.PDFLinkService({
            eventBus: eventBus
          });
          this.pdfSinglePageFindController = new PDFJSViewer.PDFFindController({
            linkService: this.pdfSinglePageLinkService,
            eventBus: eventBus
          });
          var pdfOptions = {
            eventBus: eventBus,
            container: this.element.nativeElement.querySelector('div'),
            removePageBorders: !this._showBorders,
            linkService: this.pdfSinglePageLinkService,
            textLayerMode: this._renderText ? this._renderTextMode : RenderTextMode.DISABLED,
            findController: this.pdfSinglePageFindController
          };
          this.pdfSinglePageViewer = new PDFJSViewer.PDFSinglePageViewer(pdfOptions);
          this.pdfSinglePageLinkService.setViewer(this.pdfSinglePageViewer);
          this.pdfSinglePageFindController.setDocument(this._pdf);
          this.pdfSinglePageViewer._currentPageNumber = this._page;
        }
      }, {
        key: "getValidPageNumber",
        value: function getValidPageNumber(page) {
          if (page < 1) {
            return 1;
          }

          if (page > this._pdf.numPages) {
            return this._pdf.numPages;
          }

          return page;
        }
      }, {
        key: "getDocumentParams",
        value: function getDocumentParams() {
          var srcType = typeof this.src;

          if (!this._cMapsUrl) {
            return this.src;
          }

          var params = {
            cMapUrl: this._cMapsUrl,
            cMapPacked: true
          };

          if (srcType === 'string') {
            params.url = this.src;
          } else if (srcType === 'object') {
            if (this.src.byteLength !== undefined) {
              params.data = this.src;
            } else {
              Object.assign(params, this.src);
            }
          }

          return params;
        }
      }, {
        key: "loadPDF",
        value: function loadPDF() {
          var _this8 = this;

          if (!this.src) {
            return;
          }

          if (this.lastLoaded === this.src) {
            this.update();
            return;
          }

          this.clear();
          this.loadingTask = PDFJS.getDocument(this.getDocumentParams());

          this.loadingTask.onProgress = function (progressData) {
            _this8.onProgress.emit(progressData);
          };

          var src = this.src;
          this.loadingTask.promise.then(function (pdf) {
            _this8._pdf = pdf;
            _this8.lastLoaded = src;

            _this8.afterLoadComplete.emit(pdf);

            if (!_this8.pdfMultiPageViewer) {
              _this8.setupMultiPageViewer();

              _this8.setupSinglePageViewer();
            }

            _this8.resetPdfDocument();

            _this8.update();
          }, function (error) {
            _this8.onError.emit(error);
          });
        }
      }, {
        key: "update",
        value: function update() {
          this.page = this._page;
          this.render();
        }
      }, {
        key: "render",
        value: function render() {
          var _this9 = this;

          this._page = this.getValidPageNumber(this._page);
          var currentViewer = this.getCurrentViewer();

          if (this._rotation !== 0 || currentViewer.pagesRotation !== this._rotation) {
            setTimeout(function () {
              currentViewer.pagesRotation = _this9._rotation;
            });
          }

          if (this._stickToPage) {
            setTimeout(function () {
              currentViewer.currentPageNumber = _this9._page;
            });
          }

          this.updateSize();
        }
      }, {
        key: "getScale",
        value: function getScale(viewportWidth) {
          var pdfContainerWidth = this.pdfViewerContainer.nativeElement.clientWidth - (this._showBorders ? 2 * PdfViewerComponent_1.BORDER_WIDTH : 0);

          if (pdfContainerWidth === 0 || viewportWidth === 0) {
            return 1;
          }

          return this._zoom * (pdfContainerWidth / viewportWidth) / PdfViewerComponent_1.CSS_UNITS;
        }
      }, {
        key: "getCurrentViewer",
        value: function getCurrentViewer() {
          return this._showAll ? this.pdfMultiPageViewer : this.pdfSinglePageViewer;
        }
      }, {
        key: "resetPdfDocument",
        value: function resetPdfDocument() {
          this.pdfFindController.setDocument(this._pdf);

          if (this._showAll) {
            this.pdfSinglePageViewer.setDocument(null);
            this.pdfSinglePageLinkService.setDocument(null);
            this.pdfMultiPageViewer.setDocument(this._pdf);
            this.pdfMultiPageLinkService.setDocument(this._pdf, null);
          } else {
            this.pdfMultiPageViewer.setDocument(null);
            this.pdfMultiPageLinkService.setDocument(null);
            this.pdfSinglePageViewer.setDocument(this._pdf);
            this.pdfSinglePageLinkService.setDocument(this._pdf, null);
          }
        }
      }, {
        key: "cMapsUrl",
        set: function set(cMapsUrl) {
          this._cMapsUrl = cMapsUrl;
        }
      }, {
        key: "page",
        set: function set(_page) {
          _page = parseInt(_page, 10) || 1;
          var orginalPage = _page;

          if (this._pdf) {
            _page = this.getValidPageNumber(_page);
          }

          this._page = _page;

          if (orginalPage !== _page) {
            this.pageChange.emit(_page);
          }
        }
      }, {
        key: "renderText",
        set: function set(renderText) {
          this._renderText = renderText;
        }
      }, {
        key: "renderTextMode",
        set: function set(renderTextMode) {
          this._renderTextMode = renderTextMode;
        }
      }, {
        key: "originalSize",
        set: function set(originalSize) {
          this._originalSize = originalSize;
        }
      }, {
        key: "showAll",
        set: function set(value) {
          this._showAll = value;
        }
      }, {
        key: "stickToPage",
        set: function set(value) {
          this._stickToPage = value;
        }
      }, {
        key: "zoom",
        set: function set(value) {
          if (value <= 0) {
            return;
          }

          this._zoom = value;
        },
        get: function get() {
          return this._zoom;
        }
      }, {
        key: "rotation",
        set: function set(value) {
          if (!(typeof value === 'number' && value % 90 === 0)) {
            console.warn('Invalid pages rotation angle.');
            return;
          }

          this._rotation = value;
        }
      }, {
        key: "externalLinkTarget",
        set: function set(value) {
          this._externalLinkTarget = value;
        }
      }, {
        key: "autoresize",
        set: function set(value) {
          this._canAutoResize = Boolean(value);
        }
      }, {
        key: "fitToPage",
        set: function set(value) {
          this._fitToPage = Boolean(value);
        }
      }, {
        key: "showBorders",
        set: function set(value) {
          this._showBorders = Boolean(value);
        }
      }, {
        key: "pdfLinkService",
        get: function get() {
          return this._showAll ? this.pdfMultiPageLinkService : this.pdfSinglePageLinkService;
        }
      }, {
        key: "pdfViewer",
        get: function get() {
          return this.getCurrentViewer();
        }
      }, {
        key: "pdfFindController",
        get: function get() {
          return this._showAll ? this.pdfMultiPageFindController : this.pdfSinglePageFindController;
        }
      }], [{
        key: "getLinkTarget",
        value: function getLinkTarget(type) {
          switch (type) {
            case 'blank':
              return PDFJS.LinkTarget.BLANK;

            case 'none':
              return PDFJS.LinkTarget.NONE;

            case 'self':
              return PDFJS.LinkTarget.SELF;

            case 'parent':
              return PDFJS.LinkTarget.PARENT;

            case 'top':
              return PDFJS.LinkTarget.TOP;
          }

          return null;
        }
      }, {
        key: "setExternalLinkTarget",
        value: function setExternalLinkTarget(type) {
          var linkTarget = PdfViewerComponent_1.getLinkTarget(type);

          if (linkTarget !== null) {
            PDFJS.externalLinkTarget = linkTarget;
          }
        }
      }]);

      return PdfViewerComponent;
    }();

    PdfViewerComponent.ɵfac = function PdfViewerComponent_Factory(t) {
      return new (t || PdfViewerComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]));
    };

    PdfViewerComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
      type: PdfViewerComponent,
      selectors: [["pdf-viewer"]],
      viewQuery: function PdfViewerComponent_Query(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵviewQuery"](_c0, true);
        }

        if (rf & 2) {
          var _t;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵloadQuery"]()) && (ctx.pdfViewerContainer = _t.first);
        }
      },
      hostBindings: function PdfViewerComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵlistener"]("resize", function PdfViewerComponent_resize_HostBindingHandler() {
            return ctx.onPageResize();
          }, false, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵresolveWindow"]);
        }
      },
      inputs: {
        cMapsUrl: ["c-maps-url", "cMapsUrl"],
        page: "page",
        renderText: ["render-text", "renderText"],
        renderTextMode: ["render-text-mode", "renderTextMode"],
        originalSize: ["original-size", "originalSize"],
        showAll: ["show-all", "showAll"],
        stickToPage: ["stick-to-page", "stickToPage"],
        zoom: "zoom",
        rotation: "rotation",
        externalLinkTarget: ["external-link-target", "externalLinkTarget"],
        autoresize: "autoresize",
        fitToPage: ["fit-to-page", "fitToPage"],
        showBorders: ["show-borders", "showBorders"],
        src: "src"
      },
      outputs: {
        afterLoadComplete: "after-load-complete",
        pageRendered: "page-rendered",
        textLayerRendered: "text-layer-rendered",
        onError: "error",
        onProgress: "on-progress",
        pageChange: "pageChange"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵNgOnChangesFeature"]],
      decls: 3,
      vars: 0,
      consts: [[1, "ng2-pdf-viewer-container"], ["pdfViewerContainer", ""], [1, "pdfViewer"]],
      template: function PdfViewerComponent_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "div", 0, 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](2, "div", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
        }
      },
      styles: [".ng2-pdf-viewer-container[_ngcontent-%COMP%]{overflow-x:auto;position:relative;height:100%}[_nghost-%COMP%]     .textLayer{position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;opacity:.2;line-height:1}[_nghost-%COMP%]     .textLayer>span{color:transparent;position:absolute;white-space:pre;cursor:text;-webkit-transform-origin:0 0;transform-origin:0 0}[_nghost-%COMP%]     .textLayer .highlight{margin:-1px;padding:1px;background-color:#b400aa;border-radius:4px}[_nghost-%COMP%]     .textLayer .highlight.begin{border-radius:4px 0 0 4px}[_nghost-%COMP%]     .textLayer .highlight.end{border-radius:0 4px 4px 0}[_nghost-%COMP%]     .textLayer .highlight.middle{border-radius:0}[_nghost-%COMP%]     .textLayer .highlight.selected{background-color:#006400}[_nghost-%COMP%]     .textLayer ::-moz-selection{background:#00f}[_nghost-%COMP%]     .textLayer ::-moz-selection, [_nghost-%COMP%]     .textLayer ::selection{background:#00f}[_nghost-%COMP%]     .textLayer .endOfContent{display:block;position:absolute;left:0;top:100%;right:0;bottom:0;z-index:-1;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[_nghost-%COMP%]     .textLayer .endOfContent.active{top:0}[_nghost-%COMP%]     .annotationLayer section{position:absolute}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.pushButton>a, [_nghost-%COMP%]     .annotationLayer .linkAnnotation>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.pushButton>a:hover, [_nghost-%COMP%]     .annotationLayer .linkAnnotation>a:hover{opacity:.2;background:#ff0;box-shadow:0 2px 10px #ff0}[_nghost-%COMP%]     .annotationLayer .textAnnotation img{position:absolute;cursor:pointer}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea{background-color:rgba(0,54,255,.13);border:1px solid transparent;box-sizing:border-box;font-size:9px;height:100%;margin:0;padding:0 3px;vertical-align:top;width:100%}[_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select{background-color:rgba(0,54,255,.13);border:1px solid transparent;box-sizing:border-box;font-size:9px;height:100%;margin:0;padding:0 3px;vertical-align:top;width:100%}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input{background-color:rgba(0,54,255,.13);border:1px solid transparent;box-sizing:border-box;font-size:9px;height:100%;margin:0;vertical-align:top;width:100%}[_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select option{padding:0}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea{font:message-box;font-size:9px;resize:none}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input[disabled], [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea[disabled]{background:0 0;border:1px solid transparent;cursor:not-allowed}[_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select[disabled]{background:0 0;border:1px solid transparent;cursor:not-allowed}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input[disabled], [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input[disabled]{background:0 0;border:1px solid transparent;cursor:not-allowed}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input:hover, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea:hover{border:1px solid #000}[_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select:hover{border:1px solid #000}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:hover, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input:hover{border:1px solid #000}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input:focus, [_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation textarea:focus{background:0 0;border:1px solid transparent}[_nghost-%COMP%]     .annotationLayer .choiceWidgetAnnotation select:focus{background:0 0;border:1px solid transparent}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{background-color:#000;content:\"\";display:block;position:absolute;height:80%;left:45%;width:1px}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:#000;content:\"\";display:block;position:absolute;border-radius:50%;height:50%;left:30%;top:20%;width:50%}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{-webkit-transform:rotate(45deg);transform:rotate(45deg)}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}[_nghost-%COMP%]     .annotationLayer .textWidgetAnnotation input.comb:focus{width:115%}[_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.checkBox input, [_nghost-%COMP%]     .annotationLayer .buttonWidgetAnnotation.radioButton input{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0}[_nghost-%COMP%]     .annotationLayer .popupWrapper{position:absolute;width:20em}[_nghost-%COMP%]     .annotationLayer .popup{position:absolute;z-index:200;max-width:20em;background-color:#ff9;box-shadow:0 2px 5px #333;border-radius:2px;padding:.6em;margin-left:5px;cursor:pointer;font:message-box;word-wrap:break-word}[_nghost-%COMP%]     .annotationLayer .popup h1{font-size:1em;border-bottom:1px solid #000;margin:0;padding-bottom:.2em}[_nghost-%COMP%]     .annotationLayer .popup p{margin:0;padding-top:.2em}[_nghost-%COMP%]     .annotationLayer .circleAnnotation svg ellipse, [_nghost-%COMP%]     .annotationLayer .fileAttachmentAnnotation, [_nghost-%COMP%]     .annotationLayer .highlightAnnotation, [_nghost-%COMP%]     .annotationLayer .inkAnnotation svg polyline, [_nghost-%COMP%]     .annotationLayer .lineAnnotation svg line, [_nghost-%COMP%]     .annotationLayer .polygonAnnotation svg polygon, [_nghost-%COMP%]     .annotationLayer .polylineAnnotation svg polyline, [_nghost-%COMP%]     .annotationLayer .squareAnnotation svg rect, [_nghost-%COMP%]     .annotationLayer .squigglyAnnotation, [_nghost-%COMP%]     .annotationLayer .stampAnnotation, [_nghost-%COMP%]     .annotationLayer .strikeoutAnnotation, [_nghost-%COMP%]     .annotationLayer .underlineAnnotation{cursor:pointer}[_nghost-%COMP%]     .pdfViewer{padding-bottom:10px}[_nghost-%COMP%]     .pdfViewer .canvasWrapper{overflow:hidden}[_nghost-%COMP%]     .pdfViewer .page{direction:ltr;width:816px;height:1056px;margin:1px auto -8px;position:relative;overflow:visible;border:9px solid rgba(0,0,0,.01);background-clip:content-box;-o-border-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAA6UlEQVR4Xl2Pi2rEMAwE16fm1f7/r14v7w4rI0IzLAF7hLxNevBSEMEF5+OilNCsRd8ZMyn+a4NmsOT8WJw1lFbSYgGFzF2bLFoLjTClWjKKGRWpDYAGXUnZ4uhbBUzF3Oe/GG/ue2fn4GgsyXhNgysV2JnrhKEMg4fEZcALmiKbNhBBRFpSyDOj1G4QOVly6O1FV54ZZq8OVygrciDt6JazRgi1ljTPH0gbrPmHPXAbCiDd4GawIjip1TPh9tt2sz24qaCjr/jAb/GBFTbq9KZ7Ke/Cqt8nayUikZKsWZK7Fe6bg5dOUt8fZHWG2BHc+6EAAAAASUVORK5CYII=) 9 9 repeat;-webkit-border-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAA6UlEQVR4Xl2Pi2rEMAwE16fm1f7/r14v7w4rI0IzLAF7hLxNevBSEMEF5+OilNCsRd8ZMyn+a4NmsOT8WJw1lFbSYgGFzF2bLFoLjTClWjKKGRWpDYAGXUnZ4uhbBUzF3Oe/GG/ue2fn4GgsyXhNgysV2JnrhKEMg4fEZcALmiKbNhBBRFpSyDOj1G4QOVly6O1FV54ZZq8OVygrciDt6JazRgi1ljTPH0gbrPmHPXAbCiDd4GawIjip1TPh9tt2sz24qaCjr/jAb/GBFTbq9KZ7Ke/Cqt8nayUikZKsWZK7Fe6bg5dOUt8fZHWG2BHc+6EAAAAASUVORK5CYII=) 9 9 repeat;border-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAA6UlEQVR4Xl2Pi2rEMAwE16fm1f7/r14v7w4rI0IzLAF7hLxNevBSEMEF5+OilNCsRd8ZMyn+a4NmsOT8WJw1lFbSYgGFzF2bLFoLjTClWjKKGRWpDYAGXUnZ4uhbBUzF3Oe/GG/ue2fn4GgsyXhNgysV2JnrhKEMg4fEZcALmiKbNhBBRFpSyDOj1G4QOVly6O1FV54ZZq8OVygrciDt6JazRgi1ljTPH0gbrPmHPXAbCiDd4GawIjip1TPh9tt2sz24qaCjr/jAb/GBFTbq9KZ7Ke/Cqt8nayUikZKsWZK7Fe6bg5dOUt8fZHWG2BHc+6EAAAAASUVORK5CYII=) 9 9 repeat;background-color:#fff}[_nghost-%COMP%]     .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}[_nghost-%COMP%]     .pdfViewer.removePageBorders{padding-bottom:0}[_nghost-%COMP%]     .pdfViewer.singlePageView{display:inline-block}[_nghost-%COMP%]     .pdfViewer.singlePageView .page{margin:0;border:none}[_nghost-%COMP%]     .pdfViewer.scrollHorizontal, [_nghost-%COMP%]     .pdfViewer.scrollWrapped{margin-left:3.5px;margin-right:3.5px;text-align:center}[_nghost-%COMP%]     .spread{margin-left:3.5px;margin-right:3.5px;text-align:center}[_nghost-%COMP%]     .pdfViewer.scrollHorizontal, [_nghost-%COMP%]     .spread{white-space:nowrap}[_nghost-%COMP%]     .pdfViewer.removePageBorders, [_nghost-%COMP%]     .pdfViewer.scrollHorizontal .spread, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .spread{margin-left:0;margin-right:0}[_nghost-%COMP%]     .spread .page{display:inline-block;vertical-align:middle;margin-left:-3.5px;margin-right:-3.5px}[_nghost-%COMP%]     .pdfViewer.scrollHorizontal .page, [_nghost-%COMP%]     .pdfViewer.scrollHorizontal .spread, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .page, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .spread{display:inline-block;vertical-align:middle}[_nghost-%COMP%]     .pdfViewer.scrollHorizontal .page, [_nghost-%COMP%]     .pdfViewer.scrollWrapped .page{margin-left:-3.5px;margin-right:-3.5px}[_nghost-%COMP%]     .pdfViewer.removePageBorders .spread .page, [_nghost-%COMP%]     .pdfViewer.removePageBorders.scrollHorizontal .page, [_nghost-%COMP%]     .pdfViewer.removePageBorders.scrollWrapped .page{margin-left:5px;margin-right:5px}[_nghost-%COMP%]     .pdfViewer .page canvas{margin:0;display:block}[_nghost-%COMP%]     .pdfViewer .page canvas[hidden]{display:none}[_nghost-%COMP%]     .pdfViewer .page .loadingIcon{position:absolute;display:block;left:0;top:0;right:0;bottom:0;background:url(data:image/gif;base64,R0lGODlhGAAYAPQAAP///wAAAM7Ozvr6+uDg4LCwsOjo6I6OjsjIyJycnNjY2KioqMDAwPLy8nZ2doaGhri4uGhoaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJBwAAACwAAAAAGAAYAAAFriAgjiQAQWVaDgr5POSgkoTDjFE0NoQ8iw8HQZQTDQjDn4jhSABhAAOhoTqSDg7qSUQwxEaEwwFhXHhHgzOA1xshxAnfTzotGRaHglJqkJcaVEqCgyoCBQkJBQKDDXQGDYaIioyOgYSXA36XIgYMBWRzXZoKBQUMmil0lgalLSIClgBpO0g+s26nUWddXyoEDIsACq5SsTMMDIECwUdJPw0Mzsu0qHYkw72bBmozIQAh+QQJBwAAACwAAAAAGAAYAAAFsCAgjiTAMGVaDgR5HKQwqKNxIKPjjFCk0KNXC6ATKSI7oAhxWIhezwhENTCQEoeGCdWIPEgzESGxEIgGBWstEW4QCGGAIJEoxGmGt5ZkgCRQQHkGd2CESoeIIwoMBQUMP4cNeQQGDYuNj4iSb5WJnmeGng0CDGaBlIQEJziHk3sABidDAHBgagButSKvAAoyuHuUYHgCkAZqebw0AgLBQyyzNKO3byNuoSS8x8OfwIchACH5BAkHAAAALAAAAAAYABgAAAW4ICCOJIAgZVoOBJkkpDKoo5EI43GMjNPSokXCINKJCI4HcCRIQEQvqIOhGhBHhUTDhGo4diOZyFAoKEQDxra2mAEgjghOpCgz3LTBIxJ5kgwMBShACREHZ1V4Kg1rS44pBAgMDAg/Sw0GBAQGDZGTlY+YmpyPpSQDiqYiDQoCliqZBqkGAgKIS5kEjQ21VwCyp76dBHiNvz+MR74AqSOdVwbQuo+abppo10ssjdkAnc0rf8vgl8YqIQAh+QQJBwAAACwAAAAAGAAYAAAFrCAgjiQgCGVaDgZZFCQxqKNRKGOSjMjR0qLXTyciHA7AkaLACMIAiwOC1iAxCrMToHHYjWQiA4NBEA0Q1RpWxHg4cMXxNDk4OBxNUkPAQAEXDgllKgMzQA1pSYopBgonCj9JEA8REQ8QjY+RQJOVl4ugoYssBJuMpYYjDQSliwasiQOwNakALKqsqbWvIohFm7V6rQAGP6+JQLlFg7KDQLKJrLjBKbvAor3IKiEAIfkECQcAAAAsAAAAABgAGAAABbUgII4koChlmhokw5DEoI4NQ4xFMQoJO4uuhignMiQWvxGBIQC+AJBEUyUcIRiyE6CR0CllW4HABxBURTUw4nC4FcWo5CDBRpQaCoF7VjgsyCUDYDMNZ0mHdwYEBAaGMwwHDg4HDA2KjI4qkJKUiJ6faJkiA4qAKQkRB3E0i6YpAw8RERAjA4tnBoMApCMQDhFTuySKoSKMJAq6rD4GzASiJYtgi6PUcs9Kew0xh7rNJMqIhYchACH5BAkHAAAALAAAAAAYABgAAAW0ICCOJEAQZZo2JIKQxqCOjWCMDDMqxT2LAgELkBMZCoXfyCBQiFwiRsGpku0EshNgUNAtrYPT0GQVNRBWwSKBMp98P24iISgNDAS4ipGA6JUpA2WAhDR4eWM/CAkHBwkIDYcGiTOLjY+FmZkNlCN3eUoLDmwlDW+AAwcODl5bYl8wCVYMDw5UWzBtnAANEQ8kBIM0oAAGPgcREIQnVloAChEOqARjzgAQEbczg8YkWJq8nSUhACH5BAkHAAAALAAAAAAYABgAAAWtICCOJGAYZZoOpKKQqDoORDMKwkgwtiwSBBYAJ2owGL5RgxBziQQMgkwoMkhNqAEDARPSaiMDFdDIiRSFQowMXE8Z6RdpYHWnEAWGPVkajPmARVZMPUkCBQkJBQINgwaFPoeJi4GVlQ2Qc3VJBQcLV0ptfAMJBwdcIl+FYjALQgimoGNWIhAQZA4HXSpLMQ8PIgkOSHxAQhERPw7ASTSFyCMMDqBTJL8tf3y2fCEAIfkECQcAAAAsAAAAABgAGAAABa8gII4k0DRlmg6kYZCoOg5EDBDEaAi2jLO3nEkgkMEIL4BLpBAkVy3hCTAQKGAznM0AFNFGBAbj2cA9jQixcGZAGgECBu/9HnTp+FGjjezJFAwFBQwKe2Z+KoCChHmNjVMqA21nKQwJEJRlbnUFCQlFXlpeCWcGBUACCwlrdw8RKGImBwktdyMQEQciB7oACwcIeA4RVwAODiIGvHQKERAjxyMIB5QlVSTLYLZ0sW8hACH5BAkHAAAALAAAAAAYABgAAAW0ICCOJNA0ZZoOpGGQrDoOBCoSxNgQsQzgMZyIlvOJdi+AS2SoyXrK4umWPM5wNiV0UDUIBNkdoepTfMkA7thIECiyRtUAGq8fm2O4jIBgMBA1eAZ6Knx+gHaJR4QwdCMKBxEJRggFDGgQEREPjjAMBQUKIwIRDhBDC2QNDDEKoEkDoiMHDigICGkJBS2dDA6TAAnAEAkCdQ8ORQcHTAkLcQQODLPMIgIJaCWxJMIkPIoAt3EhACH5BAkHAAAALAAAAAAYABgAAAWtICCOJNA0ZZoOpGGQrDoOBCoSxNgQsQzgMZyIlvOJdi+AS2SoyXrK4umWHM5wNiV0UN3xdLiqr+mENcWpM9TIbrsBkEck8oC0DQqBQGGIz+t3eXtob0ZTPgNrIwQJDgtGAgwCWSIMDg4HiiUIDAxFAAoODwxDBWINCEGdSTQkCQcoegADBaQ6MggHjwAFBZUFCm0HB0kJCUy9bAYHCCPGIwqmRq0jySMGmj6yRiEAIfkECQcAAAAsAAAAABgAGAAABbIgII4k0DRlmg6kYZCsOg4EKhLE2BCxDOAxnIiW84l2L4BLZKipBopW8XRLDkeCiAMyMvQAA+uON4JEIo+vqukkKQ6RhLHplVGN+LyKcXA4Dgx5DWwGDXx+gIKENnqNdzIDaiMECwcFRgQCCowiCAcHCZIlCgICVgSfCEMMnA0CXaU2YSQFoQAKUQMMqjoyAglcAAyBAAIMRUYLCUkFlybDeAYJryLNk6xGNCTQXY0juHghACH5BAkHAAAALAAAAAAYABgAAAWzICCOJNA0ZVoOAmkY5KCSSgSNBDE2hDyLjohClBMNij8RJHIQvZwEVOpIekRQJyJs5AMoHA+GMbE1lnm9EcPhOHRnhpwUl3AsknHDm5RN+v8qCAkHBwkIfw1xBAYNgoSGiIqMgJQifZUjBhAJYj95ewIJCQV7KYpzBAkLLQADCHOtOpY5PgNlAAykAEUsQ1wzCgWdCIdeArczBQVbDJ0NAqyeBb64nQAGArBTt8R8mLuyPyEAOwAAAAAAAAAAAA==) center no-repeat}[_nghost-%COMP%]     .pdfPresentationMode .pdfViewer{margin-left:0;margin-right:0}[_nghost-%COMP%]     .pdfPresentationMode .pdfViewer .page, [_nghost-%COMP%]     .pdfPresentationMode .pdfViewer .spread{display:block}[_nghost-%COMP%]     .pdfPresentationMode .pdfViewer .page, [_nghost-%COMP%]     .pdfPresentationMode .pdfViewer.removePageBorders .page{margin-left:auto;margin-right:auto}[_nghost-%COMP%]     .pdfPresentationMode:-ms-fullscreen .pdfViewer .page{margin-bottom:100%!important}[_nghost-%COMP%]     .pdfPresentationMode:-webkit-full-screen .pdfViewer .page{margin-bottom:100%;border:0}[_nghost-%COMP%]     .pdfPresentationMode:-moz-full-screen .pdfViewer .page, [_nghost-%COMP%]     .pdfPresentationMode:-webkit-full-screen .pdfViewer .page, [_nghost-%COMP%]     .pdfPresentationMode:fullscreen .pdfViewer .page{margin-bottom:100%;border:0}"]
    });
    PdfViewerComponent.CSS_UNITS = 96.0 / 72.0;
    PdfViewerComponent.BORDER_WIDTH = 9;

    PdfViewerComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('pdfViewerContainer')], PdfViewerComponent.prototype, "pdfViewerContainer", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])('after-load-complete')], PdfViewerComponent.prototype, "afterLoadComplete", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])('page-rendered')], PdfViewerComponent.prototype, "pageRendered", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])('text-layer-rendered')], PdfViewerComponent.prototype, "textLayerRendered", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])('error')], PdfViewerComponent.prototype, "onError", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])('on-progress')], PdfViewerComponent.prototype, "onProgress", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])()], PdfViewerComponent.prototype, "pageChange", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], PdfViewerComponent.prototype, "src", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('c-maps-url')], PdfViewerComponent.prototype, "cMapsUrl", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('page')], PdfViewerComponent.prototype, "page", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('render-text')], PdfViewerComponent.prototype, "renderText", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('render-text-mode')], PdfViewerComponent.prototype, "renderTextMode", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('original-size')], PdfViewerComponent.prototype, "originalSize", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('show-all')], PdfViewerComponent.prototype, "showAll", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('stick-to-page')], PdfViewerComponent.prototype, "stickToPage", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('zoom')], PdfViewerComponent.prototype, "zoom", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('rotation')], PdfViewerComponent.prototype, "rotation", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('external-link-target')], PdfViewerComponent.prototype, "externalLinkTarget", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('autoresize')], PdfViewerComponent.prototype, "autoresize", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('fit-to-page')], PdfViewerComponent.prototype, "fitToPage", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])('show-borders')], PdfViewerComponent.prototype, "showBorders", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('window:resize', [])], PdfViewerComponent.prototype, "onPageResize", null);

    var PdfViewerModule = function PdfViewerModule() {
      _classCallCheck(this, PdfViewerModule);
    };

    PdfViewerModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
      type: PdfViewerModule
    });
    PdfViewerModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
      factory: function PdfViewerModule_Factory(t) {
        return new (t || PdfViewerModule)();
      }
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](PdfViewerComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
        args: [{
          selector: 'pdf-viewer',
          template: "\n    <div #pdfViewerContainer class=\"ng2-pdf-viewer-container\">\n      <div class=\"pdfViewer\"></div>\n    </div>\n  ",
          styles: [".ng2-pdf-viewer-container{overflow-x:auto;position:relative;height:100%}:host ::ng-deep .textLayer{position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;opacity:.2;line-height:1}:host ::ng-deep .textLayer>span{color:transparent;position:absolute;white-space:pre;cursor:text;-webkit-transform-origin:0 0;transform-origin:0 0}:host ::ng-deep .textLayer .highlight{margin:-1px;padding:1px;background-color:#b400aa;border-radius:4px}:host ::ng-deep .textLayer .highlight.begin{border-radius:4px 0 0 4px}:host ::ng-deep .textLayer .highlight.end{border-radius:0 4px 4px 0}:host ::ng-deep .textLayer .highlight.middle{border-radius:0}:host ::ng-deep .textLayer .highlight.selected{background-color:#006400}:host ::ng-deep .textLayer ::-moz-selection{background:#00f}:host ::ng-deep .textLayer ::-moz-selection,:host ::ng-deep .textLayer ::selection{background:#00f}:host ::ng-deep .textLayer .endOfContent{display:block;position:absolute;left:0;top:100%;right:0;bottom:0;z-index:-1;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host ::ng-deep .textLayer .endOfContent.active{top:0}:host ::ng-deep .annotationLayer section{position:absolute}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.pushButton>a,:host ::ng-deep .annotationLayer .linkAnnotation>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.pushButton>a:hover,:host ::ng-deep .annotationLayer .linkAnnotation>a:hover{opacity:.2;background:#ff0;box-shadow:0 2px 10px #ff0}:host ::ng-deep .annotationLayer .textAnnotation img{position:absolute;cursor:pointer}:host ::ng-deep .annotationLayer .textWidgetAnnotation input,:host ::ng-deep .annotationLayer .textWidgetAnnotation textarea{background-color:rgba(0,54,255,.13);border:1px solid transparent;box-sizing:border-box;font-size:9px;height:100%;margin:0;padding:0 3px;vertical-align:top;width:100%}:host ::ng-deep .annotationLayer .choiceWidgetAnnotation select{background-color:rgba(0,54,255,.13);border:1px solid transparent;box-sizing:border-box;font-size:9px;height:100%;margin:0;padding:0 3px;vertical-align:top;width:100%}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input{background-color:rgba(0,54,255,.13);border:1px solid transparent;box-sizing:border-box;font-size:9px;height:100%;margin:0;vertical-align:top;width:100%}:host ::ng-deep .annotationLayer .choiceWidgetAnnotation select option{padding:0}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}:host ::ng-deep .annotationLayer .textWidgetAnnotation textarea{font:message-box;font-size:9px;resize:none}:host ::ng-deep .annotationLayer .textWidgetAnnotation input[disabled],:host ::ng-deep .annotationLayer .textWidgetAnnotation textarea[disabled]{background:0 0;border:1px solid transparent;cursor:not-allowed}:host ::ng-deep .annotationLayer .choiceWidgetAnnotation select[disabled]{background:0 0;border:1px solid transparent;cursor:not-allowed}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input[disabled],:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input[disabled]{background:0 0;border:1px solid transparent;cursor:not-allowed}:host ::ng-deep .annotationLayer .textWidgetAnnotation input:hover,:host ::ng-deep .annotationLayer .textWidgetAnnotation textarea:hover{border:1px solid #000}:host ::ng-deep .annotationLayer .choiceWidgetAnnotation select:hover{border:1px solid #000}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:hover,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input:hover{border:1px solid #000}:host ::ng-deep .annotationLayer .textWidgetAnnotation input:focus,:host ::ng-deep .annotationLayer .textWidgetAnnotation textarea:focus{background:0 0;border:1px solid transparent}:host ::ng-deep .annotationLayer .choiceWidgetAnnotation select:focus{background:0 0;border:1px solid transparent}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{background-color:#000;content:\"\";display:block;position:absolute;height:80%;left:45%;width:1px}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:#000;content:\"\";display:block;position:absolute;border-radius:50%;height:50%;left:30%;top:20%;width:50%}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{-webkit-transform:rotate(45deg);transform:rotate(45deg)}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}:host ::ng-deep .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}:host ::ng-deep .annotationLayer .textWidgetAnnotation input.comb:focus{width:115%}:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.checkBox input,:host ::ng-deep .annotationLayer .buttonWidgetAnnotation.radioButton input{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:0}:host ::ng-deep .annotationLayer .popupWrapper{position:absolute;width:20em}:host ::ng-deep .annotationLayer .popup{position:absolute;z-index:200;max-width:20em;background-color:#ff9;box-shadow:0 2px 5px #333;border-radius:2px;padding:.6em;margin-left:5px;cursor:pointer;font:message-box;word-wrap:break-word}:host ::ng-deep .annotationLayer .popup h1{font-size:1em;border-bottom:1px solid #000;margin:0;padding-bottom:.2em}:host ::ng-deep .annotationLayer .popup p{margin:0;padding-top:.2em}:host ::ng-deep .annotationLayer .circleAnnotation svg ellipse,:host ::ng-deep .annotationLayer .fileAttachmentAnnotation,:host ::ng-deep .annotationLayer .highlightAnnotation,:host ::ng-deep .annotationLayer .inkAnnotation svg polyline,:host ::ng-deep .annotationLayer .lineAnnotation svg line,:host ::ng-deep .annotationLayer .polygonAnnotation svg polygon,:host ::ng-deep .annotationLayer .polylineAnnotation svg polyline,:host ::ng-deep .annotationLayer .squareAnnotation svg rect,:host ::ng-deep .annotationLayer .squigglyAnnotation,:host ::ng-deep .annotationLayer .stampAnnotation,:host ::ng-deep .annotationLayer .strikeoutAnnotation,:host ::ng-deep .annotationLayer .underlineAnnotation{cursor:pointer}:host ::ng-deep .pdfViewer{padding-bottom:10px}:host ::ng-deep .pdfViewer .canvasWrapper{overflow:hidden}:host ::ng-deep .pdfViewer .page{direction:ltr;width:816px;height:1056px;margin:1px auto -8px;position:relative;overflow:visible;border:9px solid rgba(0,0,0,.01);background-clip:content-box;-o-border-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAA6UlEQVR4Xl2Pi2rEMAwE16fm1f7/r14v7w4rI0IzLAF7hLxNevBSEMEF5+OilNCsRd8ZMyn+a4NmsOT8WJw1lFbSYgGFzF2bLFoLjTClWjKKGRWpDYAGXUnZ4uhbBUzF3Oe/GG/ue2fn4GgsyXhNgysV2JnrhKEMg4fEZcALmiKbNhBBRFpSyDOj1G4QOVly6O1FV54ZZq8OVygrciDt6JazRgi1ljTPH0gbrPmHPXAbCiDd4GawIjip1TPh9tt2sz24qaCjr/jAb/GBFTbq9KZ7Ke/Cqt8nayUikZKsWZK7Fe6bg5dOUt8fZHWG2BHc+6EAAAAASUVORK5CYII=) 9 9 repeat;-webkit-border-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAA6UlEQVR4Xl2Pi2rEMAwE16fm1f7/r14v7w4rI0IzLAF7hLxNevBSEMEF5+OilNCsRd8ZMyn+a4NmsOT8WJw1lFbSYgGFzF2bLFoLjTClWjKKGRWpDYAGXUnZ4uhbBUzF3Oe/GG/ue2fn4GgsyXhNgysV2JnrhKEMg4fEZcALmiKbNhBBRFpSyDOj1G4QOVly6O1FV54ZZq8OVygrciDt6JazRgi1ljTPH0gbrPmHPXAbCiDd4GawIjip1TPh9tt2sz24qaCjr/jAb/GBFTbq9KZ7Ke/Cqt8nayUikZKsWZK7Fe6bg5dOUt8fZHWG2BHc+6EAAAAASUVORK5CYII=) 9 9 repeat;border-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAA6UlEQVR4Xl2Pi2rEMAwE16fm1f7/r14v7w4rI0IzLAF7hLxNevBSEMEF5+OilNCsRd8ZMyn+a4NmsOT8WJw1lFbSYgGFzF2bLFoLjTClWjKKGRWpDYAGXUnZ4uhbBUzF3Oe/GG/ue2fn4GgsyXhNgysV2JnrhKEMg4fEZcALmiKbNhBBRFpSyDOj1G4QOVly6O1FV54ZZq8OVygrciDt6JazRgi1ljTPH0gbrPmHPXAbCiDd4GawIjip1TPh9tt2sz24qaCjr/jAb/GBFTbq9KZ7Ke/Cqt8nayUikZKsWZK7Fe6bg5dOUt8fZHWG2BHc+6EAAAAASUVORK5CYII=) 9 9 repeat;background-color:#fff}:host ::ng-deep .pdfViewer.removePageBorders .page{margin:0 auto 10px;border:none}:host ::ng-deep .pdfViewer.removePageBorders{padding-bottom:0}:host ::ng-deep .pdfViewer.singlePageView{display:inline-block}:host ::ng-deep .pdfViewer.singlePageView .page{margin:0;border:none}:host ::ng-deep .pdfViewer.scrollHorizontal,:host ::ng-deep .pdfViewer.scrollWrapped{margin-left:3.5px;margin-right:3.5px;text-align:center}:host ::ng-deep .spread{margin-left:3.5px;margin-right:3.5px;text-align:center}:host ::ng-deep .pdfViewer.scrollHorizontal,:host ::ng-deep .spread{white-space:nowrap}:host ::ng-deep .pdfViewer.removePageBorders,:host ::ng-deep .pdfViewer.scrollHorizontal .spread,:host ::ng-deep .pdfViewer.scrollWrapped .spread{margin-left:0;margin-right:0}:host ::ng-deep .spread .page{display:inline-block;vertical-align:middle;margin-left:-3.5px;margin-right:-3.5px}:host ::ng-deep .pdfViewer.scrollHorizontal .page,:host ::ng-deep .pdfViewer.scrollHorizontal .spread,:host ::ng-deep .pdfViewer.scrollWrapped .page,:host ::ng-deep .pdfViewer.scrollWrapped .spread{display:inline-block;vertical-align:middle}:host ::ng-deep .pdfViewer.scrollHorizontal .page,:host ::ng-deep .pdfViewer.scrollWrapped .page{margin-left:-3.5px;margin-right:-3.5px}:host ::ng-deep .pdfViewer.removePageBorders .spread .page,:host ::ng-deep .pdfViewer.removePageBorders.scrollHorizontal .page,:host ::ng-deep .pdfViewer.removePageBorders.scrollWrapped .page{margin-left:5px;margin-right:5px}:host ::ng-deep .pdfViewer .page canvas{margin:0;display:block}:host ::ng-deep .pdfViewer .page canvas[hidden]{display:none}:host ::ng-deep .pdfViewer .page .loadingIcon{position:absolute;display:block;left:0;top:0;right:0;bottom:0;background:url(data:image/gif;base64,R0lGODlhGAAYAPQAAP///wAAAM7Ozvr6+uDg4LCwsOjo6I6OjsjIyJycnNjY2KioqMDAwPLy8nZ2doaGhri4uGhoaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJBwAAACwAAAAAGAAYAAAFriAgjiQAQWVaDgr5POSgkoTDjFE0NoQ8iw8HQZQTDQjDn4jhSABhAAOhoTqSDg7qSUQwxEaEwwFhXHhHgzOA1xshxAnfTzotGRaHglJqkJcaVEqCgyoCBQkJBQKDDXQGDYaIioyOgYSXA36XIgYMBWRzXZoKBQUMmil0lgalLSIClgBpO0g+s26nUWddXyoEDIsACq5SsTMMDIECwUdJPw0Mzsu0qHYkw72bBmozIQAh+QQJBwAAACwAAAAAGAAYAAAFsCAgjiTAMGVaDgR5HKQwqKNxIKPjjFCk0KNXC6ATKSI7oAhxWIhezwhENTCQEoeGCdWIPEgzESGxEIgGBWstEW4QCGGAIJEoxGmGt5ZkgCRQQHkGd2CESoeIIwoMBQUMP4cNeQQGDYuNj4iSb5WJnmeGng0CDGaBlIQEJziHk3sABidDAHBgagButSKvAAoyuHuUYHgCkAZqebw0AgLBQyyzNKO3byNuoSS8x8OfwIchACH5BAkHAAAALAAAAAAYABgAAAW4ICCOJIAgZVoOBJkkpDKoo5EI43GMjNPSokXCINKJCI4HcCRIQEQvqIOhGhBHhUTDhGo4diOZyFAoKEQDxra2mAEgjghOpCgz3LTBIxJ5kgwMBShACREHZ1V4Kg1rS44pBAgMDAg/Sw0GBAQGDZGTlY+YmpyPpSQDiqYiDQoCliqZBqkGAgKIS5kEjQ21VwCyp76dBHiNvz+MR74AqSOdVwbQuo+abppo10ssjdkAnc0rf8vgl8YqIQAh+QQJBwAAACwAAAAAGAAYAAAFrCAgjiQgCGVaDgZZFCQxqKNRKGOSjMjR0qLXTyciHA7AkaLACMIAiwOC1iAxCrMToHHYjWQiA4NBEA0Q1RpWxHg4cMXxNDk4OBxNUkPAQAEXDgllKgMzQA1pSYopBgonCj9JEA8REQ8QjY+RQJOVl4ugoYssBJuMpYYjDQSliwasiQOwNakALKqsqbWvIohFm7V6rQAGP6+JQLlFg7KDQLKJrLjBKbvAor3IKiEAIfkECQcAAAAsAAAAABgAGAAABbUgII4koChlmhokw5DEoI4NQ4xFMQoJO4uuhignMiQWvxGBIQC+AJBEUyUcIRiyE6CR0CllW4HABxBURTUw4nC4FcWo5CDBRpQaCoF7VjgsyCUDYDMNZ0mHdwYEBAaGMwwHDg4HDA2KjI4qkJKUiJ6faJkiA4qAKQkRB3E0i6YpAw8RERAjA4tnBoMApCMQDhFTuySKoSKMJAq6rD4GzASiJYtgi6PUcs9Kew0xh7rNJMqIhYchACH5BAkHAAAALAAAAAAYABgAAAW0ICCOJEAQZZo2JIKQxqCOjWCMDDMqxT2LAgELkBMZCoXfyCBQiFwiRsGpku0EshNgUNAtrYPT0GQVNRBWwSKBMp98P24iISgNDAS4ipGA6JUpA2WAhDR4eWM/CAkHBwkIDYcGiTOLjY+FmZkNlCN3eUoLDmwlDW+AAwcODl5bYl8wCVYMDw5UWzBtnAANEQ8kBIM0oAAGPgcREIQnVloAChEOqARjzgAQEbczg8YkWJq8nSUhACH5BAkHAAAALAAAAAAYABgAAAWtICCOJGAYZZoOpKKQqDoORDMKwkgwtiwSBBYAJ2owGL5RgxBziQQMgkwoMkhNqAEDARPSaiMDFdDIiRSFQowMXE8Z6RdpYHWnEAWGPVkajPmARVZMPUkCBQkJBQINgwaFPoeJi4GVlQ2Qc3VJBQcLV0ptfAMJBwdcIl+FYjALQgimoGNWIhAQZA4HXSpLMQ8PIgkOSHxAQhERPw7ASTSFyCMMDqBTJL8tf3y2fCEAIfkECQcAAAAsAAAAABgAGAAABa8gII4k0DRlmg6kYZCoOg5EDBDEaAi2jLO3nEkgkMEIL4BLpBAkVy3hCTAQKGAznM0AFNFGBAbj2cA9jQixcGZAGgECBu/9HnTp+FGjjezJFAwFBQwKe2Z+KoCChHmNjVMqA21nKQwJEJRlbnUFCQlFXlpeCWcGBUACCwlrdw8RKGImBwktdyMQEQciB7oACwcIeA4RVwAODiIGvHQKERAjxyMIB5QlVSTLYLZ0sW8hACH5BAkHAAAALAAAAAAYABgAAAW0ICCOJNA0ZZoOpGGQrDoOBCoSxNgQsQzgMZyIlvOJdi+AS2SoyXrK4umWPM5wNiV0UDUIBNkdoepTfMkA7thIECiyRtUAGq8fm2O4jIBgMBA1eAZ6Knx+gHaJR4QwdCMKBxEJRggFDGgQEREPjjAMBQUKIwIRDhBDC2QNDDEKoEkDoiMHDigICGkJBS2dDA6TAAnAEAkCdQ8ORQcHTAkLcQQODLPMIgIJaCWxJMIkPIoAt3EhACH5BAkHAAAALAAAAAAYABgAAAWtICCOJNA0ZZoOpGGQrDoOBCoSxNgQsQzgMZyIlvOJdi+AS2SoyXrK4umWHM5wNiV0UN3xdLiqr+mENcWpM9TIbrsBkEck8oC0DQqBQGGIz+t3eXtob0ZTPgNrIwQJDgtGAgwCWSIMDg4HiiUIDAxFAAoODwxDBWINCEGdSTQkCQcoegADBaQ6MggHjwAFBZUFCm0HB0kJCUy9bAYHCCPGIwqmRq0jySMGmj6yRiEAIfkECQcAAAAsAAAAABgAGAAABbIgII4k0DRlmg6kYZCsOg4EKhLE2BCxDOAxnIiW84l2L4BLZKipBopW8XRLDkeCiAMyMvQAA+uON4JEIo+vqukkKQ6RhLHplVGN+LyKcXA4Dgx5DWwGDXx+gIKENnqNdzIDaiMECwcFRgQCCowiCAcHCZIlCgICVgSfCEMMnA0CXaU2YSQFoQAKUQMMqjoyAglcAAyBAAIMRUYLCUkFlybDeAYJryLNk6xGNCTQXY0juHghACH5BAkHAAAALAAAAAAYABgAAAWzICCOJNA0ZVoOAmkY5KCSSgSNBDE2hDyLjohClBMNij8RJHIQvZwEVOpIekRQJyJs5AMoHA+GMbE1lnm9EcPhOHRnhpwUl3AsknHDm5RN+v8qCAkHBwkIfw1xBAYNgoSGiIqMgJQifZUjBhAJYj95ewIJCQV7KYpzBAkLLQADCHOtOpY5PgNlAAykAEUsQ1wzCgWdCIdeArczBQVbDJ0NAqyeBb64nQAGArBTt8R8mLuyPyEAOwAAAAAAAAAAAA==) center no-repeat}:host ::ng-deep .pdfPresentationMode .pdfViewer{margin-left:0;margin-right:0}:host ::ng-deep .pdfPresentationMode .pdfViewer .page,:host ::ng-deep .pdfPresentationMode .pdfViewer .spread{display:block}:host ::ng-deep .pdfPresentationMode .pdfViewer .page,:host ::ng-deep .pdfPresentationMode .pdfViewer.removePageBorders .page{margin-left:auto;margin-right:auto}:host ::ng-deep .pdfPresentationMode:-ms-fullscreen .pdfViewer .page{margin-bottom:100%!important}:host ::ng-deep .pdfPresentationMode:-webkit-full-screen .pdfViewer .page{margin-bottom:100%;border:0}:host ::ng-deep .pdfPresentationMode:-moz-full-screen .pdfViewer .page,:host ::ng-deep .pdfPresentationMode:-webkit-full-screen .pdfViewer .page,:host ::ng-deep .pdfPresentationMode:fullscreen .pdfViewer .page{margin-bottom:100%;border:0}"]
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
        }];
      }, {
        afterLoadComplete: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"],
          args: ['after-load-complete']
        }],
        pageRendered: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"],
          args: ['page-rendered']
        }],
        textLayerRendered: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"],
          args: ['text-layer-rendered']
        }],
        onError: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"],
          args: ['error']
        }],
        onProgress: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"],
          args: ['on-progress']
        }],
        pageChange: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
        }],
        cMapsUrl: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['c-maps-url']
        }],
        page: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['page']
        }],
        renderText: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['render-text']
        }],
        renderTextMode: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['render-text-mode']
        }],
        originalSize: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['original-size']
        }],
        showAll: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['show-all']
        }],
        stickToPage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['stick-to-page']
        }],
        zoom: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['zoom']
        }],
        rotation: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['rotation']
        }],
        externalLinkTarget: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['external-link-target']
        }],
        autoresize: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['autoresize']
        }],
        fitToPage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['fit-to-page']
        }],
        showBorders: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
          args: ['show-borders']
        }],
        onPageResize: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
          args: ['window:resize', []]
        }],
        pdfViewerContainer: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
          args: ['pdfViewerContainer']
        }],
        src: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }]
      });
    })();

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](PdfViewerModule, {
        declarations: [PdfViewerComponent],
        exports: [PdfViewerComponent]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](PdfViewerModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
        args: [{
          declarations: [PdfViewerComponent],
          exports: [PdfViewerComponent]
        }]
      }], null, null);
    })();
    /**
     * Generated bundle index. Do not edit.
     */
    //# sourceMappingURL=ng2-pdf-viewer.js.map

    /***/

  },

  /***/
  "./node_modules/pdfjs-dist/build/pdf.js":
  /*!**********************************************!*\
    !*** ./node_modules/pdfjs-dist/build/pdf.js ***!
    \**********************************************/

  /*! no static exports found */

  /***/
  function node_modulesPdfjsDistBuildPdfJs(module, exports, __webpack_require__) {
    /**
     * @licstart The following is the entire license notice for the
     * Javascript code in this page
     *
     * Copyright 2020 Mozilla Foundation
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * @licend The above is the entire license notice for the
     * Javascript code in this page
     */
    (function webpackUniversalModuleDefinition(root, factory) {
      if (true) module.exports = factory();else {}
    })(this, function () {
      return (
        /******/
        function (modules) {
          // webpackBootstrap

          /******/
          // The module cache

          /******/
          var installedModules = {};
          /******/

          /******/
          // The require function

          /******/

          function __w_pdfjs_require__(moduleId) {
            /******/

            /******/
            // Check if module is in cache

            /******/
            if (installedModules[moduleId]) {
              /******/
              return installedModules[moduleId].exports;
              /******/
            }
            /******/
            // Create a new module (and put it into the cache)

            /******/


            var module = installedModules[moduleId] = {
              /******/
              i: moduleId,

              /******/
              l: false,

              /******/
              exports: {}
              /******/

            };
            /******/

            /******/
            // Execute the module function

            /******/

            modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
            /******/

            /******/
            // Flag the module as loaded

            /******/

            module.l = true;
            /******/

            /******/
            // Return the exports of the module

            /******/

            return module.exports;
            /******/
          }
          /******/

          /******/

          /******/
          // expose the modules object (__webpack_modules__)

          /******/


          __w_pdfjs_require__.m = modules;
          /******/

          /******/
          // expose the module cache

          /******/

          __w_pdfjs_require__.c = installedModules;
          /******/

          /******/
          // define getter function for harmony exports

          /******/

          __w_pdfjs_require__.d = function (exports, name, getter) {
            /******/
            if (!__w_pdfjs_require__.o(exports, name)) {
              /******/
              Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
              });
              /******/
            }
            /******/

          };
          /******/

          /******/
          // define __esModule on exports

          /******/


          __w_pdfjs_require__.r = function (exports) {
            /******/
            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /******/
              Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
              });
              /******/
            }
            /******/


            Object.defineProperty(exports, '__esModule', {
              value: true
            });
            /******/
          };
          /******/

          /******/
          // create a fake namespace object

          /******/
          // mode & 1: value is a module id, require it

          /******/
          // mode & 2: merge all properties of value into the ns

          /******/
          // mode & 4: return value when already ns object

          /******/
          // mode & 8|1: behave like require

          /******/


          __w_pdfjs_require__.t = function (value, mode) {
            /******/
            if (mode & 1) value = __w_pdfjs_require__(value);
            /******/

            if (mode & 8) return value;
            /******/

            if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
            /******/

            var ns = Object.create(null);
            /******/

            __w_pdfjs_require__.r(ns);
            /******/


            Object.defineProperty(ns, 'default', {
              enumerable: true,
              value: value
            });
            /******/

            if (mode & 2 && typeof value != 'string') for (var key in value) {
              __w_pdfjs_require__.d(ns, key, function (key) {
                return value[key];
              }.bind(null, key));
            }
            /******/

            return ns;
            /******/
          };
          /******/

          /******/
          // getDefaultExport function for compatibility with non-harmony modules

          /******/


          __w_pdfjs_require__.n = function (module) {
            /******/
            var getter = module && module.__esModule ?
            /******/
            function getDefault() {
              return module['default'];
            } :
            /******/
            function getModuleExports() {
              return module;
            };
            /******/

            __w_pdfjs_require__.d(getter, 'a', getter);
            /******/


            return getter;
            /******/
          };
          /******/

          /******/
          // Object.prototype.hasOwnProperty.call

          /******/


          __w_pdfjs_require__.o = function (object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          /******/

          /******/
          // __webpack_public_path__

          /******/


          __w_pdfjs_require__.p = "";
          /******/

          /******/

          /******/
          // Load entry module and return exports

          /******/

          return __w_pdfjs_require__(__w_pdfjs_require__.s = 0);
          /******/
        }(
        /************************************************************************/

        /******/
        [
        /* 0 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          var pdfjsVersion = '2.4.456';
          var pdfjsBuild = '228a591c';

          var pdfjsSharedUtil = __w_pdfjs_require__(1);

          var pdfjsDisplayAPI = __w_pdfjs_require__(3);

          var pdfjsDisplayTextLayer = __w_pdfjs_require__(16);

          var pdfjsDisplayAnnotationLayer = __w_pdfjs_require__(17);

          var pdfjsDisplayDisplayUtils = __w_pdfjs_require__(4);

          var pdfjsDisplaySVG = __w_pdfjs_require__(18);

          var pdfjsDisplayWorkerOptions = __w_pdfjs_require__(10);

          var pdfjsDisplayAPICompatibility = __w_pdfjs_require__(6);

          {
            var _w_pdfjs_require__ = __w_pdfjs_require__(7),
                isNodeJS = _w_pdfjs_require__.isNodeJS;

            if (isNodeJS) {
              var PDFNodeStream = __w_pdfjs_require__(19).PDFNodeStream;

              pdfjsDisplayAPI.setPDFNetworkStreamFactory(function (params) {
                return new PDFNodeStream(params);
              });
            } else {
              var PDFNetworkStream = __w_pdfjs_require__(22).PDFNetworkStream;

              var PDFFetchStream;

              if (pdfjsDisplayDisplayUtils.isFetchSupported()) {
                PDFFetchStream = __w_pdfjs_require__(23).PDFFetchStream;
              }

              pdfjsDisplayAPI.setPDFNetworkStreamFactory(function (params) {
                if (PDFFetchStream && pdfjsDisplayDisplayUtils.isValidFetchUrl(params.url)) {
                  return new PDFFetchStream(params);
                }

                return new PDFNetworkStream(params);
              });
            }
          }
          exports.build = pdfjsDisplayAPI.build;
          exports.version = pdfjsDisplayAPI.version;
          exports.getDocument = pdfjsDisplayAPI.getDocument;
          exports.LoopbackPort = pdfjsDisplayAPI.LoopbackPort;
          exports.PDFDataRangeTransport = pdfjsDisplayAPI.PDFDataRangeTransport;
          exports.PDFWorker = pdfjsDisplayAPI.PDFWorker;
          exports.renderTextLayer = pdfjsDisplayTextLayer.renderTextLayer;
          exports.AnnotationLayer = pdfjsDisplayAnnotationLayer.AnnotationLayer;
          exports.createPromiseCapability = pdfjsSharedUtil.createPromiseCapability;
          exports.PasswordResponses = pdfjsSharedUtil.PasswordResponses;
          exports.InvalidPDFException = pdfjsSharedUtil.InvalidPDFException;
          exports.MissingPDFException = pdfjsSharedUtil.MissingPDFException;
          exports.SVGGraphics = pdfjsDisplaySVG.SVGGraphics;
          exports.NativeImageDecoding = pdfjsSharedUtil.NativeImageDecoding;
          exports.CMapCompressionType = pdfjsSharedUtil.CMapCompressionType;
          exports.PermissionFlag = pdfjsSharedUtil.PermissionFlag;
          exports.UnexpectedResponseException = pdfjsSharedUtil.UnexpectedResponseException;
          exports.OPS = pdfjsSharedUtil.OPS;
          exports.VerbosityLevel = pdfjsSharedUtil.VerbosityLevel;
          exports.UNSUPPORTED_FEATURES = pdfjsSharedUtil.UNSUPPORTED_FEATURES;
          exports.createValidAbsoluteUrl = pdfjsSharedUtil.createValidAbsoluteUrl;
          exports.createObjectURL = pdfjsSharedUtil.createObjectURL;
          exports.removeNullCharacters = pdfjsSharedUtil.removeNullCharacters;
          exports.shadow = pdfjsSharedUtil.shadow;
          exports.Util = pdfjsSharedUtil.Util;
          exports.RenderingCancelledException = pdfjsDisplayDisplayUtils.RenderingCancelledException;
          exports.getFilenameFromUrl = pdfjsDisplayDisplayUtils.getFilenameFromUrl;
          exports.LinkTarget = pdfjsDisplayDisplayUtils.LinkTarget;
          exports.addLinkAttributes = pdfjsDisplayDisplayUtils.addLinkAttributes;
          exports.loadScript = pdfjsDisplayDisplayUtils.loadScript;
          exports.PDFDateString = pdfjsDisplayDisplayUtils.PDFDateString;
          exports.GlobalWorkerOptions = pdfjsDisplayWorkerOptions.GlobalWorkerOptions;
          exports.apiCompatibilityParams = pdfjsDisplayAPICompatibility.apiCompatibilityParams;
          /***/
        },
        /* 1 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.arrayByteLength = arrayByteLength;
          exports.arraysToBytes = arraysToBytes;
          exports.assert = assert;
          exports.bytesToString = bytesToString;
          exports.createPromiseCapability = createPromiseCapability;
          exports.getVerbosityLevel = getVerbosityLevel;
          exports.info = info;
          exports.isArrayBuffer = isArrayBuffer;
          exports.isArrayEqual = isArrayEqual;
          exports.isBool = isBool;
          exports.isEmptyObj = isEmptyObj;
          exports.isNum = isNum;
          exports.isString = isString;
          exports.isSameOrigin = isSameOrigin;
          exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
          exports.removeNullCharacters = removeNullCharacters;
          exports.setVerbosityLevel = setVerbosityLevel;
          exports.shadow = shadow;
          exports.string32 = string32;
          exports.stringToBytes = stringToBytes;
          exports.stringToPDFString = stringToPDFString;
          exports.stringToUTF8String = stringToUTF8String;
          exports.utf8StringToString = utf8StringToString;
          exports.warn = warn;
          exports.unreachable = unreachable;
          exports.IsEvalSupportedCached = exports.IsLittleEndianCached = exports.createObjectURL = exports.FormatError = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.NativeImageDecoding = exports.MissingPDFException = exports.InvalidPDFException = exports.AbortException = exports.CMapCompressionType = exports.ImageKind = exports.FontType = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.UNSUPPORTED_FEATURES = exports.VerbosityLevel = exports.OPS = exports.IDENTITY_MATRIX = exports.FONT_IDENTITY_MATRIX = exports.BaseException = void 0;

          __w_pdfjs_require__(2);

          var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
          exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
          var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
          exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
          var NativeImageDecoding = {
            NONE: "none",
            DECODE: "decode",
            DISPLAY: "display"
          };
          exports.NativeImageDecoding = NativeImageDecoding;
          var PermissionFlag = {
            PRINT: 0x04,
            MODIFY_CONTENTS: 0x08,
            COPY: 0x10,
            MODIFY_ANNOTATIONS: 0x20,
            FILL_INTERACTIVE_FORMS: 0x100,
            COPY_FOR_ACCESSIBILITY: 0x200,
            ASSEMBLE: 0x400,
            PRINT_HIGH_QUALITY: 0x800
          };
          exports.PermissionFlag = PermissionFlag;
          var TextRenderingMode = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          exports.TextRenderingMode = TextRenderingMode;
          var ImageKind = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          exports.ImageKind = ImageKind;
          var AnnotationType = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          exports.AnnotationType = AnnotationType;
          var AnnotationStateModelType = {
            MARKED: "Marked",
            REVIEW: "Review"
          };
          exports.AnnotationStateModelType = AnnotationStateModelType;
          var AnnotationMarkedState = {
            MARKED: "Marked",
            UNMARKED: "Unmarked"
          };
          exports.AnnotationMarkedState = AnnotationMarkedState;
          var AnnotationReviewState = {
            ACCEPTED: "Accepted",
            REJECTED: "Rejected",
            CANCELLED: "Cancelled",
            COMPLETED: "Completed",
            NONE: "None"
          };
          exports.AnnotationReviewState = AnnotationReviewState;
          var AnnotationReplyType = {
            GROUP: "Group",
            REPLY: "R"
          };
          exports.AnnotationReplyType = AnnotationReplyType;
          var AnnotationFlag = {
            INVISIBLE: 0x01,
            HIDDEN: 0x02,
            PRINT: 0x04,
            NOZOOM: 0x08,
            NOROTATE: 0x10,
            NOVIEW: 0x20,
            READONLY: 0x40,
            LOCKED: 0x80,
            TOGGLENOVIEW: 0x100,
            LOCKEDCONTENTS: 0x200
          };
          exports.AnnotationFlag = AnnotationFlag;
          var AnnotationFieldFlag = {
            READONLY: 0x0000001,
            REQUIRED: 0x0000002,
            NOEXPORT: 0x0000004,
            MULTILINE: 0x0001000,
            PASSWORD: 0x0002000,
            NOTOGGLETOOFF: 0x0004000,
            RADIO: 0x0008000,
            PUSHBUTTON: 0x0010000,
            COMBO: 0x0020000,
            EDIT: 0x0040000,
            SORT: 0x0080000,
            FILESELECT: 0x0100000,
            MULTISELECT: 0x0200000,
            DONOTSPELLCHECK: 0x0400000,
            DONOTSCROLL: 0x0800000,
            COMB: 0x1000000,
            RICHTEXT: 0x2000000,
            RADIOSINUNISON: 0x2000000,
            COMMITONSELCHANGE: 0x4000000
          };
          exports.AnnotationFieldFlag = AnnotationFieldFlag;
          var AnnotationBorderStyleType = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
          var StreamType = {
            UNKNOWN: "UNKNOWN",
            FLATE: "FLATE",
            LZW: "LZW",
            DCT: "DCT",
            JPX: "JPX",
            JBIG: "JBIG",
            A85: "A85",
            AHX: "AHX",
            CCF: "CCF",
            RLX: "RLX"
          };
          exports.StreamType = StreamType;
          var FontType = {
            UNKNOWN: "UNKNOWN",
            TYPE1: "TYPE1",
            TYPE1C: "TYPE1C",
            CIDFONTTYPE0: "CIDFONTTYPE0",
            CIDFONTTYPE0C: "CIDFONTTYPE0C",
            TRUETYPE: "TRUETYPE",
            CIDFONTTYPE2: "CIDFONTTYPE2",
            TYPE3: "TYPE3",
            OPENTYPE: "OPENTYPE",
            TYPE0: "TYPE0",
            MMTYPE1: "MMTYPE1"
          };
          exports.FontType = FontType;
          var VerbosityLevel = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          exports.VerbosityLevel = VerbosityLevel;
          var CMapCompressionType = {
            NONE: 0,
            BINARY: 1,
            STREAM: 2
          };
          exports.CMapCompressionType = CMapCompressionType;
          var OPS = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotations: 78,
            endAnnotations: 79,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintJpegXObject: 82,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          exports.OPS = OPS;
          var UNSUPPORTED_FEATURES = {
            unknown: "unknown",
            forms: "forms",
            javaScript: "javaScript",
            smask: "smask",
            shadingPattern: "shadingPattern",
            font: "font"
          };
          exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
          var PasswordResponses = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          exports.PasswordResponses = PasswordResponses;
          var verbosity = VerbosityLevel.WARNINGS;

          function setVerbosityLevel(level) {
            if (Number.isInteger(level)) {
              verbosity = level;
            }
          }

          function getVerbosityLevel() {
            return verbosity;
          }

          function info(msg) {
            if (verbosity >= VerbosityLevel.INFOS) {
              console.log("Info: ".concat(msg));
            }
          }

          function warn(msg) {
            if (verbosity >= VerbosityLevel.WARNINGS) {
              console.log("Warning: ".concat(msg));
            }
          }

          function unreachable(msg) {
            throw new Error(msg);
          }

          function assert(cond, msg) {
            if (!cond) {
              unreachable(msg);
            }
          }

          function isSameOrigin(baseUrl, otherUrl) {
            var base;

            try {
              base = new URL(baseUrl);

              if (!base.origin || base.origin === "null") {
                return false;
              }
            } catch (e) {
              return false;
            }

            var other = new URL(otherUrl, base);
            return base.origin === other.origin;
          }

          function _isValidProtocol(url) {
            if (!url) {
              return false;
            }

            switch (url.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return true;

              default:
                return false;
            }
          }

          function createValidAbsoluteUrl(url, baseUrl) {
            if (!url) {
              return null;
            }

            try {
              var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

              if (_isValidProtocol(absoluteUrl)) {
                return absoluteUrl;
              }
            } catch (ex) {}

            return null;
          }

          function shadow(obj, prop, value) {
            Object.defineProperty(obj, prop, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: false
            });
            return value;
          }

          var BaseException = function BaseExceptionClosure() {
            function BaseException(message) {
              if (this.constructor === BaseException) {
                unreachable("Cannot initialize BaseException.");
              }

              this.message = message;
              this.name = this.constructor.name;
            }

            BaseException.prototype = new Error();
            BaseException.constructor = BaseException;
            return BaseException;
          }();

          exports.BaseException = BaseException;

          var PasswordException = /*#__PURE__*/function (_BaseException) {
            _inherits(PasswordException, _BaseException);

            var _super = _createSuper(PasswordException);

            function PasswordException(msg, code) {
              var _this10;

              _classCallCheck(this, PasswordException);

              _this10 = _super.call(this, msg);
              _this10.code = code;
              return _this10;
            }

            return PasswordException;
          }(BaseException);

          exports.PasswordException = PasswordException;

          var UnknownErrorException = /*#__PURE__*/function (_BaseException2) {
            _inherits(UnknownErrorException, _BaseException2);

            var _super2 = _createSuper(UnknownErrorException);

            function UnknownErrorException(msg, details) {
              var _this11;

              _classCallCheck(this, UnknownErrorException);

              _this11 = _super2.call(this, msg);
              _this11.details = details;
              return _this11;
            }

            return UnknownErrorException;
          }(BaseException);

          exports.UnknownErrorException = UnknownErrorException;

          var InvalidPDFException = /*#__PURE__*/function (_BaseException3) {
            _inherits(InvalidPDFException, _BaseException3);

            var _super3 = _createSuper(InvalidPDFException);

            function InvalidPDFException() {
              _classCallCheck(this, InvalidPDFException);

              return _super3.apply(this, arguments);
            }

            return InvalidPDFException;
          }(BaseException);

          exports.InvalidPDFException = InvalidPDFException;

          var MissingPDFException = /*#__PURE__*/function (_BaseException4) {
            _inherits(MissingPDFException, _BaseException4);

            var _super4 = _createSuper(MissingPDFException);

            function MissingPDFException() {
              _classCallCheck(this, MissingPDFException);

              return _super4.apply(this, arguments);
            }

            return MissingPDFException;
          }(BaseException);

          exports.MissingPDFException = MissingPDFException;

          var UnexpectedResponseException = /*#__PURE__*/function (_BaseException5) {
            _inherits(UnexpectedResponseException, _BaseException5);

            var _super5 = _createSuper(UnexpectedResponseException);

            function UnexpectedResponseException(msg, status) {
              var _this12;

              _classCallCheck(this, UnexpectedResponseException);

              _this12 = _super5.call(this, msg);
              _this12.status = status;
              return _this12;
            }

            return UnexpectedResponseException;
          }(BaseException);

          exports.UnexpectedResponseException = UnexpectedResponseException;

          var FormatError = /*#__PURE__*/function (_BaseException6) {
            _inherits(FormatError, _BaseException6);

            var _super6 = _createSuper(FormatError);

            function FormatError() {
              _classCallCheck(this, FormatError);

              return _super6.apply(this, arguments);
            }

            return FormatError;
          }(BaseException);

          exports.FormatError = FormatError;

          var AbortException = /*#__PURE__*/function (_BaseException7) {
            _inherits(AbortException, _BaseException7);

            var _super7 = _createSuper(AbortException);

            function AbortException() {
              _classCallCheck(this, AbortException);

              return _super7.apply(this, arguments);
            }

            return AbortException;
          }(BaseException);

          exports.AbortException = AbortException;
          var NullCharactersRegExp = /\x00/g;

          function removeNullCharacters(str) {
            if (typeof str !== "string") {
              warn("The argument for removeNullCharacters must be a string.");
              return str;
            }

            return str.replace(NullCharactersRegExp, "");
          }

          function bytesToString(bytes) {
            assert(bytes !== null && typeof bytes === "object" && bytes.length !== undefined, "Invalid argument for bytesToString");
            var length = bytes.length;
            var MAX_ARGUMENT_COUNT = 8192;

            if (length < MAX_ARGUMENT_COUNT) {
              return String.fromCharCode.apply(null, bytes);
            }

            var strBuf = [];

            for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
              var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
              var chunk = bytes.subarray(i, chunkEnd);
              strBuf.push(String.fromCharCode.apply(null, chunk));
            }

            return strBuf.join("");
          }

          function stringToBytes(str) {
            assert(typeof str === "string", "Invalid argument for stringToBytes");
            var length = str.length;
            var bytes = new Uint8Array(length);

            for (var i = 0; i < length; ++i) {
              bytes[i] = str.charCodeAt(i) & 0xff;
            }

            return bytes;
          }

          function arrayByteLength(arr) {
            if (arr.length !== undefined) {
              return arr.length;
            }

            assert(arr.byteLength !== undefined);
            return arr.byteLength;
          }

          function arraysToBytes(arr) {
            var length = arr.length;

            if (length === 1 && arr[0] instanceof Uint8Array) {
              return arr[0];
            }

            var resultLength = 0;

            for (var i = 0; i < length; i++) {
              resultLength += arrayByteLength(arr[i]);
            }

            var pos = 0;
            var data = new Uint8Array(resultLength);

            for (var _i = 0; _i < length; _i++) {
              var item = arr[_i];

              if (!(item instanceof Uint8Array)) {
                if (typeof item === "string") {
                  item = stringToBytes(item);
                } else {
                  item = new Uint8Array(item);
                }
              }

              var itemLength = item.byteLength;
              data.set(item, pos);
              pos += itemLength;
            }

            return data;
          }

          function string32(value) {
            return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
          }

          function isLittleEndian() {
            var buffer8 = new Uint8Array(4);
            buffer8[0] = 1;
            var view32 = new Uint32Array(buffer8.buffer, 0, 1);
            return view32[0] === 1;
          }

          var IsLittleEndianCached = {
            get value() {
              return shadow(this, "value", isLittleEndian());
            }

          };
          exports.IsLittleEndianCached = IsLittleEndianCached;

          function isEvalSupported() {
            try {
              new Function("");
              return true;
            } catch (e) {
              return false;
            }
          }

          var IsEvalSupportedCached = {
            get value() {
              return shadow(this, "value", isEvalSupported());
            }

          };
          exports.IsEvalSupportedCached = IsEvalSupportedCached;
          var rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];

          var Util = /*#__PURE__*/function () {
            function Util() {
              _classCallCheck(this, Util);
            }

            _createClass(Util, null, [{
              key: "makeCssRgb",
              value: function makeCssRgb(r, g, b) {
                rgbBuf[1] = r;
                rgbBuf[3] = g;
                rgbBuf[5] = b;
                return rgbBuf.join("");
              }
            }, {
              key: "transform",
              value: function transform(m1, m2) {
                return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
              }
            }, {
              key: "applyTransform",
              value: function applyTransform(p, m) {
                var xt = p[0] * m[0] + p[1] * m[2] + m[4];
                var yt = p[0] * m[1] + p[1] * m[3] + m[5];
                return [xt, yt];
              }
            }, {
              key: "applyInverseTransform",
              value: function applyInverseTransform(p, m) {
                var d = m[0] * m[3] - m[1] * m[2];
                var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                return [xt, yt];
              }
            }, {
              key: "getAxialAlignedBoundingBox",
              value: function getAxialAlignedBoundingBox(r, m) {
                var p1 = Util.applyTransform(r, m);
                var p2 = Util.applyTransform(r.slice(2, 4), m);
                var p3 = Util.applyTransform([r[0], r[3]], m);
                var p4 = Util.applyTransform([r[2], r[1]], m);
                return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
              }
            }, {
              key: "inverseTransform",
              value: function inverseTransform(m) {
                var d = m[0] * m[3] - m[1] * m[2];
                return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
              }
            }, {
              key: "apply3dTransform",
              value: function apply3dTransform(m, v) {
                return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
              }
            }, {
              key: "singularValueDecompose2dScale",
              value: function singularValueDecompose2dScale(m) {
                var transpose = [m[0], m[2], m[1], m[3]];
                var a = m[0] * transpose[0] + m[1] * transpose[2];
                var b = m[0] * transpose[1] + m[1] * transpose[3];
                var c = m[2] * transpose[0] + m[3] * transpose[2];
                var d = m[2] * transpose[1] + m[3] * transpose[3];
                var first = (a + d) / 2;
                var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
                var sx = first + second || 1;
                var sy = first - second || 1;
                return [Math.sqrt(sx), Math.sqrt(sy)];
              }
            }, {
              key: "normalizeRect",
              value: function normalizeRect(rect) {
                var r = rect.slice(0);

                if (rect[0] > rect[2]) {
                  r[0] = rect[2];
                  r[2] = rect[0];
                }

                if (rect[1] > rect[3]) {
                  r[1] = rect[3];
                  r[3] = rect[1];
                }

                return r;
              }
            }, {
              key: "intersect",
              value: function intersect(rect1, rect2) {
                function compare(a, b) {
                  return a - b;
                }

                var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
                var orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
                var result = [];
                rect1 = Util.normalizeRect(rect1);
                rect2 = Util.normalizeRect(rect2);

                if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                  result[0] = orderedX[1];
                  result[2] = orderedX[2];
                } else {
                  return null;
                }

                if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                  result[1] = orderedY[1];
                  result[3] = orderedY[2];
                } else {
                  return null;
                }

                return result;
              }
            }]);

            return Util;
          }();

          exports.Util = Util;
          var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];

          function stringToPDFString(str) {
            var length = str.length,
                strBuf = [];

            if (str[0] === "\xFE" && str[1] === "\xFF") {
              for (var i = 2; i < length; i += 2) {
                strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
              }
            } else if (str[0] === "\xFF" && str[1] === "\xFE") {
              for (var _i2 = 2; _i2 < length; _i2 += 2) {
                strBuf.push(String.fromCharCode(str.charCodeAt(_i2 + 1) << 8 | str.charCodeAt(_i2)));
              }
            } else {
              for (var _i3 = 0; _i3 < length; ++_i3) {
                var code = PDFStringTranslateTable[str.charCodeAt(_i3)];
                strBuf.push(code ? String.fromCharCode(code) : str.charAt(_i3));
              }
            }

            return strBuf.join("");
          }

          function stringToUTF8String(str) {
            return decodeURIComponent(escape(str));
          }

          function utf8StringToString(str) {
            return unescape(encodeURIComponent(str));
          }

          function isEmptyObj(obj) {
            for (var key in obj) {
              return false;
            }

            return true;
          }

          function isBool(v) {
            return typeof v === "boolean";
          }

          function isNum(v) {
            return typeof v === "number";
          }

          function isString(v) {
            return typeof v === "string";
          }

          function isArrayBuffer(v) {
            return typeof v === "object" && v !== null && v.byteLength !== undefined;
          }

          function isArrayEqual(arr1, arr2) {
            if (arr1.length !== arr2.length) {
              return false;
            }

            return arr1.every(function (element, index) {
              return element === arr2[index];
            });
          }

          function createPromiseCapability() {
            var capability = Object.create(null);
            var isSettled = false;
            Object.defineProperty(capability, "settled", {
              get: function get() {
                return isSettled;
              }
            });
            capability.promise = new Promise(function (resolve, reject) {
              capability.resolve = function (data) {
                isSettled = true;
                resolve(data);
              };

              capability.reject = function (reason) {
                isSettled = true;
                reject(reason);
              };
            });
            return capability;
          }

          var createObjectURL = function createObjectURLClosure() {
            var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            return function createObjectURL(data, contentType) {
              var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

              if (!forceDataSchema && URL.createObjectURL) {
                var blob = new Blob([data], {
                  type: contentType
                });
                return URL.createObjectURL(blob);
              }

              var buffer = "data:".concat(contentType, ";base64,");

              for (var i = 0, ii = data.length; i < ii; i += 3) {
                var b1 = data[i] & 0xff;
                var b2 = data[i + 1] & 0xff;
                var b3 = data[i + 2] & 0xff;
                var d1 = b1 >> 2,
                    d2 = (b1 & 3) << 4 | b2 >> 4;
                var d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
                var d4 = i + 2 < ii ? b3 & 0x3f : 64;
                buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
              }

              return buffer;
            };
          }();

          exports.createObjectURL = createObjectURL;
          /***/
        },
        /* 2 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          ;
          /***/
        },
        /* 3 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getDocument = getDocument;
          exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
          exports.build = exports.version = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = void 0;

          var _util = __w_pdfjs_require__(1);

          var _display_utils = __w_pdfjs_require__(4);

          var _font_loader = __w_pdfjs_require__(5);

          var _api_compatibility = __w_pdfjs_require__(6);

          var _canvas = __w_pdfjs_require__(8);

          var _worker_options = __w_pdfjs_require__(10);

          var _is_node = __w_pdfjs_require__(7);

          var _message_handler = __w_pdfjs_require__(11);

          var _metadata = __w_pdfjs_require__(12);

          var _transport_stream = __w_pdfjs_require__(14);

          var _webgl = __w_pdfjs_require__(15);

          var DEFAULT_RANGE_CHUNK_SIZE = 65536;
          var RENDERING_CANCELLED_TIMEOUT = 100;
          var createPDFNetworkStream;

          function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
            createPDFNetworkStream = pdfNetworkStreamFactory;
          }

          function getDocument(src) {
            var task = new PDFDocumentLoadingTask();
            var source;

            if (typeof src === "string") {
              source = {
                url: src
              };
            } else if ((0, _util.isArrayBuffer)(src)) {
              source = {
                data: src
              };
            } else if (src instanceof PDFDataRangeTransport) {
              source = {
                range: src
              };
            } else {
              if (typeof src !== "object") {
                throw new Error("Invalid parameter in getDocument, " + "need either Uint8Array, string or a parameter object");
              }

              if (!src.url && !src.data && !src.range) {
                throw new Error("Invalid parameter object: need either .data, .range or .url");
              }

              source = src;
            }

            var params = Object.create(null);
            var rangeTransport = null,
                worker = null;

            for (var key in source) {
              if (key === "url" && typeof window !== "undefined") {
                params[key] = new URL(source[key], window.location).href;
                continue;
              } else if (key === "range") {
                rangeTransport = source[key];
                continue;
              } else if (key === "worker") {
                worker = source[key];
                continue;
              } else if (key === "data" && !(source[key] instanceof Uint8Array)) {
                var pdfBytes = source[key];

                if (typeof pdfBytes === "string") {
                  params[key] = (0, _util.stringToBytes)(pdfBytes);
                } else if (typeof pdfBytes === "object" && pdfBytes !== null && !isNaN(pdfBytes.length)) {
                  params[key] = new Uint8Array(pdfBytes);
                } else if ((0, _util.isArrayBuffer)(pdfBytes)) {
                  params[key] = new Uint8Array(pdfBytes);
                } else {
                  throw new Error("Invalid PDF binary data: either typed array, " + "string or array-like object is expected in the " + "data property.");
                }

                continue;
              }

              params[key] = source[key];
            }

            params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
            params.CMapReaderFactory = params.CMapReaderFactory || _display_utils.DOMCMapReaderFactory;
            params.ignoreErrors = params.stopAtErrors !== true;
            params.pdfBug = params.pdfBug === true;
            var NativeImageDecoderValues = Object.values(_util.NativeImageDecoding);

            if (params.nativeImageDecoderSupport === undefined || !NativeImageDecoderValues.includes(params.nativeImageDecoderSupport)) {
              params.nativeImageDecoderSupport = _api_compatibility.apiCompatibilityParams.nativeImageDecoderSupport || _util.NativeImageDecoding.DECODE;
            }

            if (!Number.isInteger(params.maxImageSize)) {
              params.maxImageSize = -1;
            }

            if (typeof params.isEvalSupported !== "boolean") {
              params.isEvalSupported = true;
            }

            if (typeof params.disableFontFace !== "boolean") {
              params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;
            }

            if (typeof params.disableRange !== "boolean") {
              params.disableRange = false;
            }

            if (typeof params.disableStream !== "boolean") {
              params.disableStream = false;
            }

            if (typeof params.disableAutoFetch !== "boolean") {
              params.disableAutoFetch = false;
            }

            if (typeof params.disableCreateObjectURL !== "boolean") {
              params.disableCreateObjectURL = _api_compatibility.apiCompatibilityParams.disableCreateObjectURL || false;
            }

            (0, _util.setVerbosityLevel)(params.verbosity);

            if (!worker) {
              var workerParams = {
                verbosity: params.verbosity,
                port: _worker_options.GlobalWorkerOptions.workerPort
              };
              worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
              task._worker = worker;
            }

            var docId = task.docId;
            worker.promise.then(function () {
              if (task.destroyed) {
                throw new Error("Loading aborted");
              }

              return _fetchDocument(worker, params, rangeTransport, docId).then(function (workerId) {
                if (task.destroyed) {
                  throw new Error("Loading aborted");
                }

                var networkStream;

                if (rangeTransport) {
                  networkStream = new _transport_stream.PDFDataTransportStream({
                    length: params.length,
                    initialData: params.initialData,
                    progressiveDone: params.progressiveDone,
                    disableRange: params.disableRange,
                    disableStream: params.disableStream
                  }, rangeTransport);
                } else if (!params.data) {
                  networkStream = createPDFNetworkStream({
                    url: params.url,
                    length: params.length,
                    httpHeaders: params.httpHeaders,
                    withCredentials: params.withCredentials,
                    rangeChunkSize: params.rangeChunkSize,
                    disableRange: params.disableRange,
                    disableStream: params.disableStream
                  });
                }

                var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
                messageHandler.postMessageTransfers = worker.postMessageTransfers;
                var transport = new WorkerTransport(messageHandler, task, networkStream, params);
                task._transport = transport;
                messageHandler.send("Ready", null);
              });
            })["catch"](task._capability.reject);
            return task;
          }

          function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
            if (worker.destroyed) {
              return Promise.reject(new Error("Worker was destroyed"));
            }

            if (pdfDataRangeTransport) {
              source.length = pdfDataRangeTransport.length;
              source.initialData = pdfDataRangeTransport.initialData;
              source.progressiveDone = pdfDataRangeTransport.progressiveDone;
            }

            return worker.messageHandler.sendWithPromise("GetDocRequest", {
              docId: docId,
              apiVersion: '2.4.456',
              source: {
                data: source.data,
                url: source.url,
                password: source.password,
                disableAutoFetch: source.disableAutoFetch,
                rangeChunkSize: source.rangeChunkSize,
                length: source.length
              },
              maxImageSize: source.maxImageSize,
              disableFontFace: source.disableFontFace,
              disableCreateObjectURL: source.disableCreateObjectURL,
              postMessageTransfers: worker.postMessageTransfers,
              docBaseUrl: source.docBaseUrl,
              nativeImageDecoderSupport: source.nativeImageDecoderSupport,
              ignoreErrors: source.ignoreErrors,
              isEvalSupported: source.isEvalSupported
            }).then(function (workerId) {
              if (worker.destroyed) {
                throw new Error("Worker was destroyed");
              }

              return workerId;
            });
          }

          var PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {
            var nextDocumentId = 0;

            var PDFDocumentLoadingTask = /*#__PURE__*/function () {
              function PDFDocumentLoadingTask() {
                _classCallCheck(this, PDFDocumentLoadingTask);

                this._capability = (0, _util.createPromiseCapability)();
                this._transport = null;
                this._worker = null;
                this.docId = "d" + nextDocumentId++;
                this.destroyed = false;
                this.onPassword = null;
                this.onProgress = null;
                this.onUnsupportedFeature = null;
              }

              _createClass(PDFDocumentLoadingTask, [{
                key: "destroy",
                value: function destroy() {
                  var _this13 = this;

                  this.destroyed = true;
                  var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();
                  return transportDestroyed.then(function () {
                    _this13._transport = null;

                    if (_this13._worker) {
                      _this13._worker.destroy();

                      _this13._worker = null;
                    }
                  });
                }
              }, {
                key: "then",
                value: function then(onFulfilled, onRejected) {
                  throw new Error("Removed API method: " + "PDFDocumentLoadingTask.then, use the `promise` getter instead.");
                }
              }, {
                key: "promise",
                get: function get() {
                  return this._capability.promise;
                }
              }]);

              return PDFDocumentLoadingTask;
            }();

            return PDFDocumentLoadingTask;
          }();

          var PDFDataRangeTransport = /*#__PURE__*/function () {
            function PDFDataRangeTransport(length, initialData) {
              var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

              _classCallCheck(this, PDFDataRangeTransport);

              this.length = length;
              this.initialData = initialData;
              this.progressiveDone = progressiveDone;
              this._rangeListeners = [];
              this._progressListeners = [];
              this._progressiveReadListeners = [];
              this._progressiveDoneListeners = [];
              this._readyCapability = (0, _util.createPromiseCapability)();
            }

            _createClass(PDFDataRangeTransport, [{
              key: "addRangeListener",
              value: function addRangeListener(listener) {
                this._rangeListeners.push(listener);
              }
            }, {
              key: "addProgressListener",
              value: function addProgressListener(listener) {
                this._progressListeners.push(listener);
              }
            }, {
              key: "addProgressiveReadListener",
              value: function addProgressiveReadListener(listener) {
                this._progressiveReadListeners.push(listener);
              }
            }, {
              key: "addProgressiveDoneListener",
              value: function addProgressiveDoneListener(listener) {
                this._progressiveDoneListeners.push(listener);
              }
            }, {
              key: "onDataRange",
              value: function onDataRange(begin, chunk) {
                var _iterator2 = _createForOfIteratorHelper(this._rangeListeners),
                    _step2;

                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var listener = _step2.value;
                    listener(begin, chunk);
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
              }
            }, {
              key: "onDataProgress",
              value: function onDataProgress(loaded, total) {
                var _this14 = this;

                this._readyCapability.promise.then(function () {
                  var _iterator3 = _createForOfIteratorHelper(_this14._progressListeners),
                      _step3;

                  try {
                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                      var listener = _step3.value;
                      listener(loaded, total);
                    }
                  } catch (err) {
                    _iterator3.e(err);
                  } finally {
                    _iterator3.f();
                  }
                });
              }
            }, {
              key: "onDataProgressiveRead",
              value: function onDataProgressiveRead(chunk) {
                var _this15 = this;

                this._readyCapability.promise.then(function () {
                  var _iterator4 = _createForOfIteratorHelper(_this15._progressiveReadListeners),
                      _step4;

                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                      var listener = _step4.value;
                      listener(chunk);
                    }
                  } catch (err) {
                    _iterator4.e(err);
                  } finally {
                    _iterator4.f();
                  }
                });
              }
            }, {
              key: "onDataProgressiveDone",
              value: function onDataProgressiveDone() {
                var _this16 = this;

                this._readyCapability.promise.then(function () {
                  var _iterator5 = _createForOfIteratorHelper(_this16._progressiveDoneListeners),
                      _step5;

                  try {
                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                      var listener = _step5.value;
                      listener();
                    }
                  } catch (err) {
                    _iterator5.e(err);
                  } finally {
                    _iterator5.f();
                  }
                });
              }
            }, {
              key: "transportReady",
              value: function transportReady() {
                this._readyCapability.resolve();
              }
            }, {
              key: "requestDataRange",
              value: function requestDataRange(begin, end) {
                (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
              }
            }, {
              key: "abort",
              value: function abort() {}
            }]);

            return PDFDataRangeTransport;
          }();

          exports.PDFDataRangeTransport = PDFDataRangeTransport;

          var PDFDocumentProxy = /*#__PURE__*/function () {
            function PDFDocumentProxy(pdfInfo, transport) {
              _classCallCheck(this, PDFDocumentProxy);

              this._pdfInfo = pdfInfo;
              this._transport = transport;
            }

            _createClass(PDFDocumentProxy, [{
              key: "getPage",
              value: function getPage(pageNumber) {
                return this._transport.getPage(pageNumber);
              }
            }, {
              key: "getPageIndex",
              value: function getPageIndex(ref) {
                return this._transport.getPageIndex(ref);
              }
            }, {
              key: "getDestinations",
              value: function getDestinations() {
                return this._transport.getDestinations();
              }
            }, {
              key: "getDestination",
              value: function getDestination(id) {
                return this._transport.getDestination(id);
              }
            }, {
              key: "getPageLabels",
              value: function getPageLabels() {
                return this._transport.getPageLabels();
              }
            }, {
              key: "getPageLayout",
              value: function getPageLayout() {
                return this._transport.getPageLayout();
              }
            }, {
              key: "getPageMode",
              value: function getPageMode() {
                return this._transport.getPageMode();
              }
            }, {
              key: "getViewerPreferences",
              value: function getViewerPreferences() {
                return this._transport.getViewerPreferences();
              }
            }, {
              key: "getOpenAction",
              value: function getOpenAction() {
                return this._transport.getOpenAction();
              }
            }, {
              key: "getOpenActionDestination",
              value: function getOpenActionDestination() {
                (0, _display_utils.deprecated)("getOpenActionDestination, use getOpenAction instead.");
                return this.getOpenAction().then(function (openAction) {
                  return openAction && openAction.dest ? openAction.dest : null;
                });
              }
            }, {
              key: "getAttachments",
              value: function getAttachments() {
                return this._transport.getAttachments();
              }
            }, {
              key: "getJavaScript",
              value: function getJavaScript() {
                return this._transport.getJavaScript();
              }
            }, {
              key: "getOutline",
              value: function getOutline() {
                return this._transport.getOutline();
              }
            }, {
              key: "getPermissions",
              value: function getPermissions() {
                return this._transport.getPermissions();
              }
            }, {
              key: "getMetadata",
              value: function getMetadata() {
                return this._transport.getMetadata();
              }
            }, {
              key: "getData",
              value: function getData() {
                return this._transport.getData();
              }
            }, {
              key: "getDownloadInfo",
              value: function getDownloadInfo() {
                return this._transport.downloadInfoCapability.promise;
              }
            }, {
              key: "getStats",
              value: function getStats() {
                return this._transport.getStats();
              }
            }, {
              key: "cleanup",
              value: function cleanup() {
                return this._transport.startCleanup();
              }
            }, {
              key: "destroy",
              value: function destroy() {
                return this.loadingTask.destroy();
              }
            }, {
              key: "numPages",
              get: function get() {
                return this._pdfInfo.numPages;
              }
            }, {
              key: "fingerprint",
              get: function get() {
                return this._pdfInfo.fingerprint;
              }
            }, {
              key: "loadingParams",
              get: function get() {
                return this._transport.loadingParams;
              }
            }, {
              key: "loadingTask",
              get: function get() {
                return this._transport.loadingTask;
              }
            }]);

            return PDFDocumentProxy;
          }();

          exports.PDFDocumentProxy = PDFDocumentProxy;

          var PDFPageProxy = /*#__PURE__*/function () {
            function PDFPageProxy(pageIndex, pageInfo, transport) {
              var pdfBug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

              _classCallCheck(this, PDFPageProxy);

              this._pageIndex = pageIndex;
              this._pageInfo = pageInfo;
              this._transport = transport;
              this._stats = pdfBug ? new _display_utils.StatTimer() : null;
              this._pdfBug = pdfBug;
              this.commonObjs = transport.commonObjs;
              this.objs = new PDFObjects();
              this.cleanupAfterRender = false;
              this.pendingCleanup = false;
              this.intentStates = Object.create(null);
              this.destroyed = false;
            }

            _createClass(PDFPageProxy, [{
              key: "getViewport",
              value: function getViewport() {
                var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                    scale = _ref.scale,
                    _ref$rotation = _ref.rotation,
                    rotation = _ref$rotation === void 0 ? this.rotate : _ref$rotation,
                    _ref$offsetX = _ref.offsetX,
                    offsetX = _ref$offsetX === void 0 ? 0 : _ref$offsetX,
                    _ref$offsetY = _ref.offsetY,
                    offsetY = _ref$offsetY === void 0 ? 0 : _ref$offsetY,
                    _ref$dontFlip = _ref.dontFlip,
                    dontFlip = _ref$dontFlip === void 0 ? false : _ref$dontFlip;

                if (arguments.length > 1 || typeof arguments[0] === "number") {
                  throw new Error("PDFPageProxy.getViewport is called with obsolete arguments.");
                }

                return new _display_utils.PageViewport({
                  viewBox: this.view,
                  scale: scale,
                  rotation: rotation,
                  offsetX: offsetX,
                  offsetY: offsetY,
                  dontFlip: dontFlip
                });
              }
            }, {
              key: "getAnnotations",
              value: function getAnnotations() {
                var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                    _ref2$intent = _ref2.intent,
                    intent = _ref2$intent === void 0 ? null : _ref2$intent;

                if (!this.annotationsPromise || this.annotationsIntent !== intent) {
                  this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);
                  this.annotationsIntent = intent;
                }

                return this.annotationsPromise;
              }
            }, {
              key: "render",
              value: function render(_ref3) {
                var _this17 = this;

                var canvasContext = _ref3.canvasContext,
                    viewport = _ref3.viewport,
                    _ref3$intent = _ref3.intent,
                    intent = _ref3$intent === void 0 ? "display" : _ref3$intent,
                    _ref3$enableWebGL = _ref3.enableWebGL,
                    enableWebGL = _ref3$enableWebGL === void 0 ? false : _ref3$enableWebGL,
                    _ref3$renderInteracti = _ref3.renderInteractiveForms,
                    renderInteractiveForms = _ref3$renderInteracti === void 0 ? false : _ref3$renderInteracti,
                    _ref3$transform = _ref3.transform,
                    transform = _ref3$transform === void 0 ? null : _ref3$transform,
                    _ref3$imageLayer = _ref3.imageLayer,
                    imageLayer = _ref3$imageLayer === void 0 ? null : _ref3$imageLayer,
                    _ref3$canvasFactory = _ref3.canvasFactory,
                    canvasFactory = _ref3$canvasFactory === void 0 ? null : _ref3$canvasFactory,
                    _ref3$background = _ref3.background,
                    background = _ref3$background === void 0 ? null : _ref3$background;

                if (this._stats) {
                  this._stats.time("Overall");
                }

                var renderingIntent = intent === "print" ? "print" : "display";
                this.pendingCleanup = false;

                if (!this.intentStates[renderingIntent]) {
                  this.intentStates[renderingIntent] = Object.create(null);
                }

                var intentState = this.intentStates[renderingIntent];

                if (intentState.streamReaderCancelTimeout) {
                  clearTimeout(intentState.streamReaderCancelTimeout);
                  intentState.streamReaderCancelTimeout = null;
                }

                var canvasFactoryInstance = canvasFactory || new _display_utils.DOMCanvasFactory();
                var webGLContext = new _webgl.WebGLContext({
                  enable: enableWebGL
                });

                if (!intentState.displayReadyCapability) {
                  intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                  intentState.operatorList = {
                    fnArray: [],
                    argsArray: [],
                    lastChunk: false
                  };

                  if (this._stats) {
                    this._stats.time("Page Request");
                  }

                  this._pumpOperatorList({
                    pageIndex: this._pageIndex,
                    intent: renderingIntent,
                    renderInteractiveForms: renderInteractiveForms === true
                  });
                }

                var complete = function complete(error) {
                  var i = intentState.renderTasks.indexOf(internalRenderTask);

                  if (i >= 0) {
                    intentState.renderTasks.splice(i, 1);
                  }

                  if (_this17.cleanupAfterRender || renderingIntent === "print") {
                    _this17.pendingCleanup = true;
                  }

                  _this17._tryCleanup();

                  if (error) {
                    internalRenderTask.capability.reject(error);

                    _this17._abortOperatorList({
                      intentState: intentState,
                      reason: error
                    });
                  } else {
                    internalRenderTask.capability.resolve();
                  }

                  if (_this17._stats) {
                    _this17._stats.timeEnd("Rendering");

                    _this17._stats.timeEnd("Overall");
                  }
                };

                var internalRenderTask = new InternalRenderTask({
                  callback: complete,
                  params: {
                    canvasContext: canvasContext,
                    viewport: viewport,
                    transform: transform,
                    imageLayer: imageLayer,
                    background: background
                  },
                  objs: this.objs,
                  commonObjs: this.commonObjs,
                  operatorList: intentState.operatorList,
                  pageIndex: this._pageIndex,
                  canvasFactory: canvasFactoryInstance,
                  webGLContext: webGLContext,
                  useRequestAnimationFrame: renderingIntent !== "print",
                  pdfBug: this._pdfBug
                });

                if (!intentState.renderTasks) {
                  intentState.renderTasks = [];
                }

                intentState.renderTasks.push(internalRenderTask);
                var renderTask = internalRenderTask.task;
                intentState.displayReadyCapability.promise.then(function (transparency) {
                  if (_this17.pendingCleanup) {
                    complete();
                    return;
                  }

                  if (_this17._stats) {
                    _this17._stats.time("Rendering");
                  }

                  internalRenderTask.initializeGraphics(transparency);
                  internalRenderTask.operatorListChanged();
                })["catch"](complete);
                return renderTask;
              }
            }, {
              key: "getOperatorList",
              value: function getOperatorList() {
                function operatorListChanged() {
                  if (intentState.operatorList.lastChunk) {
                    intentState.opListReadCapability.resolve(intentState.operatorList);
                    var i = intentState.renderTasks.indexOf(opListTask);

                    if (i >= 0) {
                      intentState.renderTasks.splice(i, 1);
                    }
                  }
                }

                var renderingIntent = "oplist";

                if (!this.intentStates[renderingIntent]) {
                  this.intentStates[renderingIntent] = Object.create(null);
                }

                var intentState = this.intentStates[renderingIntent];
                var opListTask;

                if (!intentState.opListReadCapability) {
                  opListTask = {};
                  opListTask.operatorListChanged = operatorListChanged;
                  intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                  intentState.renderTasks = [];
                  intentState.renderTasks.push(opListTask);
                  intentState.operatorList = {
                    fnArray: [],
                    argsArray: [],
                    lastChunk: false
                  };

                  if (this._stats) {
                    this._stats.time("Page Request");
                  }

                  this._pumpOperatorList({
                    pageIndex: this._pageIndex,
                    intent: renderingIntent
                  });
                }

                return intentState.opListReadCapability.promise;
              }
            }, {
              key: "streamTextContent",
              value: function streamTextContent() {
                var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                    _ref4$normalizeWhites = _ref4.normalizeWhitespace,
                    normalizeWhitespace = _ref4$normalizeWhites === void 0 ? false : _ref4$normalizeWhites,
                    _ref4$disableCombineT = _ref4.disableCombineTextItems,
                    disableCombineTextItems = _ref4$disableCombineT === void 0 ? false : _ref4$disableCombineT;

                var TEXT_CONTENT_CHUNK_SIZE = 100;
                return this._transport.messageHandler.sendWithStream("GetTextContent", {
                  pageIndex: this._pageIndex,
                  normalizeWhitespace: normalizeWhitespace === true,
                  combineTextItems: disableCombineTextItems !== true
                }, {
                  highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                  size: function size(textContent) {
                    return textContent.items.length;
                  }
                });
              }
            }, {
              key: "getTextContent",
              value: function getTextContent() {
                var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var readableStream = this.streamTextContent(params);
                return new Promise(function (resolve, reject) {
                  function pump() {
                    reader.read().then(function (_ref5) {
                      var _textContent$items;

                      var value = _ref5.value,
                          done = _ref5.done;

                      if (done) {
                        resolve(textContent);
                        return;
                      }

                      Object.assign(textContent.styles, value.styles);

                      (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items));

                      pump();
                    }, reject);
                  }

                  var reader = readableStream.getReader();
                  var textContent = {
                    items: [],
                    styles: Object.create(null)
                  };
                  pump();
                });
              }
            }, {
              key: "_destroy",
              value: function _destroy() {
                var _this18 = this;

                this.destroyed = true;
                this._transport.pageCache[this._pageIndex] = null;
                var waitOn = [];
                Object.keys(this.intentStates).forEach(function (intent) {
                  var intentState = _this18.intentStates[intent];

                  _this18._abortOperatorList({
                    intentState: intentState,
                    reason: new Error("Page was destroyed."),
                    force: true
                  });

                  if (intent === "oplist") {
                    return;
                  }

                  intentState.renderTasks.forEach(function (renderTask) {
                    var renderCompleted = renderTask.capability.promise["catch"](function () {});
                    waitOn.push(renderCompleted);
                    renderTask.cancel();
                  });
                });
                this.objs.clear();
                this.annotationsPromise = null;
                this.pendingCleanup = false;
                return Promise.all(waitOn);
              }
            }, {
              key: "cleanup",
              value: function cleanup() {
                var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                this.pendingCleanup = true;
                return this._tryCleanup(resetStats);
              }
            }, {
              key: "_tryCleanup",
              value: function _tryCleanup() {
                var _this19 = this;

                var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                if (!this.pendingCleanup || Object.keys(this.intentStates).some(function (intent) {
                  var intentState = _this19.intentStates[intent];
                  return intentState.renderTasks.length !== 0 || !intentState.operatorList.lastChunk;
                })) {
                  return false;
                }

                Object.keys(this.intentStates).forEach(function (intent) {
                  delete _this19.intentStates[intent];
                });
                this.objs.clear();
                this.annotationsPromise = null;

                if (resetStats && this._stats) {
                  this._stats = new _display_utils.StatTimer();
                }

                this.pendingCleanup = false;
                return true;
              }
            }, {
              key: "_startRenderPage",
              value: function _startRenderPage(transparency, intent) {
                var intentState = this.intentStates[intent];

                if (!intentState) {
                  return;
                }

                if (this._stats) {
                  this._stats.timeEnd("Page Request");
                }

                if (intentState.displayReadyCapability) {
                  intentState.displayReadyCapability.resolve(transparency);
                }
              }
            }, {
              key: "_renderPageChunk",
              value: function _renderPageChunk(operatorListChunk, intentState) {
                for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {
                  intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                  intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                }

                intentState.operatorList.lastChunk = operatorListChunk.lastChunk;

                for (var _i4 = 0; _i4 < intentState.renderTasks.length; _i4++) {
                  intentState.renderTasks[_i4].operatorListChanged();
                }

                if (operatorListChunk.lastChunk) {
                  this._tryCleanup();
                }
              }
            }, {
              key: "_pumpOperatorList",
              value: function _pumpOperatorList(args) {
                var _this20 = this;

                (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.');

                var readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args);

                var reader = readableStream.getReader();
                var intentState = this.intentStates[args.intent];
                intentState.streamReader = reader;

                var pump = function pump() {
                  reader.read().then(function (_ref6) {
                    var value = _ref6.value,
                        done = _ref6.done;

                    if (done) {
                      intentState.streamReader = null;
                      return;
                    }

                    if (_this20._transport.destroyed) {
                      return;
                    }

                    _this20._renderPageChunk(value, intentState);

                    pump();
                  }, function (reason) {
                    intentState.streamReader = null;

                    if (_this20._transport.destroyed) {
                      return;
                    }

                    if (intentState.operatorList) {
                      intentState.operatorList.lastChunk = true;

                      for (var i = 0; i < intentState.renderTasks.length; i++) {
                        intentState.renderTasks[i].operatorListChanged();
                      }

                      _this20._tryCleanup();
                    }

                    if (intentState.displayReadyCapability) {
                      intentState.displayReadyCapability.reject(reason);
                    } else if (intentState.opListReadCapability) {
                      intentState.opListReadCapability.reject(reason);
                    } else {
                      throw reason;
                    }
                  });
                };

                pump();
              }
            }, {
              key: "_abortOperatorList",
              value: function _abortOperatorList(_ref7) {
                var _this21 = this;

                var intentState = _ref7.intentState,
                    reason = _ref7.reason,
                    _ref7$force = _ref7.force,
                    force = _ref7$force === void 0 ? false : _ref7$force;
                (0, _util.assert)(reason instanceof Error || typeof reason === "object" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.');

                if (!intentState.streamReader) {
                  return;
                }

                if (!force) {
                  if (intentState.renderTasks.length !== 0) {
                    return;
                  }

                  if (reason instanceof _display_utils.RenderingCancelledException) {
                    intentState.streamReaderCancelTimeout = setTimeout(function () {
                      _this21._abortOperatorList({
                        intentState: intentState,
                        reason: reason,
                        force: true
                      });

                      intentState.streamReaderCancelTimeout = null;
                    }, RENDERING_CANCELLED_TIMEOUT);
                    return;
                  }
                }

                intentState.streamReader.cancel(new _util.AbortException(reason && reason.message));
                intentState.streamReader = null;

                if (this._transport.destroyed) {
                  return;
                }

                Object.keys(this.intentStates).some(function (intent) {
                  if (_this21.intentStates[intent] === intentState) {
                    delete _this21.intentStates[intent];
                    return true;
                  }

                  return false;
                });
                this.cleanup();
              }
            }, {
              key: "pageNumber",
              get: function get() {
                return this._pageIndex + 1;
              }
            }, {
              key: "rotate",
              get: function get() {
                return this._pageInfo.rotate;
              }
            }, {
              key: "ref",
              get: function get() {
                return this._pageInfo.ref;
              }
            }, {
              key: "userUnit",
              get: function get() {
                return this._pageInfo.userUnit;
              }
            }, {
              key: "view",
              get: function get() {
                return this._pageInfo.view;
              }
            }, {
              key: "stats",
              get: function get() {
                return this._stats;
              }
            }]);

            return PDFPageProxy;
          }();

          exports.PDFPageProxy = PDFPageProxy;

          var LoopbackPort = /*#__PURE__*/function () {
            function LoopbackPort() {
              var defer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

              _classCallCheck(this, LoopbackPort);

              this._listeners = [];
              this._defer = defer;
              this._deferred = Promise.resolve(undefined);
            }

            _createClass(LoopbackPort, [{
              key: "postMessage",
              value: function postMessage(obj, transfers) {
                var _this22 = this;

                function cloneValue(value) {
                  if (typeof value !== "object" || value === null) {
                    return value;
                  }

                  if (cloned.has(value)) {
                    return cloned.get(value);
                  }

                  var buffer, result;

                  if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
                    var transferable = transfers && transfers.includes(buffer);

                    if (transferable) {
                      result = new value.constructor(buffer, value.byteOffset, value.byteLength);
                    } else {
                      result = new value.constructor(value);
                    }

                    cloned.set(value, result);
                    return result;
                  }

                  result = Array.isArray(value) ? [] : {};
                  cloned.set(value, result);

                  for (var i in value) {
                    var desc = void 0,
                        p = value;

                    while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
                      p = Object.getPrototypeOf(p);
                    }

                    if (typeof desc.value === "undefined") {
                      continue;
                    }

                    if (typeof desc.value === "function") {
                      if (value.hasOwnProperty && value.hasOwnProperty(i)) {
                        throw new Error("LoopbackPort.postMessage - cannot clone: ".concat(value[i]));
                      }

                      continue;
                    }

                    result[i] = cloneValue(desc.value);
                  }

                  return result;
                }

                if (!this._defer) {
                  this._listeners.forEach(function (listener) {
                    listener.call(_this22, {
                      data: obj
                    });
                  });

                  return;
                }

                var cloned = new WeakMap();
                var e = {
                  data: cloneValue(obj)
                };

                this._deferred.then(function () {
                  _this22._listeners.forEach(function (listener) {
                    listener.call(_this22, e);
                  });
                });
              }
            }, {
              key: "addEventListener",
              value: function addEventListener(name, listener) {
                this._listeners.push(listener);
              }
            }, {
              key: "removeEventListener",
              value: function removeEventListener(name, listener) {
                var i = this._listeners.indexOf(listener);

                this._listeners.splice(i, 1);
              }
            }, {
              key: "terminate",
              value: function terminate() {
                this._listeners.length = 0;
              }
            }]);

            return LoopbackPort;
          }();

          exports.LoopbackPort = LoopbackPort;

          var PDFWorker = function PDFWorkerClosure() {
            var pdfWorkerPorts = new WeakMap();
            var isWorkerDisabled = false;
            var fallbackWorkerSrc;
            var nextFakeWorkerId = 0;
            var fakeWorkerCapability;

            if (_is_node.isNodeJS && "function" === "function") {
              isWorkerDisabled = true;
              fallbackWorkerSrc = "./pdf.worker.js";
            } else if (typeof document === "object" && "currentScript" in document) {
              var pdfjsFilePath = document.currentScript && document.currentScript.src;

              if (pdfjsFilePath) {
                fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
              }
            }

            function _getWorkerSrc() {
              if (_worker_options.GlobalWorkerOptions.workerSrc) {
                return _worker_options.GlobalWorkerOptions.workerSrc;
              }

              if (typeof fallbackWorkerSrc !== "undefined") {
                if (!_is_node.isNodeJS) {
                  (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                }

                return fallbackWorkerSrc;
              }

              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
            }

            function getMainThreadWorkerMessageHandler() {
              var mainWorkerMessageHandler;

              try {
                mainWorkerMessageHandler = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler;
              } catch (ex) {}

              return mainWorkerMessageHandler || null;
            }

            function setupFakeWorkerGlobal() {
              if (fakeWorkerCapability) {
                return fakeWorkerCapability.promise;
              }

              fakeWorkerCapability = (0, _util.createPromiseCapability)();

              var loader = /*#__PURE__*/function () {
                var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                  var mainWorkerMessageHandler, worker;
                  return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();

                          if (!mainWorkerMessageHandler) {
                            _context.next = 3;
                            break;
                          }

                          return _context.abrupt("return", mainWorkerMessageHandler);

                        case 3:
                          if (!(_is_node.isNodeJS && "function" === "function")) {
                            _context.next = 6;
                            break;
                          }

                          worker = eval("require")(_getWorkerSrc());
                          return _context.abrupt("return", worker.WorkerMessageHandler);

                        case 6:
                          _context.next = 8;
                          return (0, _display_utils.loadScript)(_getWorkerSrc());

                        case 8:
                          return _context.abrupt("return", window.pdfjsWorker.WorkerMessageHandler);

                        case 9:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));

                return function loader() {
                  return _ref8.apply(this, arguments);
                };
              }();

              loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);
              return fakeWorkerCapability.promise;
            }

            function createCDNWrapper(url) {
              var wrapper = "importScripts('" + url + "');";
              return URL.createObjectURL(new Blob([wrapper]));
            }

            var PDFWorker = /*#__PURE__*/function () {
              function PDFWorker() {
                var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                    _ref9$name = _ref9.name,
                    name = _ref9$name === void 0 ? null : _ref9$name,
                    _ref9$port = _ref9.port,
                    port = _ref9$port === void 0 ? null : _ref9$port,
                    _ref9$verbosity = _ref9.verbosity,
                    verbosity = _ref9$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref9$verbosity;

                _classCallCheck(this, PDFWorker);

                if (port && pdfWorkerPorts.has(port)) {
                  throw new Error("Cannot use more than one PDFWorker per port");
                }

                this.name = name;
                this.destroyed = false;
                this.postMessageTransfers = true;
                this.verbosity = verbosity;
                this._readyCapability = (0, _util.createPromiseCapability)();
                this._port = null;
                this._webWorker = null;
                this._messageHandler = null;

                if (port) {
                  pdfWorkerPorts.set(port, this);

                  this._initializeFromPort(port);

                  return;
                }

                this._initialize();
              }

              _createClass(PDFWorker, [{
                key: "_initializeFromPort",
                value: function _initializeFromPort(port) {
                  this._port = port;
                  this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);

                  this._messageHandler.on("ready", function () {});

                  this._readyCapability.resolve();
                }
              }, {
                key: "_initialize",
                value: function _initialize() {
                  var _this23 = this;

                  if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {
                    var workerSrc = _getWorkerSrc();

                    try {
                      if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
                        workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);
                      }

                      var worker = new Worker(workerSrc);
                      var messageHandler = new _message_handler.MessageHandler("main", "worker", worker);

                      var terminateEarly = function terminateEarly() {
                        worker.removeEventListener("error", onWorkerError);
                        messageHandler.destroy();
                        worker.terminate();

                        if (_this23.destroyed) {
                          _this23._readyCapability.reject(new Error("Worker was destroyed"));
                        } else {
                          _this23._setupFakeWorker();
                        }
                      };

                      var onWorkerError = function onWorkerError() {
                        if (!_this23._webWorker) {
                          terminateEarly();
                        }
                      };

                      worker.addEventListener("error", onWorkerError);
                      messageHandler.on("test", function (data) {
                        worker.removeEventListener("error", onWorkerError);

                        if (_this23.destroyed) {
                          terminateEarly();
                          return;
                        }

                        if (data) {
                          _this23._messageHandler = messageHandler;
                          _this23._port = worker;
                          _this23._webWorker = worker;

                          if (!data.supportTransfers) {
                            _this23.postMessageTransfers = false;
                          }

                          _this23._readyCapability.resolve();

                          messageHandler.send("configure", {
                            verbosity: _this23.verbosity
                          });
                        } else {
                          _this23._setupFakeWorker();

                          messageHandler.destroy();
                          worker.terminate();
                        }
                      });
                      messageHandler.on("ready", function (data) {
                        worker.removeEventListener("error", onWorkerError);

                        if (_this23.destroyed) {
                          terminateEarly();
                          return;
                        }

                        try {
                          sendTest();
                        } catch (e) {
                          _this23._setupFakeWorker();
                        }
                      });

                      var sendTest = function sendTest() {
                        var testObj = new Uint8Array([_this23.postMessageTransfers ? 255 : 0]);

                        try {
                          messageHandler.send("test", testObj, [testObj.buffer]);
                        } catch (ex) {
                          (0, _util.warn)("Cannot use postMessage transfers.");
                          testObj[0] = 0;
                          messageHandler.send("test", testObj);
                        }
                      };

                      sendTest();
                      return;
                    } catch (e) {
                      (0, _util.info)("The worker has been disabled.");
                    }
                  }

                  this._setupFakeWorker();
                }
              }, {
                key: "_setupFakeWorker",
                value: function _setupFakeWorker() {
                  var _this24 = this;

                  if (!isWorkerDisabled) {
                    (0, _util.warn)("Setting up fake worker.");
                    isWorkerDisabled = true;
                  }

                  setupFakeWorkerGlobal().then(function (WorkerMessageHandler) {
                    if (_this24.destroyed) {
                      _this24._readyCapability.reject(new Error("Worker was destroyed"));

                      return;
                    }

                    var port = new LoopbackPort();
                    _this24._port = port;
                    var id = "fake" + nextFakeWorkerId++;
                    var workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                    WorkerMessageHandler.setup(workerHandler, port);
                    var messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                    _this24._messageHandler = messageHandler;

                    _this24._readyCapability.resolve();

                    messageHandler.send("configure", {
                      verbosity: _this24.verbosity
                    });
                  })["catch"](function (reason) {
                    _this24._readyCapability.reject(new Error("Setting up fake worker failed: \"".concat(reason.message, "\".")));
                  });
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  this.destroyed = true;

                  if (this._webWorker) {
                    this._webWorker.terminate();

                    this._webWorker = null;
                  }

                  pdfWorkerPorts["delete"](this._port);
                  this._port = null;

                  if (this._messageHandler) {
                    this._messageHandler.destroy();

                    this._messageHandler = null;
                  }
                }
              }, {
                key: "promise",
                get: function get() {
                  return this._readyCapability.promise;
                }
              }, {
                key: "port",
                get: function get() {
                  return this._port;
                }
              }, {
                key: "messageHandler",
                get: function get() {
                  return this._messageHandler;
                }
              }], [{
                key: "fromPort",
                value: function fromPort(params) {
                  if (!params || !params.port) {
                    throw new Error("PDFWorker.fromPort - invalid method signature.");
                  }

                  if (pdfWorkerPorts.has(params.port)) {
                    return pdfWorkerPorts.get(params.port);
                  }

                  return new PDFWorker(params);
                }
              }, {
                key: "getWorkerSrc",
                value: function getWorkerSrc() {
                  return _getWorkerSrc();
                }
              }]);

              return PDFWorker;
            }();

            return PDFWorker;
          }();

          exports.PDFWorker = PDFWorker;

          var WorkerTransport = /*#__PURE__*/function () {
            function WorkerTransport(messageHandler, loadingTask, networkStream, params) {
              _classCallCheck(this, WorkerTransport);

              this.messageHandler = messageHandler;
              this.loadingTask = loadingTask;
              this.commonObjs = new PDFObjects();
              this.fontLoader = new _font_loader.FontLoader({
                docId: loadingTask.docId,
                onUnsupportedFeature: this._onUnsupportedFeature.bind(this)
              });
              this._params = params;
              this.CMapReaderFactory = new params.CMapReaderFactory({
                baseUrl: params.cMapUrl,
                isCompressed: params.cMapPacked
              });
              this.destroyed = false;
              this.destroyCapability = null;
              this._passwordCapability = null;
              this._networkStream = networkStream;
              this._fullReader = null;
              this._lastProgress = null;
              this.pageCache = [];
              this.pagePromises = [];
              this.downloadInfoCapability = (0, _util.createPromiseCapability)();
              this.setupMessageHandler();
            }

            _createClass(WorkerTransport, [{
              key: "destroy",
              value: function destroy() {
                var _this25 = this;

                if (this.destroyCapability) {
                  return this.destroyCapability.promise;
                }

                this.destroyed = true;
                this.destroyCapability = (0, _util.createPromiseCapability)();

                if (this._passwordCapability) {
                  this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                }

                var waitOn = [];
                this.pageCache.forEach(function (page) {
                  if (page) {
                    waitOn.push(page._destroy());
                  }
                });
                this.pageCache.length = 0;
                this.pagePromises.length = 0;
                var terminated = this.messageHandler.sendWithPromise("Terminate", null);
                waitOn.push(terminated);
                Promise.all(waitOn).then(function () {
                  _this25.fontLoader.clear();

                  if (_this25._networkStream) {
                    _this25._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                  }

                  if (_this25.messageHandler) {
                    _this25.messageHandler.destroy();

                    _this25.messageHandler = null;
                  }

                  _this25.destroyCapability.resolve();
                }, this.destroyCapability.reject);
                return this.destroyCapability.promise;
              }
            }, {
              key: "setupMessageHandler",
              value: function setupMessageHandler() {
                var _this26 = this;

                var messageHandler = this.messageHandler,
                    loadingTask = this.loadingTask;
                messageHandler.on("GetReader", function (data, sink) {
                  (0, _util.assert)(_this26._networkStream);
                  _this26._fullReader = _this26._networkStream.getFullReader();

                  _this26._fullReader.onProgress = function (evt) {
                    _this26._lastProgress = {
                      loaded: evt.loaded,
                      total: evt.total
                    };
                  };

                  sink.onPull = function () {
                    _this26._fullReader.read().then(function (_ref10) {
                      var value = _ref10.value,
                          done = _ref10.done;

                      if (done) {
                        sink.close();
                        return;
                      }

                      (0, _util.assert)((0, _util.isArrayBuffer)(value));
                      sink.enqueue(new Uint8Array(value), 1, [value]);
                    })["catch"](function (reason) {
                      sink.error(reason);
                    });
                  };

                  sink.onCancel = function (reason) {
                    _this26._fullReader.cancel(reason);
                  };
                });
                messageHandler.on("ReaderHeadersReady", function (data) {
                  var headersCapability = (0, _util.createPromiseCapability)();
                  var fullReader = _this26._fullReader;
                  fullReader.headersReady.then(function () {
                    if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                      if (_this26._lastProgress && loadingTask.onProgress) {
                        loadingTask.onProgress(_this26._lastProgress);
                      }

                      fullReader.onProgress = function (evt) {
                        if (loadingTask.onProgress) {
                          loadingTask.onProgress({
                            loaded: evt.loaded,
                            total: evt.total
                          });
                        }
                      };
                    }

                    headersCapability.resolve({
                      isStreamingSupported: fullReader.isStreamingSupported,
                      isRangeSupported: fullReader.isRangeSupported,
                      contentLength: fullReader.contentLength
                    });
                  }, headersCapability.reject);
                  return headersCapability.promise;
                });
                messageHandler.on("GetRangeReader", function (data, sink) {
                  (0, _util.assert)(_this26._networkStream);

                  var rangeReader = _this26._networkStream.getRangeReader(data.begin, data.end);

                  if (!rangeReader) {
                    sink.close();
                    return;
                  }

                  sink.onPull = function () {
                    rangeReader.read().then(function (_ref11) {
                      var value = _ref11.value,
                          done = _ref11.done;

                      if (done) {
                        sink.close();
                        return;
                      }

                      (0, _util.assert)((0, _util.isArrayBuffer)(value));
                      sink.enqueue(new Uint8Array(value), 1, [value]);
                    })["catch"](function (reason) {
                      sink.error(reason);
                    });
                  };

                  sink.onCancel = function (reason) {
                    rangeReader.cancel(reason);
                  };
                });
                messageHandler.on("GetDoc", function (_ref12) {
                  var pdfInfo = _ref12.pdfInfo;
                  _this26._numPages = pdfInfo.numPages;

                  loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, _this26));
                });
                messageHandler.on("DocException", function (ex) {
                  var reason;

                  switch (ex.name) {
                    case "PasswordException":
                      reason = new _util.PasswordException(ex.message, ex.code);
                      break;

                    case "InvalidPDFException":
                      reason = new _util.InvalidPDFException(ex.message);
                      break;

                    case "MissingPDFException":
                      reason = new _util.MissingPDFException(ex.message);
                      break;

                    case "UnexpectedResponseException":
                      reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                      break;

                    case "UnknownErrorException":
                      reason = new _util.UnknownErrorException(ex.message, ex.details);
                      break;
                  }

                  loadingTask._capability.reject(reason);
                });
                messageHandler.on("PasswordRequest", function (exception) {
                  _this26._passwordCapability = (0, _util.createPromiseCapability)();

                  if (loadingTask.onPassword) {
                    var updatePassword = function updatePassword(password) {
                      _this26._passwordCapability.resolve({
                        password: password
                      });
                    };

                    try {
                      loadingTask.onPassword(updatePassword, exception.code);
                    } catch (ex) {
                      _this26._passwordCapability.reject(ex);
                    }
                  } else {
                    _this26._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                  }

                  return _this26._passwordCapability.promise;
                });
                messageHandler.on("DataLoaded", function (data) {
                  if (loadingTask.onProgress) {
                    loadingTask.onProgress({
                      loaded: data.length,
                      total: data.length
                    });
                  }

                  _this26.downloadInfoCapability.resolve(data);
                });
                messageHandler.on("StartRenderPage", function (data) {
                  if (_this26.destroyed) {
                    return;
                  }

                  var page = _this26.pageCache[data.pageIndex];

                  page._startRenderPage(data.transparency, data.intent);
                });
                messageHandler.on("commonobj", function (data) {
                  if (_this26.destroyed) {
                    return;
                  }

                  var _data = _slicedToArray(data, 3),
                      id = _data[0],
                      type = _data[1],
                      exportedData = _data[2];

                  if (_this26.commonObjs.has(id)) {
                    return;
                  }

                  switch (type) {
                    case "Font":
                      var params = _this26._params;

                      if ("error" in exportedData) {
                        var exportedError = exportedData.error;
                        (0, _util.warn)("Error during font loading: ".concat(exportedError));

                        _this26.commonObjs.resolve(id, exportedError);

                        break;
                      }

                      var fontRegistry = null;

                      if (params.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled) {
                        fontRegistry = {
                          registerFont: function registerFont(font, url) {
                            globalThis.FontInspector.fontAdded(font, url);
                          }
                        };
                      }

                      var font = new _font_loader.FontFaceObject(exportedData, {
                        isEvalSupported: params.isEvalSupported,
                        disableFontFace: params.disableFontFace,
                        ignoreErrors: params.ignoreErrors,
                        onUnsupportedFeature: _this26._onUnsupportedFeature.bind(_this26),
                        fontRegistry: fontRegistry
                      });

                      _this26.fontLoader.bind(font).then(function () {
                        _this26.commonObjs.resolve(id, font);
                      }, function (reason) {
                        messageHandler.sendWithPromise("FontFallback", {
                          id: id
                        })["finally"](function () {
                          _this26.commonObjs.resolve(id, font);
                        });
                      });

                      break;

                    case "FontPath":
                    case "FontType3Res":
                      _this26.commonObjs.resolve(id, exportedData);

                      break;

                    default:
                      throw new Error("Got unknown common object type ".concat(type));
                  }
                });
                messageHandler.on("obj", function (data) {
                  if (_this26.destroyed) {
                    return undefined;
                  }

                  var _data2 = _slicedToArray(data, 4),
                      id = _data2[0],
                      pageIndex = _data2[1],
                      type = _data2[2],
                      imageData = _data2[3];

                  var pageProxy = _this26.pageCache[pageIndex];

                  if (pageProxy.objs.has(id)) {
                    return undefined;
                  }

                  switch (type) {
                    case "JpegStream":
                      return new Promise(function (resolve, reject) {
                        var img = new Image();

                        img.onload = function () {
                          resolve(img);
                        };

                        img.onerror = function () {
                          reject(new Error("Error during JPEG image loading"));
                          (0, _display_utils.releaseImageResources)(img);
                        };

                        img.src = imageData;
                      }).then(function (img) {
                        pageProxy.objs.resolve(id, img);
                      });

                    case "Image":
                      pageProxy.objs.resolve(id, imageData);
                      var MAX_IMAGE_SIZE_TO_STORE = 8000000;

                      if (imageData && "data" in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {
                        pageProxy.cleanupAfterRender = true;
                      }

                      break;

                    default:
                      throw new Error("Got unknown object type ".concat(type));
                  }

                  return undefined;
                });
                messageHandler.on("DocProgress", function (data) {
                  if (_this26.destroyed) {
                    return;
                  }

                  if (loadingTask.onProgress) {
                    loadingTask.onProgress({
                      loaded: data.loaded,
                      total: data.total
                    });
                  }
                });
                messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                messageHandler.on("JpegDecode", function (data) {
                  if (_this26.destroyed) {
                    return Promise.reject(new Error("Worker was destroyed"));
                  }

                  if (typeof document === "undefined") {
                    return Promise.reject(new Error('"document" is not defined.'));
                  }

                  var _data3 = _slicedToArray(data, 2),
                      imageUrl = _data3[0],
                      components = _data3[1];

                  if (components !== 3 && components !== 1) {
                    return Promise.reject(new Error("Only 3 components or 1 component can be returned"));
                  }

                  return new Promise(function (resolve, reject) {
                    var img = new Image();

                    img.onload = function () {
                      var width = img.width,
                          height = img.height;
                      var size = width * height;
                      var rgbaLength = size * 4;
                      var buf = new Uint8ClampedArray(size * components);
                      var tmpCanvas = document.createElement("canvas");
                      tmpCanvas.width = width;
                      tmpCanvas.height = height;
                      var tmpCtx = tmpCanvas.getContext("2d");
                      tmpCtx.drawImage(img, 0, 0);
                      var data = tmpCtx.getImageData(0, 0, width, height).data;

                      if (components === 3) {
                        for (var i = 0, j = 0; i < rgbaLength; i += 4, j += 3) {
                          buf[j] = data[i];
                          buf[j + 1] = data[i + 1];
                          buf[j + 2] = data[i + 2];
                        }
                      } else if (components === 1) {
                        for (var _i5 = 0, _j = 0; _i5 < rgbaLength; _i5 += 4, _j++) {
                          buf[_j] = data[_i5];
                        }
                      }

                      resolve({
                        data: buf,
                        width: width,
                        height: height
                      });
                      (0, _display_utils.releaseImageResources)(img);
                      tmpCanvas.width = 0;
                      tmpCanvas.height = 0;
                      tmpCanvas = null;
                      tmpCtx = null;
                    };

                    img.onerror = function () {
                      reject(new Error("JpegDecode failed to load image"));
                      (0, _display_utils.releaseImageResources)(img);
                    };

                    img.src = imageUrl;
                  });
                });
                messageHandler.on("FetchBuiltInCMap", function (data, sink) {
                  if (_this26.destroyed) {
                    sink.error(new Error("Worker was destroyed"));
                    return;
                  }

                  var fetched = false;

                  sink.onPull = function () {
                    if (fetched) {
                      sink.close();
                      return;
                    }

                    fetched = true;

                    _this26.CMapReaderFactory.fetch(data).then(function (builtInCMap) {
                      sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);
                    })["catch"](function (reason) {
                      sink.error(reason);
                    });
                  };
                });
              }
            }, {
              key: "_onUnsupportedFeature",
              value: function _onUnsupportedFeature(_ref13) {
                var featureId = _ref13.featureId;

                if (this.destroyed) {
                  return;
                }

                if (this.loadingTask.onUnsupportedFeature) {
                  this.loadingTask.onUnsupportedFeature(featureId);
                }
              }
            }, {
              key: "getData",
              value: function getData() {
                return this.messageHandler.sendWithPromise("GetData", null);
              }
            }, {
              key: "getPage",
              value: function getPage(pageNumber) {
                var _this27 = this;

                if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                  return Promise.reject(new Error("Invalid page request"));
                }

                var pageIndex = pageNumber - 1;

                if (pageIndex in this.pagePromises) {
                  return this.pagePromises[pageIndex];
                }

                var promise = this.messageHandler.sendWithPromise("GetPage", {
                  pageIndex: pageIndex
                }).then(function (pageInfo) {
                  if (_this27.destroyed) {
                    throw new Error("Transport destroyed");
                  }

                  var page = new PDFPageProxy(pageIndex, pageInfo, _this27, _this27._params.pdfBug);
                  _this27.pageCache[pageIndex] = page;
                  return page;
                });
                this.pagePromises[pageIndex] = promise;
                return promise;
              }
            }, {
              key: "getPageIndex",
              value: function getPageIndex(ref) {
                return this.messageHandler.sendWithPromise("GetPageIndex", {
                  ref: ref
                })["catch"](function (reason) {
                  return Promise.reject(new Error(reason));
                });
              }
            }, {
              key: "getAnnotations",
              value: function getAnnotations(pageIndex, intent) {
                return this.messageHandler.sendWithPromise("GetAnnotations", {
                  pageIndex: pageIndex,
                  intent: intent
                });
              }
            }, {
              key: "getDestinations",
              value: function getDestinations() {
                return this.messageHandler.sendWithPromise("GetDestinations", null);
              }
            }, {
              key: "getDestination",
              value: function getDestination(id) {
                if (typeof id !== "string") {
                  return Promise.reject(new Error("Invalid destination request."));
                }

                return this.messageHandler.sendWithPromise("GetDestination", {
                  id: id
                });
              }
            }, {
              key: "getPageLabels",
              value: function getPageLabels() {
                return this.messageHandler.sendWithPromise("GetPageLabels", null);
              }
            }, {
              key: "getPageLayout",
              value: function getPageLayout() {
                return this.messageHandler.sendWithPromise("GetPageLayout", null);
              }
            }, {
              key: "getPageMode",
              value: function getPageMode() {
                return this.messageHandler.sendWithPromise("GetPageMode", null);
              }
            }, {
              key: "getViewerPreferences",
              value: function getViewerPreferences() {
                return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
              }
            }, {
              key: "getOpenAction",
              value: function getOpenAction() {
                return this.messageHandler.sendWithPromise("GetOpenAction", null);
              }
            }, {
              key: "getAttachments",
              value: function getAttachments() {
                return this.messageHandler.sendWithPromise("GetAttachments", null);
              }
            }, {
              key: "getJavaScript",
              value: function getJavaScript() {
                return this.messageHandler.sendWithPromise("GetJavaScript", null);
              }
            }, {
              key: "getOutline",
              value: function getOutline() {
                return this.messageHandler.sendWithPromise("GetOutline", null);
              }
            }, {
              key: "getPermissions",
              value: function getPermissions() {
                return this.messageHandler.sendWithPromise("GetPermissions", null);
              }
            }, {
              key: "getMetadata",
              value: function getMetadata() {
                var _this28 = this;

                return this.messageHandler.sendWithPromise("GetMetadata", null).then(function (results) {
                  return {
                    info: results[0],
                    metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                    contentDispositionFilename: _this28._fullReader ? _this28._fullReader.filename : null
                  };
                });
              }
            }, {
              key: "getStats",
              value: function getStats() {
                return this.messageHandler.sendWithPromise("GetStats", null);
              }
            }, {
              key: "startCleanup",
              value: function startCleanup() {
                var _this29 = this;

                return this.messageHandler.sendWithPromise("Cleanup", null).then(function () {
                  for (var i = 0, ii = _this29.pageCache.length; i < ii; i++) {
                    var page = _this29.pageCache[i];

                    if (page) {
                      var cleanupSuccessful = page.cleanup();

                      if (!cleanupSuccessful) {
                        throw new Error("startCleanup: Page ".concat(i + 1, " is currently rendering."));
                      }
                    }
                  }

                  _this29.commonObjs.clear();

                  _this29.fontLoader.clear();
                });
              }
            }, {
              key: "loadingParams",
              get: function get() {
                var params = this._params;
                return (0, _util.shadow)(this, "loadingParams", {
                  disableAutoFetch: params.disableAutoFetch,
                  disableCreateObjectURL: params.disableCreateObjectURL,
                  disableFontFace: params.disableFontFace,
                  nativeImageDecoderSupport: params.nativeImageDecoderSupport
                });
              }
            }]);

            return WorkerTransport;
          }();

          var PDFObjects = /*#__PURE__*/function () {
            function PDFObjects() {
              _classCallCheck(this, PDFObjects);

              this._objs = Object.create(null);
            }

            _createClass(PDFObjects, [{
              key: "_ensureObj",
              value: function _ensureObj(objId) {
                if (this._objs[objId]) {
                  return this._objs[objId];
                }

                return this._objs[objId] = {
                  capability: (0, _util.createPromiseCapability)(),
                  data: null,
                  resolved: false
                };
              }
            }, {
              key: "get",
              value: function get(objId) {
                var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

                if (callback) {
                  this._ensureObj(objId).capability.promise.then(callback);

                  return null;
                }

                var obj = this._objs[objId];

                if (!obj || !obj.resolved) {
                  throw new Error("Requesting object that isn't resolved yet ".concat(objId, "."));
                }

                return obj.data;
              }
            }, {
              key: "has",
              value: function has(objId) {
                var obj = this._objs[objId];
                return obj ? obj.resolved : false;
              }
            }, {
              key: "resolve",
              value: function resolve(objId, data) {
                var obj = this._ensureObj(objId);

                obj.resolved = true;
                obj.data = data;
                obj.capability.resolve(data);
              }
            }, {
              key: "clear",
              value: function clear() {
                for (var objId in this._objs) {
                  var data = this._objs[objId].data;

                  if (typeof Image !== "undefined" && data instanceof Image) {
                    (0, _display_utils.releaseImageResources)(data);
                  }
                }

                this._objs = Object.create(null);
              }
            }]);

            return PDFObjects;
          }();

          var RenderTask = /*#__PURE__*/function () {
            function RenderTask(internalRenderTask) {
              _classCallCheck(this, RenderTask);

              this._internalRenderTask = internalRenderTask;
              this.onContinue = null;
            }

            _createClass(RenderTask, [{
              key: "cancel",
              value: function cancel() {
                this._internalRenderTask.cancel();
              }
            }, {
              key: "then",
              value: function then(onFulfilled, onRejected) {
                throw new Error("Removed API method: " + "RenderTask.then, use the `promise` getter instead.");
              }
            }, {
              key: "promise",
              get: function get() {
                return this._internalRenderTask.capability.promise;
              }
            }]);

            return RenderTask;
          }();

          var InternalRenderTask = function InternalRenderTaskClosure() {
            var canvasInRendering = new WeakSet();

            var InternalRenderTask = /*#__PURE__*/function () {
              function InternalRenderTask(_ref14) {
                var callback = _ref14.callback,
                    params = _ref14.params,
                    objs = _ref14.objs,
                    commonObjs = _ref14.commonObjs,
                    operatorList = _ref14.operatorList,
                    pageIndex = _ref14.pageIndex,
                    canvasFactory = _ref14.canvasFactory,
                    webGLContext = _ref14.webGLContext,
                    _ref14$useRequestAnim = _ref14.useRequestAnimationFrame,
                    useRequestAnimationFrame = _ref14$useRequestAnim === void 0 ? false : _ref14$useRequestAnim,
                    _ref14$pdfBug = _ref14.pdfBug,
                    pdfBug = _ref14$pdfBug === void 0 ? false : _ref14$pdfBug;

                _classCallCheck(this, InternalRenderTask);

                this.callback = callback;
                this.params = params;
                this.objs = objs;
                this.commonObjs = commonObjs;
                this.operatorListIdx = null;
                this.operatorList = operatorList;
                this._pageIndex = pageIndex;
                this.canvasFactory = canvasFactory;
                this.webGLContext = webGLContext;
                this._pdfBug = pdfBug;
                this.running = false;
                this.graphicsReadyCallback = null;
                this.graphicsReady = false;
                this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                this.cancelled = false;
                this.capability = (0, _util.createPromiseCapability)();
                this.task = new RenderTask(this);
                this._continueBound = this._continue.bind(this);
                this._scheduleNextBound = this._scheduleNext.bind(this);
                this._nextBound = this._next.bind(this);
                this._canvas = params.canvasContext.canvas;
              }

              _createClass(InternalRenderTask, [{
                key: "initializeGraphics",
                value: function initializeGraphics() {
                  var transparency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                  if (this.cancelled) {
                    return;
                  }

                  if (this._canvas) {
                    if (canvasInRendering.has(this._canvas)) {
                      throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
                    }

                    canvasInRendering.add(this._canvas);
                  }

                  if (this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled) {
                    this.stepper = globalThis.StepperManager.create(this._pageIndex);
                    this.stepper.init(this.operatorList);
                    this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                  }

                  var _this$params = this.params,
                      canvasContext = _this$params.canvasContext,
                      viewport = _this$params.viewport,
                      transform = _this$params.transform,
                      imageLayer = _this$params.imageLayer,
                      background = _this$params.background;
                  this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer);
                  this.gfx.beginDrawing({
                    transform: transform,
                    viewport: viewport,
                    transparency: transparency,
                    background: background
                  });
                  this.operatorListIdx = 0;
                  this.graphicsReady = true;

                  if (this.graphicsReadyCallback) {
                    this.graphicsReadyCallback();
                  }
                }
              }, {
                key: "cancel",
                value: function cancel() {
                  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                  this.running = false;
                  this.cancelled = true;

                  if (this.gfx) {
                    this.gfx.endDrawing();
                  }

                  if (this._canvas) {
                    canvasInRendering["delete"](this._canvas);
                  }

                  this.callback(error || new _display_utils.RenderingCancelledException("Rendering cancelled, page ".concat(this._pageIndex + 1), "canvas"));
                }
              }, {
                key: "operatorListChanged",
                value: function operatorListChanged() {
                  if (!this.graphicsReady) {
                    if (!this.graphicsReadyCallback) {
                      this.graphicsReadyCallback = this._continueBound;
                    }

                    return;
                  }

                  if (this.stepper) {
                    this.stepper.updateOperatorList(this.operatorList);
                  }

                  if (this.running) {
                    return;
                  }

                  this._continue();
                }
              }, {
                key: "_continue",
                value: function _continue() {
                  this.running = true;

                  if (this.cancelled) {
                    return;
                  }

                  if (this.task.onContinue) {
                    this.task.onContinue(this._scheduleNextBound);
                  } else {
                    this._scheduleNext();
                  }
                }
              }, {
                key: "_scheduleNext",
                value: function _scheduleNext() {
                  var _this30 = this;

                  if (this._useRequestAnimationFrame) {
                    window.requestAnimationFrame(function () {
                      _this30._nextBound()["catch"](_this30.cancel.bind(_this30));
                    });
                  } else {
                    Promise.resolve().then(this._nextBound)["catch"](this.cancel.bind(this));
                  }
                }
              }, {
                key: "_next",
                value: function () {
                  var _next2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!this.cancelled) {
                              _context2.next = 2;
                              break;
                            }

                            return _context2.abrupt("return");

                          case 2:
                            this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);

                            if (this.operatorListIdx === this.operatorList.argsArray.length) {
                              this.running = false;

                              if (this.operatorList.lastChunk) {
                                this.gfx.endDrawing();

                                if (this._canvas) {
                                  canvasInRendering["delete"](this._canvas);
                                }

                                this.callback();
                              }
                            }

                          case 4:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));

                  function _next() {
                    return _next2.apply(this, arguments);
                  }

                  return _next;
                }()
              }]);

              return InternalRenderTask;
            }();

            return InternalRenderTask;
          }();

          var version = '2.4.456';
          exports.version = version;
          var build = '228a591c';
          exports.build = build;
          /***/
        },
        /* 4 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.addLinkAttributes = addLinkAttributes;
          exports.getFilenameFromUrl = getFilenameFromUrl;
          exports.isFetchSupported = isFetchSupported;
          exports.isValidFetchUrl = isValidFetchUrl;
          exports.loadScript = loadScript;
          exports.deprecated = deprecated;
          exports.releaseImageResources = releaseImageResources;
          exports.PDFDateString = exports.StatTimer = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.LinkTarget = exports.RenderingCancelledException = exports.PageViewport = void 0;

          var _util = __w_pdfjs_require__(1);

          var DEFAULT_LINK_REL = "noopener noreferrer nofollow";
          exports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
          var SVG_NS = "http://www.w3.org/2000/svg";

          var DOMCanvasFactory = /*#__PURE__*/function () {
            function DOMCanvasFactory() {
              _classCallCheck(this, DOMCanvasFactory);
            }

            _createClass(DOMCanvasFactory, [{
              key: "create",
              value: function create(width, height) {
                if (width <= 0 || height <= 0) {
                  throw new Error("Invalid canvas size");
                }

                var canvas = document.createElement("canvas");
                var context = canvas.getContext("2d");
                canvas.width = width;
                canvas.height = height;
                return {
                  canvas: canvas,
                  context: context
                };
              }
            }, {
              key: "reset",
              value: function reset(canvasAndContext, width, height) {
                if (!canvasAndContext.canvas) {
                  throw new Error("Canvas is not specified");
                }

                if (width <= 0 || height <= 0) {
                  throw new Error("Invalid canvas size");
                }

                canvasAndContext.canvas.width = width;
                canvasAndContext.canvas.height = height;
              }
            }, {
              key: "destroy",
              value: function destroy(canvasAndContext) {
                if (!canvasAndContext.canvas) {
                  throw new Error("Canvas is not specified");
                }

                canvasAndContext.canvas.width = 0;
                canvasAndContext.canvas.height = 0;
                canvasAndContext.canvas = null;
                canvasAndContext.context = null;
              }
            }]);

            return DOMCanvasFactory;
          }();

          exports.DOMCanvasFactory = DOMCanvasFactory;

          var DOMCMapReaderFactory = /*#__PURE__*/function () {
            function DOMCMapReaderFactory(_ref15) {
              var _ref15$baseUrl = _ref15.baseUrl,
                  baseUrl = _ref15$baseUrl === void 0 ? null : _ref15$baseUrl,
                  _ref15$isCompressed = _ref15.isCompressed,
                  isCompressed = _ref15$isCompressed === void 0 ? false : _ref15$isCompressed;

              _classCallCheck(this, DOMCMapReaderFactory);

              this.baseUrl = baseUrl;
              this.isCompressed = isCompressed;
            }

            _createClass(DOMCMapReaderFactory, [{
              key: "fetch",
              value: function (_fetch) {
                function fetch(_x) {
                  return _fetch.apply(this, arguments);
                }

                fetch.toString = function () {
                  return _fetch.toString();
                };

                return fetch;
              }( /*#__PURE__*/function () {
                var _ref17 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref16) {
                  var _this31 = this;

                  var name, url, compressionType;
                  return regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          name = _ref16.name;

                          if (this.baseUrl) {
                            _context4.next = 3;
                            break;
                          }

                          throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');

                        case 3:
                          if (name) {
                            _context4.next = 5;
                            break;
                          }

                          throw new Error("CMap name must be specified.");

                        case 5:
                          url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                          compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;

                          if (!(isFetchSupported() && isValidFetchUrl(url, document.baseURI))) {
                            _context4.next = 9;
                            break;
                          }

                          return _context4.abrupt("return", fetch(url).then( /*#__PURE__*/function () {
                            var _ref18 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(response) {
                              var cMapData;
                              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                                while (1) {
                                  switch (_context3.prev = _context3.next) {
                                    case 0:
                                      if (response.ok) {
                                        _context3.next = 2;
                                        break;
                                      }

                                      throw new Error(response.statusText);

                                    case 2:
                                      if (!_this31.isCompressed) {
                                        _context3.next = 10;
                                        break;
                                      }

                                      _context3.t0 = Uint8Array;
                                      _context3.next = 6;
                                      return response.arrayBuffer();

                                    case 6:
                                      _context3.t1 = _context3.sent;
                                      cMapData = new _context3.t0(_context3.t1);
                                      _context3.next = 15;
                                      break;

                                    case 10:
                                      _context3.t2 = (0, _util.stringToBytes);
                                      _context3.next = 13;
                                      return response.text();

                                    case 13:
                                      _context3.t3 = _context3.sent;
                                      cMapData = (0, _context3.t2)(_context3.t3);

                                    case 15:
                                      return _context3.abrupt("return", {
                                        cMapData: cMapData,
                                        compressionType: compressionType
                                      });

                                    case 16:
                                    case "end":
                                      return _context3.stop();
                                  }
                                }
                              }, _callee3);
                            }));

                            return function (_x3) {
                              return _ref18.apply(this, arguments);
                            };
                          }())["catch"](function (reason) {
                            throw new Error("Unable to load ".concat(_this31.isCompressed ? "binary " : "") + "CMap at: ".concat(url));
                          }));

                        case 9:
                          return _context4.abrupt("return", new Promise(function (resolve, reject) {
                            var request = new XMLHttpRequest();
                            request.open("GET", url, true);

                            if (_this31.isCompressed) {
                              request.responseType = "arraybuffer";
                            }

                            request.onreadystatechange = function () {
                              if (request.readyState !== XMLHttpRequest.DONE) {
                                return;
                              }

                              if (request.status === 200 || request.status === 0) {
                                var cMapData;

                                if (_this31.isCompressed && request.response) {
                                  cMapData = new Uint8Array(request.response);
                                } else if (!_this31.isCompressed && request.responseText) {
                                  cMapData = (0, _util.stringToBytes)(request.responseText);
                                }

                                if (cMapData) {
                                  resolve({
                                    cMapData: cMapData,
                                    compressionType: compressionType
                                  });
                                  return;
                                }
                              }

                              reject(new Error(request.statusText));
                            };

                            request.send(null);
                          })["catch"](function (reason) {
                            throw new Error("Unable to load ".concat(_this31.isCompressed ? "binary " : "") + "CMap at: ".concat(url));
                          }));

                        case 10:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4, this);
                }));

                return function (_x2) {
                  return _ref17.apply(this, arguments);
                };
              }())
            }]);

            return DOMCMapReaderFactory;
          }();

          exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

          var DOMSVGFactory = /*#__PURE__*/function () {
            function DOMSVGFactory() {
              _classCallCheck(this, DOMSVGFactory);
            }

            _createClass(DOMSVGFactory, [{
              key: "create",
              value: function create(width, height) {
                (0, _util.assert)(width > 0 && height > 0, "Invalid SVG dimensions");
                var svg = document.createElementNS(SVG_NS, "svg:svg");
                svg.setAttribute("version", "1.1");
                svg.setAttribute("width", width + "px");
                svg.setAttribute("height", height + "px");
                svg.setAttribute("preserveAspectRatio", "none");
                svg.setAttribute("viewBox", "0 0 " + width + " " + height);
                return svg;
              }
            }, {
              key: "createElement",
              value: function createElement(type) {
                (0, _util.assert)(typeof type === "string", "Invalid SVG element type");
                return document.createElementNS(SVG_NS, type);
              }
            }]);

            return DOMSVGFactory;
          }();

          exports.DOMSVGFactory = DOMSVGFactory;

          var PageViewport = /*#__PURE__*/function () {
            function PageViewport(_ref19) {
              var viewBox = _ref19.viewBox,
                  scale = _ref19.scale,
                  rotation = _ref19.rotation,
                  _ref19$offsetX = _ref19.offsetX,
                  offsetX = _ref19$offsetX === void 0 ? 0 : _ref19$offsetX,
                  _ref19$offsetY = _ref19.offsetY,
                  offsetY = _ref19$offsetY === void 0 ? 0 : _ref19$offsetY,
                  _ref19$dontFlip = _ref19.dontFlip,
                  dontFlip = _ref19$dontFlip === void 0 ? false : _ref19$dontFlip;

              _classCallCheck(this, PageViewport);

              this.viewBox = viewBox;
              this.scale = scale;
              this.rotation = rotation;
              this.offsetX = offsetX;
              this.offsetY = offsetY;
              var centerX = (viewBox[2] + viewBox[0]) / 2;
              var centerY = (viewBox[3] + viewBox[1]) / 2;
              var rotateA, rotateB, rotateC, rotateD;
              rotation = rotation % 360;
              rotation = rotation < 0 ? rotation + 360 : rotation;

              switch (rotation) {
                case 180:
                  rotateA = -1;
                  rotateB = 0;
                  rotateC = 0;
                  rotateD = 1;
                  break;

                case 90:
                  rotateA = 0;
                  rotateB = 1;
                  rotateC = 1;
                  rotateD = 0;
                  break;

                case 270:
                  rotateA = 0;
                  rotateB = -1;
                  rotateC = -1;
                  rotateD = 0;
                  break;

                default:
                  rotateA = 1;
                  rotateB = 0;
                  rotateC = 0;
                  rotateD = -1;
                  break;
              }

              if (dontFlip) {
                rotateC = -rotateC;
                rotateD = -rotateD;
              }

              var offsetCanvasX, offsetCanvasY;
              var width, height;

              if (rotateA === 0) {
                offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                height = Math.abs(viewBox[2] - viewBox[0]) * scale;
              } else {
                offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                height = Math.abs(viewBox[3] - viewBox[1]) * scale;
              }

              this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
              this.width = width;
              this.height = height;
            }

            _createClass(PageViewport, [{
              key: "clone",
              value: function clone() {
                var _ref20 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                    _ref20$scale = _ref20.scale,
                    scale = _ref20$scale === void 0 ? this.scale : _ref20$scale,
                    _ref20$rotation = _ref20.rotation,
                    rotation = _ref20$rotation === void 0 ? this.rotation : _ref20$rotation,
                    _ref20$offsetX = _ref20.offsetX,
                    offsetX = _ref20$offsetX === void 0 ? this.offsetX : _ref20$offsetX,
                    _ref20$offsetY = _ref20.offsetY,
                    offsetY = _ref20$offsetY === void 0 ? this.offsetY : _ref20$offsetY,
                    _ref20$dontFlip = _ref20.dontFlip,
                    dontFlip = _ref20$dontFlip === void 0 ? false : _ref20$dontFlip;

                return new PageViewport({
                  viewBox: this.viewBox.slice(),
                  scale: scale,
                  rotation: rotation,
                  offsetX: offsetX,
                  offsetY: offsetY,
                  dontFlip: dontFlip
                });
              }
            }, {
              key: "convertToViewportPoint",
              value: function convertToViewportPoint(x, y) {
                return _util.Util.applyTransform([x, y], this.transform);
              }
            }, {
              key: "convertToViewportRectangle",
              value: function convertToViewportRectangle(rect) {
                var topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);

                var bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);

                return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
              }
            }, {
              key: "convertToPdfPoint",
              value: function convertToPdfPoint(x, y) {
                return _util.Util.applyInverseTransform([x, y], this.transform);
              }
            }]);

            return PageViewport;
          }();

          exports.PageViewport = PageViewport;

          var RenderingCancelledException = /*#__PURE__*/function (_util$BaseException) {
            _inherits(RenderingCancelledException, _util$BaseException);

            var _super8 = _createSuper(RenderingCancelledException);

            function RenderingCancelledException(msg, type) {
              var _this32;

              _classCallCheck(this, RenderingCancelledException);

              _this32 = _super8.call(this, msg);
              _this32.type = type;
              return _this32;
            }

            return RenderingCancelledException;
          }(_util.BaseException);

          exports.RenderingCancelledException = RenderingCancelledException;
          var LinkTarget = {
            NONE: 0,
            SELF: 1,
            BLANK: 2,
            PARENT: 3,
            TOP: 4
          };
          exports.LinkTarget = LinkTarget;

          function addLinkAttributes(link) {
            var _ref21 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                url = _ref21.url,
                target = _ref21.target,
                rel = _ref21.rel,
                _ref21$enabled = _ref21.enabled,
                enabled = _ref21$enabled === void 0 ? true : _ref21$enabled;

            (0, _util.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
            var urlNullRemoved = (0, _util.removeNullCharacters)(url);

            if (enabled) {
              link.href = link.title = urlNullRemoved;
            } else {
              link.href = "";
              link.title = "Disabled: ".concat(urlNullRemoved);

              link.onclick = function () {
                return false;
              };
            }

            var targetStr = "";

            switch (target) {
              case LinkTarget.NONE:
                break;

              case LinkTarget.SELF:
                targetStr = "_self";
                break;

              case LinkTarget.BLANK:
                targetStr = "_blank";
                break;

              case LinkTarget.PARENT:
                targetStr = "_parent";
                break;

              case LinkTarget.TOP:
                targetStr = "_top";
                break;
            }

            link.target = targetStr;
            link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
          }

          function getFilenameFromUrl(url) {
            var anchor = url.indexOf("#");
            var query = url.indexOf("?");
            var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
            return url.substring(url.lastIndexOf("/", end) + 1, end);
          }

          var StatTimer = /*#__PURE__*/function () {
            function StatTimer() {
              _classCallCheck(this, StatTimer);

              this.started = Object.create(null);
              this.times = [];
            }

            _createClass(StatTimer, [{
              key: "time",
              value: function time(name) {
                if (name in this.started) {
                  (0, _util.warn)("Timer is already running for ".concat(name));
                }

                this.started[name] = Date.now();
              }
            }, {
              key: "timeEnd",
              value: function timeEnd(name) {
                if (!(name in this.started)) {
                  (0, _util.warn)("Timer has not been started for ".concat(name));
                }

                this.times.push({
                  name: name,
                  start: this.started[name],
                  end: Date.now()
                });
                delete this.started[name];
              }
            }, {
              key: "toString",
              value: function toString() {
                var outBuf = [];
                var longest = 0;

                var _iterator6 = _createForOfIteratorHelper(this.times),
                    _step6;

                try {
                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                    var time = _step6.value;
                    var name = time.name;

                    if (name.length > longest) {
                      longest = name.length;
                    }
                  }
                } catch (err) {
                  _iterator6.e(err);
                } finally {
                  _iterator6.f();
                }

                var _iterator7 = _createForOfIteratorHelper(this.times),
                    _step7;

                try {
                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                    var _time = _step7.value;
                    var duration = _time.end - _time.start;
                    outBuf.push("".concat(_time.name.padEnd(longest), " ").concat(duration, "ms\n"));
                  }
                } catch (err) {
                  _iterator7.e(err);
                } finally {
                  _iterator7.f();
                }

                return outBuf.join("");
              }
            }]);

            return StatTimer;
          }();

          exports.StatTimer = StatTimer;

          function isFetchSupported() {
            return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined";
          }

          function isValidFetchUrl(url, baseUrl) {
            try {
              var _ref22 = baseUrl ? new URL(url, baseUrl) : new URL(url),
                  protocol = _ref22.protocol;

              return protocol === "http:" || protocol === "https:";
            } catch (ex) {
              return false;
            }
          }

          function loadScript(src) {
            return new Promise(function (resolve, reject) {
              var script = document.createElement("script");
              script.src = src;
              script.onload = resolve;

              script.onerror = function () {
                reject(new Error("Cannot load script at: ".concat(script.src)));
              };

              (document.head || document.documentElement).appendChild(script);
            });
          }

          function deprecated(details) {
            console.log("Deprecated API usage: " + details);
          }

          function releaseImageResources(img) {
            (0, _util.assert)(img instanceof Image, "Invalid `img` parameter.");
            var url = img.src;

            if (typeof url === "string" && url.startsWith("blob:") && URL.revokeObjectURL) {
              URL.revokeObjectURL(url);
            }

            img.removeAttribute("src");
          }

          var pdfDateStringRegex;

          var PDFDateString = /*#__PURE__*/function () {
            function PDFDateString() {
              _classCallCheck(this, PDFDateString);
            }

            _createClass(PDFDateString, null, [{
              key: "toDateObject",
              value: function toDateObject(input) {
                if (!input || !(0, _util.isString)(input)) {
                  return null;
                }

                if (!pdfDateStringRegex) {
                  pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
                }

                var matches = pdfDateStringRegex.exec(input);

                if (!matches) {
                  return null;
                }

                var year = parseInt(matches[1], 10);
                var month = parseInt(matches[2], 10);
                month = month >= 1 && month <= 12 ? month - 1 : 0;
                var day = parseInt(matches[3], 10);
                day = day >= 1 && day <= 31 ? day : 1;
                var hour = parseInt(matches[4], 10);
                hour = hour >= 0 && hour <= 23 ? hour : 0;
                var minute = parseInt(matches[5], 10);
                minute = minute >= 0 && minute <= 59 ? minute : 0;
                var second = parseInt(matches[6], 10);
                second = second >= 0 && second <= 59 ? second : 0;
                var universalTimeRelation = matches[7] || "Z";
                var offsetHour = parseInt(matches[8], 10);
                offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                var offsetMinute = parseInt(matches[9], 10) || 0;
                offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

                if (universalTimeRelation === "-") {
                  hour += offsetHour;
                  minute += offsetMinute;
                } else if (universalTimeRelation === "+") {
                  hour -= offsetHour;
                  minute -= offsetMinute;
                }

                return new Date(Date.UTC(year, month, day, hour, minute, second));
              }
            }]);

            return PDFDateString;
          }();

          exports.PDFDateString = PDFDateString;
          /***/
        },
        /* 5 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.FontLoader = exports.FontFaceObject = void 0;

          var _util = __w_pdfjs_require__(1);

          var BaseFontLoader = /*#__PURE__*/function () {
            function BaseFontLoader(_ref23) {
              var docId = _ref23.docId,
                  onUnsupportedFeature = _ref23.onUnsupportedFeature;

              _classCallCheck(this, BaseFontLoader);

              if (this.constructor === BaseFontLoader) {
                (0, _util.unreachable)("Cannot initialize BaseFontLoader.");
              }

              this.docId = docId;
              this._onUnsupportedFeature = onUnsupportedFeature;
              this.nativeFontFaces = [];
              this.styleElement = null;
            }

            _createClass(BaseFontLoader, [{
              key: "addNativeFontFace",
              value: function addNativeFontFace(nativeFontFace) {
                this.nativeFontFaces.push(nativeFontFace);
                document.fonts.add(nativeFontFace);
              }
            }, {
              key: "insertRule",
              value: function insertRule(rule) {
                var styleElement = this.styleElement;

                if (!styleElement) {
                  styleElement = this.styleElement = document.createElement("style");
                  styleElement.id = "PDFJS_FONT_STYLE_TAG_".concat(this.docId);
                  document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
                }

                var styleSheet = styleElement.sheet;
                styleSheet.insertRule(rule, styleSheet.cssRules.length);
              }
            }, {
              key: "clear",
              value: function clear() {
                this.nativeFontFaces.forEach(function (nativeFontFace) {
                  document.fonts["delete"](nativeFontFace);
                });
                this.nativeFontFaces.length = 0;

                if (this.styleElement) {
                  this.styleElement.remove();
                  this.styleElement = null;
                }
              }
            }, {
              key: "bind",
              value: function () {
                var _bind = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(font) {
                  var _this33 = this;

                  var nativeFontFace, rule;
                  return regeneratorRuntime.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          if (!(font.attached || font.missingFile)) {
                            _context5.next = 2;
                            break;
                          }

                          return _context5.abrupt("return");

                        case 2:
                          font.attached = true;

                          if (!this.isFontLoadingAPISupported) {
                            _context5.next = 19;
                            break;
                          }

                          nativeFontFace = font.createNativeFontFace();

                          if (!nativeFontFace) {
                            _context5.next = 18;
                            break;
                          }

                          this.addNativeFontFace(nativeFontFace);
                          _context5.prev = 7;
                          _context5.next = 10;
                          return nativeFontFace.loaded;

                        case 10:
                          _context5.next = 18;
                          break;

                        case 12:
                          _context5.prev = 12;
                          _context5.t0 = _context5["catch"](7);

                          this._onUnsupportedFeature({
                            featureId: _util.UNSUPPORTED_FEATURES.font
                          });

                          (0, _util.warn)("Failed to load font '".concat(nativeFontFace.family, "': '").concat(_context5.t0, "'."));
                          font.disableFontFace = true;
                          throw _context5.t0;

                        case 18:
                          return _context5.abrupt("return");

                        case 19:
                          rule = font.createFontFaceRule();

                          if (!rule) {
                            _context5.next = 26;
                            break;
                          }

                          this.insertRule(rule);

                          if (!this.isSyncFontLoadingSupported) {
                            _context5.next = 24;
                            break;
                          }

                          return _context5.abrupt("return");

                        case 24:
                          _context5.next = 26;
                          return new Promise(function (resolve) {
                            var request = _this33._queueLoadingCallback(resolve);

                            _this33._prepareFontLoadEvent([rule], [font], request);
                          });

                        case 26:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5, this, [[7, 12]]);
                }));

                function bind(_x4) {
                  return _bind.apply(this, arguments);
                }

                return bind;
              }()
            }, {
              key: "_queueLoadingCallback",
              value: function _queueLoadingCallback(callback) {
                (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");
              }
            }, {
              key: "_prepareFontLoadEvent",
              value: function _prepareFontLoadEvent(rules, fontsToLoad, request) {
                (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");
              }
            }, {
              key: "isFontLoadingAPISupported",
              get: function get() {
                var supported = typeof document !== "undefined" && !!document.fonts;
                return (0, _util.shadow)(this, "isFontLoadingAPISupported", supported);
              }
            }, {
              key: "isSyncFontLoadingSupported",
              get: function get() {
                (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
              }
            }, {
              key: "_loadTestFont",
              get: function get() {
                (0, _util.unreachable)("Abstract method `_loadTestFont`.");
              }
            }]);

            return BaseFontLoader;
          }();

          var FontLoader;
          exports.FontLoader = FontLoader;
          {
            exports.FontLoader = FontLoader = /*#__PURE__*/function (_BaseFontLoader) {
              _inherits(GenericFontLoader, _BaseFontLoader);

              var _super9 = _createSuper(GenericFontLoader);

              function GenericFontLoader(docId) {
                var _this34;

                _classCallCheck(this, GenericFontLoader);

                _this34 = _super9.call(this, docId);
                _this34.loadingContext = {
                  requests: [],
                  nextRequestId: 0
                };
                _this34.loadTestFontId = 0;
                return _this34;
              }

              _createClass(GenericFontLoader, [{
                key: "_queueLoadingCallback",
                value: function _queueLoadingCallback(callback) {
                  function completeRequest() {
                    (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
                    request.done = true;

                    while (context.requests.length > 0 && context.requests[0].done) {
                      var otherRequest = context.requests.shift();
                      setTimeout(otherRequest.callback, 0);
                    }
                  }

                  var context = this.loadingContext;
                  var request = {
                    id: "pdfjs-font-loading-".concat(context.nextRequestId++),
                    done: false,
                    complete: completeRequest,
                    callback: callback
                  };
                  context.requests.push(request);
                  return request;
                }
              }, {
                key: "_prepareFontLoadEvent",
                value: function _prepareFontLoadEvent(rules, fonts, request) {
                  function int32(data, offset) {
                    return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
                  }

                  function spliceString(s, offset, remove, insert) {
                    var chunk1 = s.substring(0, offset);
                    var chunk2 = s.substring(offset + remove);
                    return chunk1 + insert + chunk2;
                  }

                  var i, ii;
                  var canvas = document.createElement("canvas");
                  canvas.width = 1;
                  canvas.height = 1;
                  var ctx = canvas.getContext("2d");
                  var called = 0;

                  function isFontReady(name, callback) {
                    called++;

                    if (called > 30) {
                      (0, _util.warn)("Load test font never loaded.");
                      callback();
                      return;
                    }

                    ctx.font = "30px " + name;
                    ctx.fillText(".", 0, 20);
                    var imageData = ctx.getImageData(0, 0, 1, 1);

                    if (imageData.data[3] > 0) {
                      callback();
                      return;
                    }

                    setTimeout(isFontReady.bind(null, name, callback));
                  }

                  var loadTestFontId = "lt".concat(Date.now()).concat(this.loadTestFontId++);
                  var data = this._loadTestFont;
                  var COMMENT_OFFSET = 976;
                  data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                  var CFF_CHECKSUM_OFFSET = 16;
                  var XXXX_VALUE = 0x58585858;
                  var checksum = int32(data, CFF_CHECKSUM_OFFSET);

                  for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                  }

                  if (i < loadTestFontId.length) {
                    checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                  }

                  data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
                  var url = "url(data:font/opentype;base64,".concat(btoa(data), ");");
                  var rule = "@font-face {font-family:\"".concat(loadTestFontId, "\";src:").concat(url, "}");
                  this.insertRule(rule);
                  var names = [];

                  for (i = 0, ii = fonts.length; i < ii; i++) {
                    names.push(fonts[i].loadedName);
                  }

                  names.push(loadTestFontId);
                  var div = document.createElement("div");
                  div.style.visibility = "hidden";
                  div.style.width = div.style.height = "10px";
                  div.style.position = "absolute";
                  div.style.top = div.style.left = "0px";

                  for (i = 0, ii = names.length; i < ii; ++i) {
                    var span = document.createElement("span");
                    span.textContent = "Hi";
                    span.style.fontFamily = names[i];
                    div.appendChild(span);
                  }

                  document.body.appendChild(div);
                  isFontReady(loadTestFontId, function () {
                    document.body.removeChild(div);
                    request.complete();
                  });
                }
              }, {
                key: "isSyncFontLoadingSupported",
                get: function get() {
                  var supported = false;

                  if (typeof navigator === "undefined") {
                    supported = true;
                  } else {
                    var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

                    if (m && m[1] >= 14) {
                      supported = true;
                    }
                  }

                  return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
                }
              }, {
                key: "_loadTestFont",
                get: function get() {
                  var getLoadTestFont = function getLoadTestFont() {
                    return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                  };

                  return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());
                }
              }]);

              return GenericFontLoader;
            }(BaseFontLoader);
          }

          var FontFaceObject = /*#__PURE__*/function () {
            function FontFaceObject(translatedData, _ref24) {
              var _ref24$isEvalSupporte = _ref24.isEvalSupported,
                  isEvalSupported = _ref24$isEvalSupporte === void 0 ? true : _ref24$isEvalSupporte,
                  _ref24$disableFontFac = _ref24.disableFontFace,
                  disableFontFace = _ref24$disableFontFac === void 0 ? false : _ref24$disableFontFac,
                  _ref24$ignoreErrors = _ref24.ignoreErrors,
                  ignoreErrors = _ref24$ignoreErrors === void 0 ? false : _ref24$ignoreErrors,
                  _ref24$onUnsupportedF = _ref24.onUnsupportedFeature,
                  onUnsupportedFeature = _ref24$onUnsupportedF === void 0 ? null : _ref24$onUnsupportedF,
                  _ref24$fontRegistry = _ref24.fontRegistry,
                  fontRegistry = _ref24$fontRegistry === void 0 ? null : _ref24$fontRegistry;

              _classCallCheck(this, FontFaceObject);

              this.compiledGlyphs = Object.create(null);

              for (var i in translatedData) {
                this[i] = translatedData[i];
              }

              this.isEvalSupported = isEvalSupported !== false;
              this.disableFontFace = disableFontFace === true;
              this.ignoreErrors = ignoreErrors === true;
              this._onUnsupportedFeature = onUnsupportedFeature;
              this.fontRegistry = fontRegistry;
            }

            _createClass(FontFaceObject, [{
              key: "createNativeFontFace",
              value: function createNativeFontFace() {
                if (!this.data || this.disableFontFace) {
                  return null;
                }

                var nativeFontFace = new FontFace(this.loadedName, this.data, {});

                if (this.fontRegistry) {
                  this.fontRegistry.registerFont(this);
                }

                return nativeFontFace;
              }
            }, {
              key: "createFontFaceRule",
              value: function createFontFaceRule() {
                if (!this.data || this.disableFontFace) {
                  return null;
                }

                var data = (0, _util.bytesToString)(new Uint8Array(this.data));
                var url = "url(data:".concat(this.mimetype, ";base64,").concat(btoa(data), ");");
                var rule = "@font-face {font-family:\"".concat(this.loadedName, "\";src:").concat(url, "}");

                if (this.fontRegistry) {
                  this.fontRegistry.registerFont(this, url);
                }

                return rule;
              }
            }, {
              key: "getPathGenerator",
              value: function getPathGenerator(objs, character) {
                if (this.compiledGlyphs[character] !== undefined) {
                  return this.compiledGlyphs[character];
                }

                var cmds, current;

                try {
                  cmds = objs.get(this.loadedName + "_path_" + character);
                } catch (ex) {
                  if (!this.ignoreErrors) {
                    throw ex;
                  }

                  if (this._onUnsupportedFeature) {
                    this._onUnsupportedFeature({
                      featureId: _util.UNSUPPORTED_FEATURES.font
                    });
                  }

                  (0, _util.warn)("getPathGenerator - ignoring character: \"".concat(ex, "\"."));
                  return this.compiledGlyphs[character] = function (c, size) {};
                }

                if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {
                  var args,
                      js = "";

                  for (var i = 0, ii = cmds.length; i < ii; i++) {
                    current = cmds[i];

                    if (current.args !== undefined) {
                      args = current.args.join(",");
                    } else {
                      args = "";
                    }

                    js += "c." + current.cmd + "(" + args + ");\n";
                  }

                  return this.compiledGlyphs[character] = new Function("c", "size", js);
                }

                return this.compiledGlyphs[character] = function (c, size) {
                  for (var _i6 = 0, _ii = cmds.length; _i6 < _ii; _i6++) {
                    current = cmds[_i6];

                    if (current.cmd === "scale") {
                      current.args = [size, -size];
                    }

                    c[current.cmd].apply(c, current.args);
                  }
                };
              }
            }]);

            return FontFaceObject;
          }();

          exports.FontFaceObject = FontFaceObject;
          /***/
        },
        /* 6 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          var compatibilityParams = Object.create(null);
          {
            var _w_pdfjs_require__2 = __w_pdfjs_require__(7),
                isNodeJS = _w_pdfjs_require__2.isNodeJS;

            var userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
            var isIE = /Trident/.test(userAgent);
            var isIOSChrome = /CriOS/.test(userAgent);

            (function checkOnBlobSupport() {
              if (isIE || isIOSChrome) {
                compatibilityParams.disableCreateObjectURL = true;
              }
            })();

            (function checkFontFaceAndImage() {
              if (isNodeJS) {
                compatibilityParams.disableFontFace = true;
                compatibilityParams.nativeImageDecoderSupport = "none";
              }
            })();
          }
          exports.apiCompatibilityParams = Object.freeze(compatibilityParams);
          /***/
        },
        /* 7 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.isNodeJS = void 0;
          var isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions["nw"] && !process.versions["electron"];
          exports.isNodeJS = isNodeJS;
          /***/
        },
        /* 8 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CanvasGraphics = void 0;

          var _util = __w_pdfjs_require__(1);

          var _pattern_helper = __w_pdfjs_require__(9);

          var MIN_FONT_SIZE = 16;
          var MAX_FONT_SIZE = 100;
          var MAX_GROUP_SIZE = 4096;
          var MIN_WIDTH_FACTOR = 0.65;
          var COMPILE_TYPE3_GLYPHS = true;
          var MAX_SIZE_TO_COMPILE = 1000;
          var FULL_CHUNK_HEIGHT = 16;

          function addContextCurrentTransform(ctx) {
            if (!ctx.mozCurrentTransform) {
              ctx._originalSave = ctx.save;
              ctx._originalRestore = ctx.restore;
              ctx._originalRotate = ctx.rotate;
              ctx._originalScale = ctx.scale;
              ctx._originalTranslate = ctx.translate;
              ctx._originalTransform = ctx.transform;
              ctx._originalSetTransform = ctx.setTransform;
              ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
              ctx._transformStack = [];
              Object.defineProperty(ctx, "mozCurrentTransform", {
                get: function getCurrentTransform() {
                  return this._transformMatrix;
                }
              });
              Object.defineProperty(ctx, "mozCurrentTransformInverse", {
                get: function getCurrentTransformInverse() {
                  var m = this._transformMatrix;
                  var a = m[0],
                      b = m[1],
                      c = m[2],
                      d = m[3],
                      e = m[4],
                      f = m[5];
                  var ad_bc = a * d - b * c;
                  var bc_ad = b * c - a * d;
                  return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
                }
              });

              ctx.save = function ctxSave() {
                var old = this._transformMatrix;

                this._transformStack.push(old);

                this._transformMatrix = old.slice(0, 6);

                this._originalSave();
              };

              ctx.restore = function ctxRestore() {
                var prev = this._transformStack.pop();

                if (prev) {
                  this._transformMatrix = prev;

                  this._originalRestore();
                }
              };

              ctx.translate = function ctxTranslate(x, y) {
                var m = this._transformMatrix;
                m[4] = m[0] * x + m[2] * y + m[4];
                m[5] = m[1] * x + m[3] * y + m[5];

                this._originalTranslate(x, y);
              };

              ctx.scale = function ctxScale(x, y) {
                var m = this._transformMatrix;
                m[0] = m[0] * x;
                m[1] = m[1] * x;
                m[2] = m[2] * y;
                m[3] = m[3] * y;

                this._originalScale(x, y);
              };

              ctx.transform = function ctxTransform(a, b, c, d, e, f) {
                var m = this._transformMatrix;
                this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];

                ctx._originalTransform(a, b, c, d, e, f);
              };

              ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
                this._transformMatrix = [a, b, c, d, e, f];

                ctx._originalSetTransform(a, b, c, d, e, f);
              };

              ctx.rotate = function ctxRotate(angle) {
                var cosValue = Math.cos(angle);
                var sinValue = Math.sin(angle);
                var m = this._transformMatrix;
                this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];

                this._originalRotate(angle);
              };
            }
          }

          var CachedCanvases = function CachedCanvasesClosure() {
            function CachedCanvases(canvasFactory) {
              this.canvasFactory = canvasFactory;
              this.cache = Object.create(null);
            }

            CachedCanvases.prototype = {
              getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {
                var canvasEntry;

                if (this.cache[id] !== undefined) {
                  canvasEntry = this.cache[id];
                  this.canvasFactory.reset(canvasEntry, width, height);
                  canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
                } else {
                  canvasEntry = this.canvasFactory.create(width, height);
                  this.cache[id] = canvasEntry;
                }

                if (trackTransform) {
                  addContextCurrentTransform(canvasEntry.context);
                }

                return canvasEntry;
              },
              clear: function clear() {
                for (var id in this.cache) {
                  var canvasEntry = this.cache[id];
                  this.canvasFactory.destroy(canvasEntry);
                  delete this.cache[id];
                }
              }
            };
            return CachedCanvases;
          }();

          function compileType3Glyph(imgData) {
            var POINT_TO_PROCESS_LIMIT = 1000;
            var width = imgData.width,
                height = imgData.height;
            var i,
                j,
                j0,
                width1 = width + 1;
            var points = new Uint8Array(width1 * (height + 1));
            var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
            var lineSize = width + 7 & ~7,
                data0 = imgData.data;
            var data = new Uint8Array(lineSize * height),
                pos = 0,
                ii;

            for (i = 0, ii = data0.length; i < ii; i++) {
              var mask = 128,
                  elem = data0[i];

              while (mask > 0) {
                data[pos++] = elem & mask ? 0 : 255;
                mask >>= 1;
              }
            }

            var count = 0;
            pos = 0;

            if (data[pos] !== 0) {
              points[0] = 1;
              ++count;
            }

            for (j = 1; j < width; j++) {
              if (data[pos] !== data[pos + 1]) {
                points[j] = data[pos] ? 2 : 1;
                ++count;
              }

              pos++;
            }

            if (data[pos] !== 0) {
              points[j] = 2;
              ++count;
            }

            for (i = 1; i < height; i++) {
              pos = i * lineSize;
              j0 = i * width1;

              if (data[pos - lineSize] !== data[pos]) {
                points[j0] = data[pos] ? 1 : 8;
                ++count;
              }

              var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);

              for (j = 1; j < width; j++) {
                sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);

                if (POINT_TYPES[sum]) {
                  points[j0 + j] = POINT_TYPES[sum];
                  ++count;
                }

                pos++;
              }

              if (data[pos - lineSize] !== data[pos]) {
                points[j0 + j] = data[pos] ? 2 : 4;
                ++count;
              }

              if (count > POINT_TO_PROCESS_LIMIT) {
                return null;
              }
            }

            pos = lineSize * (height - 1);
            j0 = i * width1;

            if (data[pos] !== 0) {
              points[j0] = 8;
              ++count;
            }

            for (j = 1; j < width; j++) {
              if (data[pos] !== data[pos + 1]) {
                points[j0 + j] = data[pos] ? 4 : 8;
                ++count;
              }

              pos++;
            }

            if (data[pos] !== 0) {
              points[j0 + j] = 4;
              ++count;
            }

            if (count > POINT_TO_PROCESS_LIMIT) {
              return null;
            }

            var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
            var outlines = [];

            for (i = 0; count && i <= height; i++) {
              var p = i * width1;
              var end = p + width;

              while (p < end && !points[p]) {
                p++;
              }

              if (p === end) {
                continue;
              }

              var coords = [p % width1, i];
              var type = points[p],
                  p0 = p,
                  pp;

              do {
                var step = steps[type];

                do {
                  p += step;
                } while (!points[p]);

                pp = points[p];

                if (pp !== 5 && pp !== 10) {
                  type = pp;
                  points[p] = 0;
                } else {
                  type = pp & 0x33 * type >> 4;
                  points[p] &= type >> 2 | type << 2;
                }

                coords.push(p % width1);
                coords.push(p / width1 | 0);

                if (!points[p]) {
                  --count;
                }
              } while (p0 !== p);

              outlines.push(coords);
              --i;
            }

            var drawOutline = function drawOutline(c) {
              c.save();
              c.scale(1 / width, -1 / height);
              c.translate(0, -height);
              c.beginPath();

              for (var i = 0, ii = outlines.length; i < ii; i++) {
                var o = outlines[i];
                c.moveTo(o[0], o[1]);

                for (var j = 2, jj = o.length; j < jj; j += 2) {
                  c.lineTo(o[j], o[j + 1]);
                }
              }

              c.fill();
              c.beginPath();
              c.restore();
            };

            return drawOutline;
          }

          var CanvasExtraState = function CanvasExtraStateClosure() {
            function CanvasExtraState() {
              this.alphaIsShape = false;
              this.fontSize = 0;
              this.fontSizeScale = 1;
              this.textMatrix = _util.IDENTITY_MATRIX;
              this.textMatrixScale = 1;
              this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
              this.leading = 0;
              this.x = 0;
              this.y = 0;
              this.lineX = 0;
              this.lineY = 0;
              this.charSpacing = 0;
              this.wordSpacing = 0;
              this.textHScale = 1;
              this.textRenderingMode = _util.TextRenderingMode.FILL;
              this.textRise = 0;
              this.fillColor = "#000000";
              this.strokeColor = "#000000";
              this.patternFill = false;
              this.fillAlpha = 1;
              this.strokeAlpha = 1;
              this.lineWidth = 1;
              this.activeSMask = null;
              this.resumeSMaskCtx = null;
            }

            CanvasExtraState.prototype = {
              clone: function CanvasExtraState_clone() {
                return Object.create(this);
              },
              setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {
                this.x = x;
                this.y = y;
              }
            };
            return CanvasExtraState;
          }();

          var CanvasGraphics = function CanvasGraphicsClosure() {
            var EXECUTION_TIME = 15;
            var EXECUTION_STEPS = 10;

            function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer) {
              this.ctx = canvasCtx;
              this.current = new CanvasExtraState();
              this.stateStack = [];
              this.pendingClip = null;
              this.pendingEOFill = false;
              this.res = null;
              this.xobjs = null;
              this.commonObjs = commonObjs;
              this.objs = objs;
              this.canvasFactory = canvasFactory;
              this.webGLContext = webGLContext;
              this.imageLayer = imageLayer;
              this.groupStack = [];
              this.processingType3 = null;
              this.baseTransform = null;
              this.baseTransformStack = [];
              this.groupLevel = 0;
              this.smaskStack = [];
              this.smaskCounter = 0;
              this.tempSMask = null;
              this.cachedCanvases = new CachedCanvases(this.canvasFactory);

              if (canvasCtx) {
                addContextCurrentTransform(canvasCtx);
              }

              this._cachedGetSinglePixelWidth = null;
            }

            function putBinaryImageData(ctx, imgData) {
              if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                ctx.putImageData(imgData, 0, 0);
                return;
              }

              var height = imgData.height,
                  width = imgData.width;
              var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
              var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
              var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
              var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
              var srcPos = 0,
                  destPos;
              var src = imgData.data;
              var dest = chunkImgData.data;
              var i, j, thisChunkHeight, elemsInThisChunk;

              if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
                var srcLength = src.byteLength;
                var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                var dest32DataLength = dest32.length;
                var fullSrcDiff = width + 7 >> 3;
                var white = 0xffffffff;
                var black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;

                for (i = 0; i < totalChunks; i++) {
                  thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  destPos = 0;

                  for (j = 0; j < thisChunkHeight; j++) {
                    var srcDiff = srcLength - srcPos;
                    var k = 0;
                    var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                    var kEndUnrolled = kEnd & ~7;
                    var mask = 0;
                    var srcByte = 0;

                    for (; k < kEndUnrolled; k += 8) {
                      srcByte = src[srcPos++];
                      dest32[destPos++] = srcByte & 128 ? white : black;
                      dest32[destPos++] = srcByte & 64 ? white : black;
                      dest32[destPos++] = srcByte & 32 ? white : black;
                      dest32[destPos++] = srcByte & 16 ? white : black;
                      dest32[destPos++] = srcByte & 8 ? white : black;
                      dest32[destPos++] = srcByte & 4 ? white : black;
                      dest32[destPos++] = srcByte & 2 ? white : black;
                      dest32[destPos++] = srcByte & 1 ? white : black;
                    }

                    for (; k < kEnd; k++) {
                      if (mask === 0) {
                        srcByte = src[srcPos++];
                        mask = 128;
                      }

                      dest32[destPos++] = srcByte & mask ? white : black;
                      mask >>= 1;
                    }
                  }

                  while (destPos < dest32DataLength) {
                    dest32[destPos++] = 0;
                  }

                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
                j = 0;
                elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;

                for (i = 0; i < fullChunks; i++) {
                  dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                  srcPos += elemsInThisChunk;
                  ctx.putImageData(chunkImgData, 0, j);
                  j += FULL_CHUNK_HEIGHT;
                }

                if (i < totalChunks) {
                  elemsInThisChunk = width * partialChunkHeight * 4;
                  dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
                  ctx.putImageData(chunkImgData, 0, j);
                }
              } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
                thisChunkHeight = FULL_CHUNK_HEIGHT;
                elemsInThisChunk = width * thisChunkHeight;

                for (i = 0; i < totalChunks; i++) {
                  if (i >= fullChunks) {
                    thisChunkHeight = partialChunkHeight;
                    elemsInThisChunk = width * thisChunkHeight;
                  }

                  destPos = 0;

                  for (j = elemsInThisChunk; j--;) {
                    dest[destPos++] = src[srcPos++];
                    dest[destPos++] = src[srcPos++];
                    dest[destPos++] = src[srcPos++];
                    dest[destPos++] = 255;
                  }

                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              } else {
                throw new Error("bad image kind: ".concat(imgData.kind));
              }
            }

            function putBinaryImageMask(ctx, imgData) {
              var height = imgData.height,
                  width = imgData.width;
              var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
              var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
              var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
              var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
              var srcPos = 0;
              var src = imgData.data;
              var dest = chunkImgData.data;

              for (var i = 0; i < totalChunks; i++) {
                var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                var destPos = 3;

                for (var j = 0; j < thisChunkHeight; j++) {
                  var mask = 0;

                  for (var k = 0; k < width; k++) {
                    if (!mask) {
                      var elem = src[srcPos++];
                      mask = 128;
                    }

                    dest[destPos] = elem & mask ? 0 : 255;
                    destPos += 4;
                    mask >>= 1;
                  }
                }

                ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
              }
            }

            function copyCtxState(sourceCtx, destCtx) {
              var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];

              for (var i = 0, ii = properties.length; i < ii; i++) {
                var property = properties[i];

                if (sourceCtx[property] !== undefined) {
                  destCtx[property] = sourceCtx[property];
                }
              }

              if (sourceCtx.setLineDash !== undefined) {
                destCtx.setLineDash(sourceCtx.getLineDash());
                destCtx.lineDashOffset = sourceCtx.lineDashOffset;
              }
            }

            function resetCtxToDefault(ctx) {
              ctx.strokeStyle = "#000000";
              ctx.fillStyle = "#000000";
              ctx.fillRule = "nonzero";
              ctx.globalAlpha = 1;
              ctx.lineWidth = 1;
              ctx.lineCap = "butt";
              ctx.lineJoin = "miter";
              ctx.miterLimit = 10;
              ctx.globalCompositeOperation = "source-over";
              ctx.font = "10px sans-serif";

              if (ctx.setLineDash !== undefined) {
                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;
              }
            }

            function composeSMaskBackdrop(bytes, r0, g0, b0) {
              var length = bytes.length;

              for (var i = 3; i < length; i += 4) {
                var alpha = bytes[i];

                if (alpha === 0) {
                  bytes[i - 3] = r0;
                  bytes[i - 2] = g0;
                  bytes[i - 1] = b0;
                } else if (alpha < 255) {
                  var alpha_ = 255 - alpha;
                  bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                  bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                  bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                }
              }
            }

            function composeSMaskAlpha(maskData, layerData, transferMap) {
              var length = maskData.length;
              var scale = 1 / 255;

              for (var i = 3; i < length; i += 4) {
                var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                layerData[i] = layerData[i] * alpha * scale | 0;
              }
            }

            function composeSMaskLuminosity(maskData, layerData, transferMap) {
              var length = maskData.length;

              for (var i = 3; i < length; i += 4) {
                var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
              }
            }

            function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
              var hasBackdrop = !!backdrop;
              var r0 = hasBackdrop ? backdrop[0] : 0;
              var g0 = hasBackdrop ? backdrop[1] : 0;
              var b0 = hasBackdrop ? backdrop[2] : 0;
              var composeFn;

              if (subtype === "Luminosity") {
                composeFn = composeSMaskLuminosity;
              } else {
                composeFn = composeSMaskAlpha;
              }

              var PIXELS_TO_PROCESS = 1048576;
              var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));

              for (var row = 0; row < height; row += chunkSize) {
                var chunkHeight = Math.min(chunkSize, height - row);
                var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
                var layerData = layerCtx.getImageData(0, row, width, chunkHeight);

                if (hasBackdrop) {
                  composeSMaskBackdrop(maskData.data, r0, g0, b0);
                }

                composeFn(maskData.data, layerData.data, transferMap);
                maskCtx.putImageData(layerData, 0, row);
              }
            }

            function composeSMask(ctx, smask, layerCtx, webGLContext) {
              var mask = smask.canvas;
              var maskCtx = smask.context;
              ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
              var backdrop = smask.backdrop || null;

              if (!smask.transferMap && webGLContext.isEnabled) {
                var composed = webGLContext.composeSMask({
                  layer: layerCtx.canvas,
                  mask: mask,
                  properties: {
                    subtype: smask.subtype,
                    backdrop: backdrop
                  }
                });
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.drawImage(composed, smask.offsetX, smask.offsetY);
                return;
              }

              genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);
              ctx.drawImage(mask, 0, 0);
            }

            var LINE_CAP_STYLES = ["butt", "round", "square"];
            var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
            var NORMAL_CLIP = {};
            var EO_CLIP = {};
            CanvasGraphics.prototype = {
              beginDrawing: function beginDrawing(_ref25) {
                var transform = _ref25.transform,
                    viewport = _ref25.viewport,
                    _ref25$transparency = _ref25.transparency,
                    transparency = _ref25$transparency === void 0 ? false : _ref25$transparency,
                    _ref25$background = _ref25.background,
                    background = _ref25$background === void 0 ? null : _ref25$background;
                var width = this.ctx.canvas.width;
                var height = this.ctx.canvas.height;
                this.ctx.save();
                this.ctx.fillStyle = background || "rgb(255, 255, 255)";
                this.ctx.fillRect(0, 0, width, height);
                this.ctx.restore();

                if (transparency) {
                  var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
                  this.compositeCtx = this.ctx;
                  this.transparentCanvas = transparentCanvas.canvas;
                  this.ctx = transparentCanvas.context;
                  this.ctx.save();
                  this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
                }

                this.ctx.save();
                resetCtxToDefault(this.ctx);

                if (transform) {
                  this.ctx.transform.apply(this.ctx, transform);
                }

                this.ctx.transform.apply(this.ctx, viewport.transform);
                this.baseTransform = this.ctx.mozCurrentTransform.slice();

                if (this.imageLayer) {
                  this.imageLayer.beginLayout();
                }
              },
              executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                var argsArray = operatorList.argsArray;
                var fnArray = operatorList.fnArray;
                var i = executionStartIdx || 0;
                var argsArrayLen = argsArray.length;

                if (argsArrayLen === i) {
                  return i;
                }

                var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                var steps = 0;
                var commonObjs = this.commonObjs;
                var objs = this.objs;
                var fnId;

                while (true) {
                  if (stepper !== undefined && i === stepper.nextBreakPoint) {
                    stepper.breakIt(i, continueCallback);
                    return i;
                  }

                  fnId = fnArray[i];

                  if (fnId !== _util.OPS.dependency) {
                    this[fnId].apply(this, argsArray[i]);
                  } else {
                    var _iterator8 = _createForOfIteratorHelper(argsArray[i]),
                        _step8;

                    try {
                      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                        var depObjId = _step8.value;
                        var objsPool = depObjId.startsWith("g_") ? commonObjs : objs;

                        if (!objsPool.has(depObjId)) {
                          objsPool.get(depObjId, continueCallback);
                          return i;
                        }
                      }
                    } catch (err) {
                      _iterator8.e(err);
                    } finally {
                      _iterator8.f();
                    }
                  }

                  i++;

                  if (i === argsArrayLen) {
                    return i;
                  }

                  if (chunkOperations && ++steps > EXECUTION_STEPS) {
                    if (Date.now() > endTime) {
                      continueCallback();
                      return i;
                    }

                    steps = 0;
                  }
                }
              },
              endDrawing: function CanvasGraphics_endDrawing() {
                if (this.current.activeSMask !== null) {
                  this.endSMaskGroup();
                }

                this.ctx.restore();

                if (this.transparentCanvas) {
                  this.ctx = this.compositeCtx;
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.drawImage(this.transparentCanvas, 0, 0);
                  this.ctx.restore();
                  this.transparentCanvas = null;
                }

                this.cachedCanvases.clear();
                this.webGLContext.clear();

                if (this.imageLayer) {
                  this.imageLayer.endLayout();
                }
              },
              setLineWidth: function CanvasGraphics_setLineWidth(width) {
                this.current.lineWidth = width;
                this.ctx.lineWidth = width;
              },
              setLineCap: function CanvasGraphics_setLineCap(style) {
                this.ctx.lineCap = LINE_CAP_STYLES[style];
              },
              setLineJoin: function CanvasGraphics_setLineJoin(style) {
                this.ctx.lineJoin = LINE_JOIN_STYLES[style];
              },
              setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {
                this.ctx.miterLimit = limit;
              },
              setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {
                var ctx = this.ctx;

                if (ctx.setLineDash !== undefined) {
                  ctx.setLineDash(dashArray);
                  ctx.lineDashOffset = dashPhase;
                }
              },
              setRenderingIntent: function setRenderingIntent(intent) {},
              setFlatness: function setFlatness(flatness) {},
              setGState: function CanvasGraphics_setGState(states) {
                for (var i = 0, ii = states.length; i < ii; i++) {
                  var state = states[i];
                  var key = state[0];
                  var value = state[1];

                  switch (key) {
                    case "LW":
                      this.setLineWidth(value);
                      break;

                    case "LC":
                      this.setLineCap(value);
                      break;

                    case "LJ":
                      this.setLineJoin(value);
                      break;

                    case "ML":
                      this.setMiterLimit(value);
                      break;

                    case "D":
                      this.setDash(value[0], value[1]);
                      break;

                    case "RI":
                      this.setRenderingIntent(value);
                      break;

                    case "FL":
                      this.setFlatness(value);
                      break;

                    case "Font":
                      this.setFont(value[0], value[1]);
                      break;

                    case "CA":
                      this.current.strokeAlpha = state[1];
                      break;

                    case "ca":
                      this.current.fillAlpha = state[1];
                      this.ctx.globalAlpha = state[1];
                      break;

                    case "BM":
                      this.ctx.globalCompositeOperation = value;
                      break;

                    case "SMask":
                      if (this.current.activeSMask) {
                        if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                          this.suspendSMaskGroup();
                        } else {
                          this.endSMaskGroup();
                        }
                      }

                      this.current.activeSMask = value ? this.tempSMask : null;

                      if (this.current.activeSMask) {
                        this.beginSMaskGroup();
                      }

                      this.tempSMask = null;
                      break;
                  }
                }
              },
              beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {
                var activeSMask = this.current.activeSMask;
                var drawnWidth = activeSMask.canvas.width;
                var drawnHeight = activeSMask.canvas.height;
                var cacheId = "smaskGroupAt" + this.groupLevel;
                var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                var currentCtx = this.ctx;
                var currentTransform = currentCtx.mozCurrentTransform;
                this.ctx.save();
                var groupCtx = scratchCanvas.context;
                groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
                groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
                groupCtx.transform.apply(groupCtx, currentTransform);
                activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
                copyCtxState(currentCtx, groupCtx);
                this.ctx = groupCtx;
                this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                this.groupStack.push(currentCtx);
                this.groupLevel++;
              },
              suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                var groupCtx = this.ctx;
                this.groupLevel--;
                this.ctx = this.groupStack.pop();
                composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                this.ctx.restore();
                this.ctx.save();
                copyCtxState(groupCtx, this.ctx);
                this.current.resumeSMaskCtx = groupCtx;

                var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

                this.ctx.transform.apply(this.ctx, deltaTransform);
                groupCtx.save();
                groupCtx.setTransform(1, 0, 0, 1, 0, 0);
                groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
                groupCtx.restore();
              },
              resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                var groupCtx = this.current.resumeSMaskCtx;
                var currentCtx = this.ctx;
                this.ctx = groupCtx;
                this.groupStack.push(currentCtx);
                this.groupLevel++;
              },
              endSMaskGroup: function CanvasGraphics_endSMaskGroup() {
                var groupCtx = this.ctx;
                this.groupLevel--;
                this.ctx = this.groupStack.pop();
                composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);
                this.ctx.restore();
                copyCtxState(groupCtx, this.ctx);

                var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

                this.ctx.transform.apply(this.ctx, deltaTransform);
              },
              save: function CanvasGraphics_save() {
                this.ctx.save();
                var old = this.current;
                this.stateStack.push(old);
                this.current = old.clone();
                this.current.resumeSMaskCtx = null;
              },
              restore: function CanvasGraphics_restore() {
                if (this.current.resumeSMaskCtx) {
                  this.resumeSMaskGroup();
                }

                if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
                  this.endSMaskGroup();
                }

                if (this.stateStack.length !== 0) {
                  this.current = this.stateStack.pop();
                  this.ctx.restore();
                  this.pendingClip = null;
                  this._cachedGetSinglePixelWidth = null;
                }
              },
              transform: function CanvasGraphics_transform(a, b, c, d, e, f) {
                this.ctx.transform(a, b, c, d, e, f);
                this._cachedGetSinglePixelWidth = null;
              },
              constructPath: function CanvasGraphics_constructPath(ops, args) {
                var ctx = this.ctx;
                var current = this.current;
                var x = current.x,
                    y = current.y;

                for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
                  switch (ops[i] | 0) {
                    case _util.OPS.rectangle:
                      x = args[j++];
                      y = args[j++];
                      var width = args[j++];
                      var height = args[j++];

                      if (width === 0) {
                        width = this.getSinglePixelWidth();
                      }

                      if (height === 0) {
                        height = this.getSinglePixelWidth();
                      }

                      var xw = x + width;
                      var yh = y + height;
                      this.ctx.moveTo(x, y);
                      this.ctx.lineTo(xw, y);
                      this.ctx.lineTo(xw, yh);
                      this.ctx.lineTo(x, yh);
                      this.ctx.lineTo(x, y);
                      this.ctx.closePath();
                      break;

                    case _util.OPS.moveTo:
                      x = args[j++];
                      y = args[j++];
                      ctx.moveTo(x, y);
                      break;

                    case _util.OPS.lineTo:
                      x = args[j++];
                      y = args[j++];
                      ctx.lineTo(x, y);
                      break;

                    case _util.OPS.curveTo:
                      x = args[j + 4];
                      y = args[j + 5];
                      ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                      j += 6;
                      break;

                    case _util.OPS.curveTo2:
                      ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                      x = args[j + 2];
                      y = args[j + 3];
                      j += 4;
                      break;

                    case _util.OPS.curveTo3:
                      x = args[j + 2];
                      y = args[j + 3];
                      ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                      j += 4;
                      break;

                    case _util.OPS.closePath:
                      ctx.closePath();
                      break;
                  }
                }

                current.setCurrentPoint(x, y);
              },
              closePath: function CanvasGraphics_closePath() {
                this.ctx.closePath();
              },
              stroke: function CanvasGraphics_stroke(consumePath) {
                consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                var ctx = this.ctx;
                var strokeColor = this.current.strokeColor;
                ctx.globalAlpha = this.current.strokeAlpha;

                if (strokeColor && strokeColor.hasOwnProperty("type") && strokeColor.type === "Pattern") {
                  ctx.save();
                  var transform = ctx.mozCurrentTransform;

                  var scale = _util.Util.singularValueDecompose2dScale(transform)[0];

                  ctx.strokeStyle = strokeColor.getPattern(ctx, this);
                  ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth * scale);
                  ctx.stroke();
                  ctx.restore();
                } else {
                  ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);
                  ctx.stroke();
                }

                if (consumePath) {
                  this.consumePath();
                }

                ctx.globalAlpha = this.current.fillAlpha;
              },
              closeStroke: function CanvasGraphics_closeStroke() {
                this.closePath();
                this.stroke();
              },
              fill: function CanvasGraphics_fill(consumePath) {
                consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                var ctx = this.ctx;
                var fillColor = this.current.fillColor;
                var isPatternFill = this.current.patternFill;
                var needRestore = false;

                if (isPatternFill) {
                  ctx.save();

                  if (this.baseTransform) {
                    ctx.setTransform.apply(ctx, this.baseTransform);
                  }

                  ctx.fillStyle = fillColor.getPattern(ctx, this);
                  needRestore = true;
                }

                if (this.pendingEOFill) {
                  ctx.fill("evenodd");
                  this.pendingEOFill = false;
                } else {
                  ctx.fill();
                }

                if (needRestore) {
                  ctx.restore();
                }

                if (consumePath) {
                  this.consumePath();
                }
              },
              eoFill: function CanvasGraphics_eoFill() {
                this.pendingEOFill = true;
                this.fill();
              },
              fillStroke: function CanvasGraphics_fillStroke() {
                this.fill(false);
                this.stroke(false);
                this.consumePath();
              },
              eoFillStroke: function CanvasGraphics_eoFillStroke() {
                this.pendingEOFill = true;
                this.fillStroke();
              },
              closeFillStroke: function CanvasGraphics_closeFillStroke() {
                this.closePath();
                this.fillStroke();
              },
              closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {
                this.pendingEOFill = true;
                this.closePath();
                this.fillStroke();
              },
              endPath: function CanvasGraphics_endPath() {
                this.consumePath();
              },
              clip: function CanvasGraphics_clip() {
                this.pendingClip = NORMAL_CLIP;
              },
              eoClip: function CanvasGraphics_eoClip() {
                this.pendingClip = EO_CLIP;
              },
              beginText: function CanvasGraphics_beginText() {
                this.current.textMatrix = _util.IDENTITY_MATRIX;
                this.current.textMatrixScale = 1;
                this.current.x = this.current.lineX = 0;
                this.current.y = this.current.lineY = 0;
              },
              endText: function CanvasGraphics_endText() {
                var paths = this.pendingTextPaths;
                var ctx = this.ctx;

                if (paths === undefined) {
                  ctx.beginPath();
                  return;
                }

                ctx.save();
                ctx.beginPath();

                for (var i = 0; i < paths.length; i++) {
                  var path = paths[i];
                  ctx.setTransform.apply(ctx, path.transform);
                  ctx.translate(path.x, path.y);
                  path.addToPath(ctx, path.fontSize);
                }

                ctx.restore();
                ctx.clip();
                ctx.beginPath();
                delete this.pendingTextPaths;
              },
              setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {
                this.current.charSpacing = spacing;
              },
              setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {
                this.current.wordSpacing = spacing;
              },
              setHScale: function CanvasGraphics_setHScale(scale) {
                this.current.textHScale = scale / 100;
              },
              setLeading: function CanvasGraphics_setLeading(leading) {
                this.current.leading = -leading;
              },
              setFont: function CanvasGraphics_setFont(fontRefName, size) {
                var fontObj = this.commonObjs.get(fontRefName);
                var current = this.current;

                if (!fontObj) {
                  throw new Error("Can't find font for ".concat(fontRefName));
                }

                current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;

                if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                  (0, _util.warn)("Invalid font matrix for font " + fontRefName);
                }

                if (size < 0) {
                  size = -size;
                  current.fontDirection = -1;
                } else {
                  current.fontDirection = 1;
                }

                this.current.font = fontObj;
                this.current.fontSize = size;

                if (fontObj.isType3Font) {
                  return;
                }

                var name = fontObj.loadedName || "sans-serif";
                var bold = "normal";

                if (fontObj.black) {
                  bold = "900";
                } else if (fontObj.bold) {
                  bold = "bold";
                }

                var italic = fontObj.italic ? "italic" : "normal";
                var typeface = "\"".concat(name, "\", ").concat(fontObj.fallbackName);
                var browserFontSize = size;

                if (size < MIN_FONT_SIZE) {
                  browserFontSize = MIN_FONT_SIZE;
                } else if (size > MAX_FONT_SIZE) {
                  browserFontSize = MAX_FONT_SIZE;
                }

                this.current.fontSizeScale = size / browserFontSize;
                this.ctx.font = "".concat(italic, " ").concat(bold, " ").concat(browserFontSize, "px ").concat(typeface);
              },
              setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {
                this.current.textRenderingMode = mode;
              },
              setTextRise: function CanvasGraphics_setTextRise(rise) {
                this.current.textRise = rise;
              },
              moveText: function CanvasGraphics_moveText(x, y) {
                this.current.x = this.current.lineX += x;
                this.current.y = this.current.lineY += y;
              },
              setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {
                this.setLeading(-y);
                this.moveText(x, y);
              },
              setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {
                this.current.textMatrix = [a, b, c, d, e, f];
                this.current.textMatrixScale = Math.sqrt(a * a + b * b);
                this.current.x = this.current.lineX = 0;
                this.current.y = this.current.lineY = 0;
              },
              nextLine: function CanvasGraphics_nextLine() {
                this.moveText(0, this.current.leading);
              },
              paintChar: function paintChar(character, x, y, patternTransform) {
                var ctx = this.ctx;
                var current = this.current;
                var font = current.font;
                var textRenderingMode = current.textRenderingMode;
                var fontSize = current.fontSize / current.fontSizeScale;
                var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
                var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
                var patternFill = current.patternFill && font.data;
                var addToPath;

                if (font.disableFontFace || isAddToPathSet || patternFill) {
                  addToPath = font.getPathGenerator(this.commonObjs, character);
                }

                if (font.disableFontFace || patternFill) {
                  ctx.save();
                  ctx.translate(x, y);
                  ctx.beginPath();
                  addToPath(ctx, fontSize);

                  if (patternTransform) {
                    ctx.setTransform.apply(ctx, patternTransform);
                  }

                  if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                    ctx.fill();
                  }

                  if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                    ctx.stroke();
                  }

                  ctx.restore();
                } else {
                  if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                    ctx.fillText(character, x, y);
                  }

                  if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                    ctx.strokeText(character, x, y);
                  }
                }

                if (isAddToPathSet) {
                  var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                  paths.push({
                    transform: ctx.mozCurrentTransform,
                    x: x,
                    y: y,
                    fontSize: fontSize,
                    addToPath: addToPath
                  });
                }
              },

              get isFontSubpixelAAEnabled() {
                var _this$cachedCanvases$ = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10),
                    ctx = _this$cachedCanvases$.context;

                ctx.scale(1.5, 1);
                ctx.fillText("I", 0, 10);
                var data = ctx.getImageData(0, 0, 10, 10).data;
                var enabled = false;

                for (var i = 3; i < data.length; i += 4) {
                  if (data[i] > 0 && data[i] < 255) {
                    enabled = true;
                    break;
                  }
                }

                return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
              },

              showText: function CanvasGraphics_showText(glyphs) {
                var current = this.current;
                var font = current.font;

                if (font.isType3Font) {
                  return this.showType3Text(glyphs);
                }

                var fontSize = current.fontSize;

                if (fontSize === 0) {
                  return undefined;
                }

                var ctx = this.ctx;
                var fontSizeScale = current.fontSizeScale;
                var charSpacing = current.charSpacing;
                var wordSpacing = current.wordSpacing;
                var fontDirection = current.fontDirection;
                var textHScale = current.textHScale * fontDirection;
                var glyphsLength = glyphs.length;
                var vertical = font.vertical;
                var spacingDir = vertical ? 1 : -1;
                var defaultVMetrics = font.defaultVMetrics;
                var widthAdvanceScale = fontSize * current.fontMatrix[0];
                var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                ctx.save();
                var patternTransform;

                if (current.patternFill) {
                  ctx.save();
                  var pattern = current.fillColor.getPattern(ctx, this);
                  patternTransform = ctx.mozCurrentTransform;
                  ctx.restore();
                  ctx.fillStyle = pattern;
                }

                ctx.transform.apply(ctx, current.textMatrix);
                ctx.translate(current.x, current.y + current.textRise);

                if (fontDirection > 0) {
                  ctx.scale(textHScale, -1);
                } else {
                  ctx.scale(textHScale, 1);
                }

                var lineWidth = current.lineWidth;
                var scale = current.textMatrixScale;

                if (scale === 0 || lineWidth === 0) {
                  var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

                  if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                    this._cachedGetSinglePixelWidth = null;
                    lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;
                  }
                } else {
                  lineWidth /= scale;
                }

                if (fontSizeScale !== 1.0) {
                  ctx.scale(fontSizeScale, fontSizeScale);
                  lineWidth /= fontSizeScale;
                }

                ctx.lineWidth = lineWidth;
                var x = 0,
                    i;

                for (i = 0; i < glyphsLength; ++i) {
                  var glyph = glyphs[i];

                  if ((0, _util.isNum)(glyph)) {
                    x += spacingDir * glyph * fontSize / 1000;
                    continue;
                  }

                  var restoreNeeded = false;
                  var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                  var character = glyph.fontChar;
                  var accent = glyph.accent;
                  var scaledX, scaledY, scaledAccentX, scaledAccentY;
                  var width = glyph.width;

                  if (vertical) {
                    var vmetric, vx, vy;
                    vmetric = glyph.vmetric || defaultVMetrics;
                    vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                    vx = -vx * widthAdvanceScale;
                    vy = vmetric[2] * widthAdvanceScale;
                    width = vmetric ? -vmetric[0] : width;
                    scaledX = vx / fontSizeScale;
                    scaledY = (x + vy) / fontSizeScale;
                  } else {
                    scaledX = x / fontSizeScale;
                    scaledY = 0;
                  }

                  if (font.remeasure && width > 0) {
                    var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;

                    if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                      var characterScaleX = width / measuredWidth;
                      restoreNeeded = true;
                      ctx.save();
                      ctx.scale(characterScaleX, 1);
                      scaledX /= characterScaleX;
                    } else if (width !== measuredWidth) {
                      scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
                    }
                  }

                  if (glyph.isInFont || font.missingFile) {
                    if (simpleFillText && !accent) {
                      ctx.fillText(character, scaledX, scaledY);
                    } else {
                      this.paintChar(character, scaledX, scaledY, patternTransform);

                      if (accent) {
                        scaledAccentX = scaledX + accent.offset.x / fontSizeScale;
                        scaledAccentY = scaledY - accent.offset.y / fontSizeScale;
                        this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                      }
                    }
                  }

                  var charWidth;

                  if (vertical) {
                    charWidth = width * widthAdvanceScale - spacing * fontDirection;
                  } else {
                    charWidth = width * widthAdvanceScale + spacing * fontDirection;
                  }

                  x += charWidth;

                  if (restoreNeeded) {
                    ctx.restore();
                  }
                }

                if (vertical) {
                  current.y -= x;
                } else {
                  current.x += x * textHScale;
                }

                ctx.restore();
              },
              showType3Text: function CanvasGraphics_showType3Text(glyphs) {
                var ctx = this.ctx;
                var current = this.current;
                var font = current.font;
                var fontSize = current.fontSize;
                var fontDirection = current.fontDirection;
                var spacingDir = font.vertical ? 1 : -1;
                var charSpacing = current.charSpacing;
                var wordSpacing = current.wordSpacing;
                var textHScale = current.textHScale * fontDirection;
                var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
                var glyphsLength = glyphs.length;
                var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
                var i, glyph, width, spacingLength;

                if (isTextInvisible || fontSize === 0) {
                  return;
                }

                this._cachedGetSinglePixelWidth = null;
                ctx.save();
                ctx.transform.apply(ctx, current.textMatrix);
                ctx.translate(current.x, current.y);
                ctx.scale(textHScale, fontDirection);

                for (i = 0; i < glyphsLength; ++i) {
                  glyph = glyphs[i];

                  if ((0, _util.isNum)(glyph)) {
                    spacingLength = spacingDir * glyph * fontSize / 1000;
                    this.ctx.translate(spacingLength, 0);
                    current.x += spacingLength * textHScale;
                    continue;
                  }

                  var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                  var operatorList = font.charProcOperatorList[glyph.operatorListId];

                  if (!operatorList) {
                    (0, _util.warn)("Type3 character \"".concat(glyph.operatorListId, "\" is not available."));
                    continue;
                  }

                  this.processingType3 = glyph;
                  this.save();
                  ctx.scale(fontSize, fontSize);
                  ctx.transform.apply(ctx, fontMatrix);
                  this.executeOperatorList(operatorList);
                  this.restore();

                  var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);

                  width = transformed[0] * fontSize + spacing;
                  ctx.translate(width, 0);
                  current.x += width * textHScale;
                }

                ctx.restore();
                this.processingType3 = null;
              },
              setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},
              setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                this.ctx.rect(llx, lly, urx - llx, ury - lly);
                this.clip();
                this.endPath();
              },
              getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {
                var _this35 = this;

                var pattern;

                if (IR[0] === "TilingPattern") {
                  var color = IR[1];
                  var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
                  var canvasGraphicsFactory = {
                    createCanvasGraphics: function createCanvasGraphics(ctx) {
                      return new CanvasGraphics(ctx, _this35.commonObjs, _this35.objs, _this35.canvasFactory, _this35.webGLContext);
                    }
                  };
                  pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                } else {
                  pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);
                }

                return pattern;
              },
              setStrokeColorN: function CanvasGraphics_setStrokeColorN() {
                this.current.strokeColor = this.getColorN_Pattern(arguments);
              },
              setFillColorN: function CanvasGraphics_setFillColorN() {
                this.current.fillColor = this.getColorN_Pattern(arguments);
                this.current.patternFill = true;
              },
              setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {
                var color = _util.Util.makeCssRgb(r, g, b);

                this.ctx.strokeStyle = color;
                this.current.strokeColor = color;
              },
              setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
                var color = _util.Util.makeCssRgb(r, g, b);

                this.ctx.fillStyle = color;
                this.current.fillColor = color;
                this.current.patternFill = false;
              },
              shadingFill: function CanvasGraphics_shadingFill(patternIR) {
                var ctx = this.ctx;
                this.save();
                var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);
                ctx.fillStyle = pattern.getPattern(ctx, this, true);
                var inv = ctx.mozCurrentTransformInverse;

                if (inv) {
                  var canvas = ctx.canvas;
                  var width = canvas.width;
                  var height = canvas.height;

                  var bl = _util.Util.applyTransform([0, 0], inv);

                  var br = _util.Util.applyTransform([0, height], inv);

                  var ul = _util.Util.applyTransform([width, 0], inv);

                  var ur = _util.Util.applyTransform([width, height], inv);

                  var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                  var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                  var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                  var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                  this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                } else {
                  this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                }

                this.restore();
              },
              beginInlineImage: function CanvasGraphics_beginInlineImage() {
                (0, _util.unreachable)("Should not call beginInlineImage");
              },
              beginImageData: function CanvasGraphics_beginImageData() {
                (0, _util.unreachable)("Should not call beginImageData");
              },
              paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {
                this.save();
                this.baseTransformStack.push(this.baseTransform);

                if (Array.isArray(matrix) && matrix.length === 6) {
                  this.transform.apply(this, matrix);
                }

                this.baseTransform = this.ctx.mozCurrentTransform;

                if (bbox) {
                  var width = bbox[2] - bbox[0];
                  var height = bbox[3] - bbox[1];
                  this.ctx.rect(bbox[0], bbox[1], width, height);
                  this.clip();
                  this.endPath();
                }
              },
              paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {
                this.restore();
                this.baseTransform = this.baseTransformStack.pop();
              },
              beginGroup: function CanvasGraphics_beginGroup(group) {
                this.save();
                var currentCtx = this.ctx;

                if (!group.isolated) {
                  (0, _util.info)("TODO: Support non-isolated groups.");
                }

                if (group.knockout) {
                  (0, _util.warn)("Knockout groups not supported.");
                }

                var currentTransform = currentCtx.mozCurrentTransform;

                if (group.matrix) {
                  currentCtx.transform.apply(currentCtx, group.matrix);
                }

                if (!group.bbox) {
                  throw new Error("Bounding box is required.");
                }

                var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);

                var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                var offsetX = Math.floor(bounds[0]);
                var offsetY = Math.floor(bounds[1]);
                var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                var scaleX = 1,
                    scaleY = 1;

                if (drawnWidth > MAX_GROUP_SIZE) {
                  scaleX = drawnWidth / MAX_GROUP_SIZE;
                  drawnWidth = MAX_GROUP_SIZE;
                }

                if (drawnHeight > MAX_GROUP_SIZE) {
                  scaleY = drawnHeight / MAX_GROUP_SIZE;
                  drawnHeight = MAX_GROUP_SIZE;
                }

                var cacheId = "groupAt" + this.groupLevel;

                if (group.smask) {
                  cacheId += "_smask_" + this.smaskCounter++ % 2;
                }

                var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
                var groupCtx = scratchCanvas.context;
                groupCtx.scale(1 / scaleX, 1 / scaleY);
                groupCtx.translate(-offsetX, -offsetY);
                groupCtx.transform.apply(groupCtx, currentTransform);

                if (group.smask) {
                  this.smaskStack.push({
                    canvas: scratchCanvas.canvas,
                    context: groupCtx,
                    offsetX: offsetX,
                    offsetY: offsetY,
                    scaleX: scaleX,
                    scaleY: scaleY,
                    subtype: group.smask.subtype,
                    backdrop: group.smask.backdrop,
                    transferMap: group.smask.transferMap || null,
                    startTransformInverse: null
                  });
                } else {
                  currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                  currentCtx.translate(offsetX, offsetY);
                  currentCtx.scale(scaleX, scaleY);
                }

                copyCtxState(currentCtx, groupCtx);
                this.ctx = groupCtx;
                this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                this.groupStack.push(currentCtx);
                this.groupLevel++;
                this.current.activeSMask = null;
              },
              endGroup: function CanvasGraphics_endGroup(group) {
                this.groupLevel--;
                var groupCtx = this.ctx;
                this.ctx = this.groupStack.pop();

                if (this.ctx.imageSmoothingEnabled !== undefined) {
                  this.ctx.imageSmoothingEnabled = false;
                } else {
                  this.ctx.mozImageSmoothingEnabled = false;
                }

                if (group.smask) {
                  this.tempSMask = this.smaskStack.pop();
                } else {
                  this.ctx.drawImage(groupCtx.canvas, 0, 0);
                }

                this.restore();
              },
              beginAnnotations: function CanvasGraphics_beginAnnotations() {
                this.save();

                if (this.baseTransform) {
                  this.ctx.setTransform.apply(this.ctx, this.baseTransform);
                }
              },
              endAnnotations: function CanvasGraphics_endAnnotations() {
                this.restore();
              },
              beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {
                this.save();
                resetCtxToDefault(this.ctx);
                this.current = new CanvasExtraState();

                if (Array.isArray(rect) && rect.length === 4) {
                  var width = rect[2] - rect[0];
                  var height = rect[3] - rect[1];
                  this.ctx.rect(rect[0], rect[1], width, height);
                  this.clip();
                  this.endPath();
                }

                this.transform.apply(this, transform);
                this.transform.apply(this, matrix);
              },
              endAnnotation: function CanvasGraphics_endAnnotation() {
                this.restore();
              },
              paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {
                var domImage = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);

                if (!domImage) {
                  (0, _util.warn)("Dependent image isn't ready yet");
                  return;
                }

                this.save();
                var ctx = this.ctx;
                ctx.scale(1 / w, -1 / h);
                ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h, w, h);

                if (this.imageLayer) {
                  var currentTransform = ctx.mozCurrentTransformInverse;
                  var position = this.getCanvasPosition(0, 0);
                  this.imageLayer.appendImage({
                    objId: objId,
                    left: position[0],
                    top: position[1],
                    width: w / currentTransform[0],
                    height: h / currentTransform[3]
                  });
                }

                this.restore();
              },
              paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {
                var ctx = this.ctx;
                var width = img.width,
                    height = img.height;
                var fillColor = this.current.fillColor;
                var isPatternFill = this.current.patternFill;
                var glyph = this.processingType3;

                if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {
                  if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
                    glyph.compiled = compileType3Glyph({
                      data: img.data,
                      width: width,
                      height: height
                    });
                  } else {
                    glyph.compiled = null;
                  }
                }

                if (glyph && glyph.compiled) {
                  glyph.compiled(ctx);
                  return;
                }

                var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                var maskCtx = maskCanvas.context;
                maskCtx.save();
                putBinaryImageMask(maskCtx, img);
                maskCtx.globalCompositeOperation = "source-in";
                maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                maskCtx.fillRect(0, 0, width, height);
                maskCtx.restore();
                this.paintInlineImageXObject(maskCanvas.canvas);
              },
              paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) {
                var width = imgData.width;
                var height = imgData.height;
                var fillColor = this.current.fillColor;
                var isPatternFill = this.current.patternFill;
                var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                var maskCtx = maskCanvas.context;
                maskCtx.save();
                putBinaryImageMask(maskCtx, imgData);
                maskCtx.globalCompositeOperation = "source-in";
                maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                maskCtx.fillRect(0, 0, width, height);
                maskCtx.restore();
                var ctx = this.ctx;

                for (var i = 0, ii = positions.length; i < ii; i += 2) {
                  ctx.save();
                  ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);
                  ctx.scale(1, -1);
                  ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                  ctx.restore();
                }
              },
              paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {
                var ctx = this.ctx;
                var fillColor = this.current.fillColor;
                var isPatternFill = this.current.patternFill;

                for (var i = 0, ii = images.length; i < ii; i++) {
                  var image = images[i];
                  var width = image.width,
                      height = image.height;
                  var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                  var maskCtx = maskCanvas.context;
                  maskCtx.save();
                  putBinaryImageMask(maskCtx, image);
                  maskCtx.globalCompositeOperation = "source-in";
                  maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;
                  maskCtx.fillRect(0, 0, width, height);
                  maskCtx.restore();
                  ctx.save();
                  ctx.transform.apply(ctx, image.transform);
                  ctx.scale(1, -1);
                  ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                  ctx.restore();
                }
              },
              paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {
                var imgData = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);

                if (!imgData) {
                  (0, _util.warn)("Dependent image isn't ready yet");
                  return;
                }

                this.paintInlineImageXObject(imgData);
              },
              paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                var imgData = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);

                if (!imgData) {
                  (0, _util.warn)("Dependent image isn't ready yet");
                  return;
                }

                var width = imgData.width;
                var height = imgData.height;
                var map = [];

                for (var i = 0, ii = positions.length; i < ii; i += 2) {
                  map.push({
                    transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                    x: 0,
                    y: 0,
                    w: width,
                    h: height
                  });
                }

                this.paintInlineImageXObjectGroup(imgData, map);
              },
              paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {
                var width = imgData.width;
                var height = imgData.height;
                var ctx = this.ctx;
                this.save();
                ctx.scale(1 / width, -1 / height);
                var currentTransform = ctx.mozCurrentTransformInverse;
                var a = currentTransform[0],
                    b = currentTransform[1];
                var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);
                var c = currentTransform[2],
                    d = currentTransform[3];
                var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);
                var imgToPaint, tmpCanvas;

                if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                  imgToPaint = imgData;
                } else {
                  tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                  var tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData);
                  imgToPaint = tmpCanvas.canvas;
                }

                var paintWidth = width,
                    paintHeight = height;
                var tmpCanvasId = "prescale1";

                while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                  var newWidth = paintWidth,
                      newHeight = paintHeight;

                  if (widthScale > 2 && paintWidth > 1) {
                    newWidth = Math.ceil(paintWidth / 2);
                    widthScale /= paintWidth / newWidth;
                  }

                  if (heightScale > 2 && paintHeight > 1) {
                    newHeight = Math.ceil(paintHeight / 2);
                    heightScale /= paintHeight / newHeight;
                  }

                  tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                  tmpCtx = tmpCanvas.context;
                  tmpCtx.clearRect(0, 0, newWidth, newHeight);
                  tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                  imgToPaint = tmpCanvas.canvas;
                  paintWidth = newWidth;
                  paintHeight = newHeight;
                  tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                }

                ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);

                if (this.imageLayer) {
                  var position = this.getCanvasPosition(0, -height);
                  this.imageLayer.appendImage({
                    imgData: imgData,
                    left: position[0],
                    top: position[1],
                    width: width / currentTransform[0],
                    height: height / currentTransform[3]
                  });
                }

                this.restore();
              },
              paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {
                var ctx = this.ctx;
                var w = imgData.width;
                var h = imgData.height;
                var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
                var tmpCtx = tmpCanvas.context;
                putBinaryImageData(tmpCtx, imgData);

                for (var i = 0, ii = map.length; i < ii; i++) {
                  var entry = map[i];
                  ctx.save();
                  ctx.transform.apply(ctx, entry.transform);
                  ctx.scale(1, -1);
                  ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);

                  if (this.imageLayer) {
                    var position = this.getCanvasPosition(entry.x, entry.y);
                    this.imageLayer.appendImage({
                      imgData: imgData,
                      left: position[0],
                      top: position[1],
                      width: w,
                      height: h
                    });
                  }

                  ctx.restore();
                }
              },
              paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {
                this.ctx.fillRect(0, 0, 1, 1);
              },
              paintXObject: function CanvasGraphics_paintXObject() {
                (0, _util.warn)("Unsupported 'paintXObject' command.");
              },
              markPoint: function CanvasGraphics_markPoint(tag) {},
              markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},
              beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {},
              beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {},
              endMarkedContent: function CanvasGraphics_endMarkedContent() {},
              beginCompat: function CanvasGraphics_beginCompat() {},
              endCompat: function CanvasGraphics_endCompat() {},
              consumePath: function CanvasGraphics_consumePath() {
                var ctx = this.ctx;

                if (this.pendingClip) {
                  if (this.pendingClip === EO_CLIP) {
                    ctx.clip("evenodd");
                  } else {
                    ctx.clip();
                  }

                  this.pendingClip = null;
                }

                ctx.beginPath();
              },
              getSinglePixelWidth: function getSinglePixelWidth(scale) {
                if (this._cachedGetSinglePixelWidth === null) {
                  var inverse = this.ctx.mozCurrentTransformInverse;
                  this._cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));
                }

                return this._cachedGetSinglePixelWidth;
              },
              getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {
                var transform = this.ctx.mozCurrentTransform;
                return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
              }
            };

            for (var op in _util.OPS) {
              CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
            }

            return CanvasGraphics;
          }();

          exports.CanvasGraphics = CanvasGraphics;
          /***/
        },
        /* 9 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getShadingPatternFromIR = getShadingPatternFromIR;
          exports.TilingPattern = void 0;

          var _util = __w_pdfjs_require__(1);

          var ShadingIRs = {};

          function applyBoundingBox(ctx, bbox) {
            if (!bbox || typeof Path2D === "undefined") {
              return;
            }

            var width = bbox[2] - bbox[0];
            var height = bbox[3] - bbox[1];
            var region = new Path2D();
            region.rect(bbox[0], bbox[1], width, height);
            ctx.clip(region);
          }

          ShadingIRs.RadialAxial = {
            fromIR: function RadialAxial_fromIR(raw) {
              var type = raw[1];
              var bbox = raw[2];
              var colorStops = raw[3];
              var p0 = raw[4];
              var p1 = raw[5];
              var r0 = raw[6];
              var r1 = raw[7];
              return {
                type: "Pattern",
                getPattern: function RadialAxial_getPattern(ctx) {
                  applyBoundingBox(ctx, bbox);
                  var grad;

                  if (type === "axial") {
                    grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
                  } else if (type === "radial") {
                    grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);
                  }

                  for (var i = 0, ii = colorStops.length; i < ii; ++i) {
                    var c = colorStops[i];
                    grad.addColorStop(c[0], c[1]);
                  }

                  return grad;
                }
              };
            }
          };

          var createMeshCanvas = function createMeshCanvasClosure() {
            function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
              var coords = context.coords,
                  colors = context.colors;
              var bytes = data.data,
                  rowSize = data.width * 4;
              var tmp;

              if (coords[p1 + 1] > coords[p2 + 1]) {
                tmp = p1;
                p1 = p2;
                p2 = tmp;
                tmp = c1;
                c1 = c2;
                c2 = tmp;
              }

              if (coords[p2 + 1] > coords[p3 + 1]) {
                tmp = p2;
                p2 = p3;
                p3 = tmp;
                tmp = c2;
                c2 = c3;
                c3 = tmp;
              }

              if (coords[p1 + 1] > coords[p2 + 1]) {
                tmp = p1;
                p1 = p2;
                p2 = tmp;
                tmp = c1;
                c1 = c2;
                c2 = tmp;
              }

              var x1 = (coords[p1] + context.offsetX) * context.scaleX;
              var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
              var x2 = (coords[p2] + context.offsetX) * context.scaleX;
              var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
              var x3 = (coords[p3] + context.offsetX) * context.scaleX;
              var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;

              if (y1 >= y3) {
                return;
              }

              var c1r = colors[c1],
                  c1g = colors[c1 + 1],
                  c1b = colors[c1 + 2];
              var c2r = colors[c2],
                  c2g = colors[c2 + 1],
                  c2b = colors[c2 + 2];
              var c3r = colors[c3],
                  c3g = colors[c3 + 1],
                  c3b = colors[c3 + 2];
              var minY = Math.round(y1),
                  maxY = Math.round(y3);
              var xa, car, cag, cab;
              var xb, cbr, cbg, cbb;

              for (var y = minY; y <= maxY; y++) {
                if (y < y2) {
                  var _k = void 0;

                  if (y < y1) {
                    _k = 0;
                  } else if (y1 === y2) {
                    _k = 1;
                  } else {
                    _k = (y1 - y) / (y1 - y2);
                  }

                  xa = x1 - (x1 - x2) * _k;
                  car = c1r - (c1r - c2r) * _k;
                  cag = c1g - (c1g - c2g) * _k;
                  cab = c1b - (c1b - c2b) * _k;
                } else {
                  var _k2 = void 0;

                  if (y > y3) {
                    _k2 = 1;
                  } else if (y2 === y3) {
                    _k2 = 0;
                  } else {
                    _k2 = (y2 - y) / (y2 - y3);
                  }

                  xa = x2 - (x2 - x3) * _k2;
                  car = c2r - (c2r - c3r) * _k2;
                  cag = c2g - (c2g - c3g) * _k2;
                  cab = c2b - (c2b - c3b) * _k2;
                }

                var k = void 0;

                if (y < y1) {
                  k = 0;
                } else if (y > y3) {
                  k = 1;
                } else {
                  k = (y1 - y) / (y1 - y3);
                }

                xb = x1 - (x1 - x3) * k;
                cbr = c1r - (c1r - c3r) * k;
                cbg = c1g - (c1g - c3g) * k;
                cbb = c1b - (c1b - c3b) * k;
                var x1_ = Math.round(Math.min(xa, xb));
                var x2_ = Math.round(Math.max(xa, xb));
                var j = rowSize * y + x1_ * 4;

                for (var x = x1_; x <= x2_; x++) {
                  var _k3 = (xa - x) / (xa - xb);

                  if (_k3 < 0) {
                    _k3 = 0;
                  } else if (_k3 > 1) {
                    _k3 = 1;
                  }

                  bytes[j++] = car - (car - cbr) * _k3 | 0;
                  bytes[j++] = cag - (cag - cbg) * _k3 | 0;
                  bytes[j++] = cab - (cab - cbb) * _k3 | 0;
                  bytes[j++] = 255;
                }
              }
            }

            function drawFigure(data, figure, context) {
              var ps = figure.coords;
              var cs = figure.colors;
              var i, ii;

              switch (figure.type) {
                case "lattice":
                  var verticesPerRow = figure.verticesPerRow;
                  var rows = Math.floor(ps.length / verticesPerRow) - 1;
                  var cols = verticesPerRow - 1;

                  for (i = 0; i < rows; i++) {
                    var q = i * verticesPerRow;

                    for (var j = 0; j < cols; j++, q++) {
                      drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                      drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                    }
                  }

                  break;

                case "triangles":
                  for (i = 0, ii = ps.length; i < ii; i += 3) {
                    drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                  }

                  break;

                default:
                  throw new Error("illegal figure");
              }
            }

            function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {
              var EXPECTED_SCALE = 1.1;
              var MAX_PATTERN_SIZE = 3000;
              var BORDER_SIZE = 2;
              var offsetX = Math.floor(bounds[0]);
              var offsetY = Math.floor(bounds[1]);
              var boundsWidth = Math.ceil(bounds[2]) - offsetX;
              var boundsHeight = Math.ceil(bounds[3]) - offsetY;
              var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
              var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
              var scaleX = boundsWidth / width;
              var scaleY = boundsHeight / height;
              var context = {
                coords: coords,
                colors: colors,
                offsetX: -offsetX,
                offsetY: -offsetY,
                scaleX: 1 / scaleX,
                scaleY: 1 / scaleY
              };
              var paddedWidth = width + BORDER_SIZE * 2;
              var paddedHeight = height + BORDER_SIZE * 2;
              var canvas, tmpCanvas, i, ii;

              if (webGLContext.isEnabled) {
                canvas = webGLContext.drawFigures({
                  width: width,
                  height: height,
                  backgroundColor: backgroundColor,
                  figures: figures,
                  context: context
                });
                tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);
                canvas = tmpCanvas.canvas;
              } else {
                tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                var tmpCtx = tmpCanvas.context;
                var data = tmpCtx.createImageData(width, height);

                if (backgroundColor) {
                  var bytes = data.data;

                  for (i = 0, ii = bytes.length; i < ii; i += 4) {
                    bytes[i] = backgroundColor[0];
                    bytes[i + 1] = backgroundColor[1];
                    bytes[i + 2] = backgroundColor[2];
                    bytes[i + 3] = 255;
                  }
                }

                for (i = 0; i < figures.length; i++) {
                  drawFigure(data, figures[i], context);
                }

                tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                canvas = tmpCanvas.canvas;
              }

              return {
                canvas: canvas,
                offsetX: offsetX - BORDER_SIZE * scaleX,
                offsetY: offsetY - BORDER_SIZE * scaleY,
                scaleX: scaleX,
                scaleY: scaleY
              };
            }

            return createMeshCanvas;
          }();

          ShadingIRs.Mesh = {
            fromIR: function Mesh_fromIR(raw) {
              var coords = raw[2];
              var colors = raw[3];
              var figures = raw[4];
              var bounds = raw[5];
              var matrix = raw[6];
              var bbox = raw[7];
              var background = raw[8];
              return {
                type: "Pattern",
                getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {
                  applyBoundingBox(ctx, bbox);
                  var scale;

                  if (shadingFill) {
                    scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
                  } else {
                    scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);

                    if (matrix) {
                      var matrixScale = _util.Util.singularValueDecompose2dScale(matrix);

                      scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                    }
                  }

                  var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);

                  if (!shadingFill) {
                    ctx.setTransform.apply(ctx, owner.baseTransform);

                    if (matrix) {
                      ctx.transform.apply(ctx, matrix);
                    }
                  }

                  ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                  return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                }
              };
            }
          };
          ShadingIRs.Dummy = {
            fromIR: function Dummy_fromIR() {
              return {
                type: "Pattern",
                getPattern: function Dummy_fromIR_getPattern() {
                  return "hotpink";
                }
              };
            }
          };

          function getShadingPatternFromIR(raw) {
            var shadingIR = ShadingIRs[raw[0]];

            if (!shadingIR) {
              throw new Error("Unknown IR type: ".concat(raw[0]));
            }

            return shadingIR.fromIR(raw);
          }

          var TilingPattern = function TilingPatternClosure() {
            var PaintType = {
              COLORED: 1,
              UNCOLORED: 2
            };
            var MAX_PATTERN_SIZE = 3000;

            function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
              this.operatorList = IR[2];
              this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
              this.bbox = IR[4];
              this.xstep = IR[5];
              this.ystep = IR[6];
              this.paintType = IR[7];
              this.tilingType = IR[8];
              this.color = color;
              this.canvasGraphicsFactory = canvasGraphicsFactory;
              this.baseTransform = baseTransform;
              this.type = "Pattern";
              this.ctx = ctx;
            }

            TilingPattern.prototype = {
              createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {
                var operatorList = this.operatorList;
                var bbox = this.bbox;
                var xstep = this.xstep;
                var ystep = this.ystep;
                var paintType = this.paintType;
                var tilingType = this.tilingType;
                var color = this.color;
                var canvasGraphicsFactory = this.canvasGraphicsFactory;
                (0, _util.info)("TilingType: " + tilingType);
                var x0 = bbox[0],
                    y0 = bbox[1],
                    x1 = bbox[2],
                    y1 = bbox[3];

                var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

                var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);

                var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                var tmpCtx = tmpCanvas.context;
                var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                graphics.groupLevel = owner.groupLevel;
                this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                graphics.transform(1, 0, 0, 1, -x0, -y0);
                this.clipBbox(graphics, bbox, x0, y0, x1, y1);
                graphics.executeOperatorList(operatorList);
                this.ctx.transform(1, 0, 0, 1, x0, y0);
                this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);
                return tmpCanvas.canvas;
              },
              getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {
                step = Math.abs(step);
                var maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);
                var size = Math.ceil(step * scale);

                if (size >= maxSize) {
                  size = maxSize;
                } else {
                  scale = size / step;
                }

                return {
                  scale: scale,
                  size: size
                };
              },
              clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {
                if (Array.isArray(bbox) && bbox.length === 4) {
                  var bboxWidth = x1 - x0;
                  var bboxHeight = y1 - y0;
                  graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                  graphics.clip();
                  graphics.endPath();
                }
              },
              setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
                var context = graphics.ctx,
                    current = graphics.current;

                switch (paintType) {
                  case PaintType.COLORED:
                    var ctx = this.ctx;
                    context.fillStyle = ctx.fillStyle;
                    context.strokeStyle = ctx.strokeStyle;
                    current.fillColor = ctx.fillStyle;
                    current.strokeColor = ctx.strokeStyle;
                    break;

                  case PaintType.UNCOLORED:
                    var cssColor = _util.Util.makeCssRgb(color[0], color[1], color[2]);

                    context.fillStyle = cssColor;
                    context.strokeStyle = cssColor;
                    current.fillColor = cssColor;
                    current.strokeColor = cssColor;
                    break;

                  default:
                    throw new _util.FormatError("Unsupported paint type: ".concat(paintType));
                }
              },
              getPattern: function TilingPattern_getPattern(ctx, owner) {
                ctx = this.ctx;
                ctx.setTransform.apply(ctx, this.baseTransform);
                ctx.transform.apply(ctx, this.matrix);
                var temporaryPatternCanvas = this.createPatternCanvas(owner);
                return ctx.createPattern(temporaryPatternCanvas, "repeat");
              }
            };
            return TilingPattern;
          }();

          exports.TilingPattern = TilingPattern;
          /***/
        },
        /* 10 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.GlobalWorkerOptions = void 0;
          var GlobalWorkerOptions = Object.create(null);
          exports.GlobalWorkerOptions = GlobalWorkerOptions;
          GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
          GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;
          /***/
        },
        /* 11 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MessageHandler = void 0;

          var _util = __w_pdfjs_require__(1);

          var CallbackKind = {
            UNKNOWN: 0,
            DATA: 1,
            ERROR: 2
          };
          var StreamKind = {
            UNKNOWN: 0,
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };

          function wrapReason(reason) {
            if (typeof reason !== "object" || reason === null) {
              return reason;
            }

            switch (reason.name) {
              case "AbortException":
                return new _util.AbortException(reason.message);

              case "MissingPDFException":
                return new _util.MissingPDFException(reason.message);

              case "UnexpectedResponseException":
                return new _util.UnexpectedResponseException(reason.message, reason.status);

              case "UnknownErrorException":
                return new _util.UnknownErrorException(reason.message, reason.details);

              default:
                return new _util.UnknownErrorException(reason.message, reason.toString());
            }
          }

          var MessageHandler = /*#__PURE__*/function () {
            function MessageHandler(sourceName, targetName, comObj) {
              var _this36 = this;

              _classCallCheck(this, MessageHandler);

              this.sourceName = sourceName;
              this.targetName = targetName;
              this.comObj = comObj;
              this.callbackId = 1;
              this.streamId = 1;
              this.postMessageTransfers = true;
              this.streamSinks = Object.create(null);
              this.streamControllers = Object.create(null);
              this.callbackCapabilities = Object.create(null);
              this.actionHandler = Object.create(null);

              this._onComObjOnMessage = function (event) {
                var data = event.data;

                if (data.targetName !== _this36.sourceName) {
                  return;
                }

                if (data.stream) {
                  _this36._processStreamMessage(data);

                  return;
                }

                if (data.callback) {
                  var callbackId = data.callbackId;
                  var capability = _this36.callbackCapabilities[callbackId];

                  if (!capability) {
                    throw new Error("Cannot resolve callback ".concat(callbackId));
                  }

                  delete _this36.callbackCapabilities[callbackId];

                  if (data.callback === CallbackKind.DATA) {
                    capability.resolve(data.data);
                  } else if (data.callback === CallbackKind.ERROR) {
                    capability.reject(wrapReason(data.reason));
                  } else {
                    throw new Error("Unexpected callback case");
                  }

                  return;
                }

                var action = _this36.actionHandler[data.action];

                if (!action) {
                  throw new Error("Unknown action from worker: ".concat(data.action));
                }

                if (data.callbackId) {
                  var _sourceName = _this36.sourceName;
                  var _targetName = data.sourceName;
                  new Promise(function (resolve) {
                    resolve(action(data.data));
                  }).then(function (result) {
                    comObj.postMessage({
                      sourceName: _sourceName,
                      targetName: _targetName,
                      callback: CallbackKind.DATA,
                      callbackId: data.callbackId,
                      data: result
                    });
                  }, function (reason) {
                    comObj.postMessage({
                      sourceName: _sourceName,
                      targetName: _targetName,
                      callback: CallbackKind.ERROR,
                      callbackId: data.callbackId,
                      reason: wrapReason(reason)
                    });
                  });
                  return;
                }

                if (data.streamId) {
                  _this36._createStreamSink(data);

                  return;
                }

                action(data.data);
              };

              comObj.addEventListener("message", this._onComObjOnMessage);
            }

            _createClass(MessageHandler, [{
              key: "on",
              value: function on(actionName, handler) {
                var ah = this.actionHandler;

                if (ah[actionName]) {
                  throw new Error("There is already an actionName called \"".concat(actionName, "\""));
                }

                ah[actionName] = handler;
              }
            }, {
              key: "send",
              value: function send(actionName, data, transfers) {
                this._postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data: data
                }, transfers);
              }
            }, {
              key: "sendWithPromise",
              value: function sendWithPromise(actionName, data, transfers) {
                var callbackId = this.callbackId++;
                var capability = (0, _util.createPromiseCapability)();
                this.callbackCapabilities[callbackId] = capability;

                try {
                  this._postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    callbackId: callbackId,
                    data: data
                  }, transfers);
                } catch (ex) {
                  capability.reject(ex);
                }

                return capability.promise;
              }
            }, {
              key: "sendWithStream",
              value: function sendWithStream(actionName, data, queueingStrategy, transfers) {
                var _this37 = this;

                var streamId = this.streamId++;
                var sourceName = this.sourceName;
                var targetName = this.targetName;
                var comObj = this.comObj;
                return new ReadableStream({
                  start: function start(controller) {
                    var startCapability = (0, _util.createPromiseCapability)();
                    _this37.streamControllers[streamId] = {
                      controller: controller,
                      startCall: startCapability,
                      pullCall: null,
                      cancelCall: null,
                      isClosed: false
                    };

                    _this37._postMessage({
                      sourceName: sourceName,
                      targetName: targetName,
                      action: actionName,
                      streamId: streamId,
                      data: data,
                      desiredSize: controller.desiredSize
                    }, transfers);

                    return startCapability.promise;
                  },
                  pull: function pull(controller) {
                    var pullCapability = (0, _util.createPromiseCapability)();
                    _this37.streamControllers[streamId].pullCall = pullCapability;
                    comObj.postMessage({
                      sourceName: sourceName,
                      targetName: targetName,
                      stream: StreamKind.PULL,
                      streamId: streamId,
                      desiredSize: controller.desiredSize
                    });
                    return pullCapability.promise;
                  },
                  cancel: function cancel(reason) {
                    (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
                    var cancelCapability = (0, _util.createPromiseCapability)();
                    _this37.streamControllers[streamId].cancelCall = cancelCapability;
                    _this37.streamControllers[streamId].isClosed = true;
                    comObj.postMessage({
                      sourceName: sourceName,
                      targetName: targetName,
                      stream: StreamKind.CANCEL,
                      streamId: streamId,
                      reason: wrapReason(reason)
                    });
                    return cancelCapability.promise;
                  }
                }, queueingStrategy);
              }
            }, {
              key: "_createStreamSink",
              value: function _createStreamSink(data) {
                var self = this;
                var action = this.actionHandler[data.action];
                var streamId = data.streamId;
                var sourceName = this.sourceName;
                var targetName = data.sourceName;
                var comObj = this.comObj;
                var streamSink = {
                  enqueue: function enqueue(chunk) {
                    var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                    var transfers = arguments.length > 2 ? arguments[2] : undefined;

                    if (this.isCancelled) {
                      return;
                    }

                    var lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;

                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = (0, _util.createPromiseCapability)();
                      this.ready = this.sinkCapability.promise;
                    }

                    self._postMessage({
                      sourceName: sourceName,
                      targetName: targetName,
                      stream: StreamKind.ENQUEUE,
                      streamId: streamId,
                      chunk: chunk
                    }, transfers);
                  },
                  close: function close() {
                    if (this.isCancelled) {
                      return;
                    }

                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName: sourceName,
                      targetName: targetName,
                      stream: StreamKind.CLOSE,
                      streamId: streamId
                    });
                    delete self.streamSinks[streamId];
                  },
                  error: function error(reason) {
                    (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

                    if (this.isCancelled) {
                      return;
                    }

                    this.isCancelled = true;
                    comObj.postMessage({
                      sourceName: sourceName,
                      targetName: targetName,
                      stream: StreamKind.ERROR,
                      streamId: streamId,
                      reason: wrapReason(reason)
                    });
                  },
                  sinkCapability: (0, _util.createPromiseCapability)(),
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize: data.desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                new Promise(function (resolve) {
                  resolve(action(data.data, streamSink));
                }).then(function () {
                  comObj.postMessage({
                    sourceName: sourceName,
                    targetName: targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId: streamId,
                    success: true
                  });
                }, function (reason) {
                  comObj.postMessage({
                    sourceName: sourceName,
                    targetName: targetName,
                    stream: StreamKind.START_COMPLETE,
                    streamId: streamId,
                    reason: wrapReason(reason)
                  });
                });
              }
            }, {
              key: "_processStreamMessage",
              value: function _processStreamMessage(data) {
                var streamId = data.streamId;
                var sourceName = this.sourceName;
                var targetName = data.sourceName;
                var comObj = this.comObj;

                switch (data.stream) {
                  case StreamKind.START_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].startCall.resolve();
                    } else {
                      this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));
                    }

                    break;

                  case StreamKind.PULL_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].pullCall.resolve();
                    } else {
                      this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));
                    }

                    break;

                  case StreamKind.PULL:
                    if (!this.streamSinks[streamId]) {
                      comObj.postMessage({
                        sourceName: sourceName,
                        targetName: targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId: streamId,
                        success: true
                      });
                      break;
                    }

                    if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {
                      this.streamSinks[streamId].sinkCapability.resolve();
                    }

                    this.streamSinks[streamId].desiredSize = data.desiredSize;
                    var onPull = this.streamSinks[data.streamId].onPull;
                    new Promise(function (resolve) {
                      resolve(onPull && onPull());
                    }).then(function () {
                      comObj.postMessage({
                        sourceName: sourceName,
                        targetName: targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId: streamId,
                        success: true
                      });
                    }, function (reason) {
                      comObj.postMessage({
                        sourceName: sourceName,
                        targetName: targetName,
                        stream: StreamKind.PULL_COMPLETE,
                        streamId: streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    break;

                  case StreamKind.ENQUEUE:
                    (0, _util.assert)(this.streamControllers[streamId], "enqueue should have stream controller");

                    if (this.streamControllers[streamId].isClosed) {
                      break;
                    }

                    this.streamControllers[streamId].controller.enqueue(data.chunk);
                    break;

                  case StreamKind.CLOSE:
                    (0, _util.assert)(this.streamControllers[streamId], "close should have stream controller");

                    if (this.streamControllers[streamId].isClosed) {
                      break;
                    }

                    this.streamControllers[streamId].isClosed = true;
                    this.streamControllers[streamId].controller.close();

                    this._deleteStreamController(streamId);

                    break;

                  case StreamKind.ERROR:
                    (0, _util.assert)(this.streamControllers[streamId], "error should have stream controller");
                    this.streamControllers[streamId].controller.error(wrapReason(data.reason));

                    this._deleteStreamController(streamId);

                    break;

                  case StreamKind.CANCEL_COMPLETE:
                    if (data.success) {
                      this.streamControllers[streamId].cancelCall.resolve();
                    } else {
                      this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));
                    }

                    this._deleteStreamController(streamId);

                    break;

                  case StreamKind.CANCEL:
                    if (!this.streamSinks[streamId]) {
                      break;
                    }

                    var onCancel = this.streamSinks[data.streamId].onCancel;
                    new Promise(function (resolve) {
                      resolve(onCancel && onCancel(wrapReason(data.reason)));
                    }).then(function () {
                      comObj.postMessage({
                        sourceName: sourceName,
                        targetName: targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId: streamId,
                        success: true
                      });
                    }, function (reason) {
                      comObj.postMessage({
                        sourceName: sourceName,
                        targetName: targetName,
                        stream: StreamKind.CANCEL_COMPLETE,
                        streamId: streamId,
                        reason: wrapReason(reason)
                      });
                    });
                    this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));
                    this.streamSinks[streamId].isCancelled = true;
                    delete this.streamSinks[streamId];
                    break;

                  default:
                    throw new Error("Unexpected stream case");
                }
              }
            }, {
              key: "_deleteStreamController",
              value: function () {
                var _deleteStreamController2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(streamId) {
                  return regeneratorRuntime.wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          _context6.next = 2;
                          return Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) {
                            return capability && capability.promise;
                          }));

                        case 2:
                          delete this.streamControllers[streamId];

                        case 3:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6, this);
                }));

                function _deleteStreamController(_x5) {
                  return _deleteStreamController2.apply(this, arguments);
                }

                return _deleteStreamController;
              }()
            }, {
              key: "_postMessage",
              value: function _postMessage(message, transfers) {
                if (transfers && this.postMessageTransfers) {
                  this.comObj.postMessage(message, transfers);
                } else {
                  this.comObj.postMessage(message);
                }
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.comObj.removeEventListener("message", this._onComObjOnMessage);
              }
            }]);

            return MessageHandler;
          }();

          exports.MessageHandler = MessageHandler;
          /***/
        },
        /* 12 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Metadata = void 0;

          var _util = __w_pdfjs_require__(1);

          var _xml_parser = __w_pdfjs_require__(13);

          var Metadata = /*#__PURE__*/function () {
            function Metadata(data) {
              _classCallCheck(this, Metadata);

              (0, _util.assert)(typeof data === "string", "Metadata: input is not a string");
              data = this._repair(data);
              var parser = new _xml_parser.SimpleXMLParser();
              var xmlDocument = parser.parseFromString(data);
              this._metadataMap = new Map();

              if (xmlDocument) {
                this._parse(xmlDocument);
              }
            }

            _createClass(Metadata, [{
              key: "_repair",
              value: function _repair(data) {
                return data.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function (all, codes) {
                  var bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {
                    return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);
                  }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) {
                    switch (name) {
                      case "amp":
                        return "&";

                      case "apos":
                        return "'";

                      case "gt":
                        return ">";

                      case "lt":
                        return "<";

                      case "quot":
                        return '"';
                    }

                    throw new Error("_repair: ".concat(name, " isn't defined."));
                  });
                  var chars = "";

                  for (var i = 0, ii = bytes.length; i < ii; i += 2) {
                    var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);

                    if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {
                      chars += String.fromCharCode(code);
                    } else {
                      chars += "&#x" + (0x10000 + code).toString(16).substring(1) + ";";
                    }
                  }

                  return ">" + chars;
                });
              }
            }, {
              key: "_parse",
              value: function _parse(xmlDocument) {
                var rdf = xmlDocument.documentElement;

                if (rdf.nodeName.toLowerCase() !== "rdf:rdf") {
                  rdf = rdf.firstChild;

                  while (rdf && rdf.nodeName.toLowerCase() !== "rdf:rdf") {
                    rdf = rdf.nextSibling;
                  }
                }

                var nodeName = rdf ? rdf.nodeName.toLowerCase() : null;

                if (!rdf || nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {
                  return;
                }

                var children = rdf.childNodes;

                for (var i = 0, ii = children.length; i < ii; i++) {
                  var desc = children[i];

                  if (desc.nodeName.toLowerCase() !== "rdf:description") {
                    continue;
                  }

                  for (var j = 0, jj = desc.childNodes.length; j < jj; j++) {
                    if (desc.childNodes[j].nodeName.toLowerCase() !== "#text") {
                      var entry = desc.childNodes[j];
                      var name = entry.nodeName.toLowerCase();

                      this._metadataMap.set(name, entry.textContent.trim());
                    }
                  }
                }
              }
            }, {
              key: "get",
              value: function get(name) {
                return this._metadataMap.has(name) ? this._metadataMap.get(name) : null;
              }
            }, {
              key: "getAll",
              value: function getAll() {
                var obj = Object.create(null);

                var _iterator9 = _createForOfIteratorHelper(this._metadataMap),
                    _step9;

                try {
                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                    var _step9$value = _slicedToArray(_step9.value, 2),
                        key = _step9$value[0],
                        value = _step9$value[1];

                    obj[key] = value;
                  }
                } catch (err) {
                  _iterator9.e(err);
                } finally {
                  _iterator9.f();
                }

                return obj;
              }
            }, {
              key: "has",
              value: function has(name) {
                return this._metadataMap.has(name);
              }
            }]);

            return Metadata;
          }();

          exports.Metadata = Metadata;
          /***/
        },
        /* 13 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SimpleXMLParser = void 0;
          var XMLParserErrorCode = {
            NoError: 0,
            EndOfDocument: -1,
            UnterminatedCdat: -2,
            UnterminatedXmlDeclaration: -3,
            UnterminatedDoctypeDeclaration: -4,
            UnterminatedComment: -5,
            MalformedElement: -6,
            OutOfMemory: -7,
            UnterminatedAttributeValue: -8,
            UnterminatedElement: -9,
            ElementNeverBegun: -10
          };

          function isWhitespace(s, index) {
            var ch = s[index];
            return ch === " " || ch === "\n" || ch === "\r" || ch === "\t";
          }

          function isWhitespaceString(s) {
            for (var i = 0, ii = s.length; i < ii; i++) {
              if (!isWhitespace(s, i)) {
                return false;
              }
            }

            return true;
          }

          var XMLParserBase = /*#__PURE__*/function () {
            function XMLParserBase() {
              _classCallCheck(this, XMLParserBase);
            }

            _createClass(XMLParserBase, [{
              key: "_resolveEntities",
              value: function _resolveEntities(s) {
                var _this38 = this;

                return s.replace(/&([^;]+);/g, function (all, entity) {
                  if (entity.substring(0, 2) === "#x") {
                    return String.fromCharCode(parseInt(entity.substring(2), 16));
                  } else if (entity.substring(0, 1) === "#") {
                    return String.fromCharCode(parseInt(entity.substring(1), 10));
                  }

                  switch (entity) {
                    case "lt":
                      return "<";

                    case "gt":
                      return ">";

                    case "amp":
                      return "&";

                    case "quot":
                      return '"';
                  }

                  return _this38.onResolveEntity(entity);
                });
              }
            }, {
              key: "_parseContent",
              value: function _parseContent(s, start) {
                var attributes = [];
                var pos = start;

                function skipWs() {
                  while (pos < s.length && isWhitespace(s, pos)) {
                    ++pos;
                  }
                }

                while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                  ++pos;
                }

                var name = s.substring(start, pos);
                skipWs();

                while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {
                  skipWs();
                  var attrName = "",
                      attrValue = "";

                  while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {
                    attrName += s[pos];
                    ++pos;
                  }

                  skipWs();

                  if (s[pos] !== "=") {
                    return null;
                  }

                  ++pos;
                  skipWs();
                  var attrEndChar = s[pos];

                  if (attrEndChar !== '"' && attrEndChar !== "'") {
                    return null;
                  }

                  var attrEndIndex = s.indexOf(attrEndChar, ++pos);

                  if (attrEndIndex < 0) {
                    return null;
                  }

                  attrValue = s.substring(pos, attrEndIndex);
                  attributes.push({
                    name: attrName,
                    value: this._resolveEntities(attrValue)
                  });
                  pos = attrEndIndex + 1;
                  skipWs();
                }

                return {
                  name: name,
                  attributes: attributes,
                  parsed: pos - start
                };
              }
            }, {
              key: "_parseProcessingInstruction",
              value: function _parseProcessingInstruction(s, start) {
                var pos = start;

                function skipWs() {
                  while (pos < s.length && isWhitespace(s, pos)) {
                    ++pos;
                  }
                }

                while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {
                  ++pos;
                }

                var name = s.substring(start, pos);
                skipWs();
                var attrStart = pos;

                while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {
                  ++pos;
                }

                var value = s.substring(attrStart, pos);
                return {
                  name: name,
                  value: value,
                  parsed: pos - start
                };
              }
            }, {
              key: "parseXml",
              value: function parseXml(s) {
                var i = 0;

                while (i < s.length) {
                  var ch = s[i];
                  var j = i;

                  if (ch === "<") {
                    ++j;
                    var ch2 = s[j];
                    var q = void 0;

                    switch (ch2) {
                      case "/":
                        ++j;
                        q = s.indexOf(">", j);

                        if (q < 0) {
                          this.onError(XMLParserErrorCode.UnterminatedElement);
                          return;
                        }

                        this.onEndElement(s.substring(j, q));
                        j = q + 1;
                        break;

                      case "?":
                        ++j;

                        var pi = this._parseProcessingInstruction(s, j);

                        if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {
                          this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);
                          return;
                        }

                        this.onPi(pi.name, pi.value);
                        j += pi.parsed + 2;
                        break;

                      case "!":
                        if (s.substring(j + 1, j + 3) === "--") {
                          q = s.indexOf("-->", j + 3);

                          if (q < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedComment);
                            return;
                          }

                          this.onComment(s.substring(j + 3, q));
                          j = q + 3;
                        } else if (s.substring(j + 1, j + 8) === "[CDATA[") {
                          q = s.indexOf("]]>", j + 8);

                          if (q < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedCdat);
                            return;
                          }

                          this.onCdata(s.substring(j + 8, q));
                          j = q + 3;
                        } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {
                          var q2 = s.indexOf("[", j + 8);
                          var complexDoctype = false;
                          q = s.indexOf(">", j + 8);

                          if (q < 0) {
                            this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                            return;
                          }

                          if (q2 > 0 && q > q2) {
                            q = s.indexOf("]>", j + 8);

                            if (q < 0) {
                              this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);
                              return;
                            }

                            complexDoctype = true;
                          }

                          var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                          this.onDoctype(doctypeContent);
                          j = q + (complexDoctype ? 2 : 1);
                        } else {
                          this.onError(XMLParserErrorCode.MalformedElement);
                          return;
                        }

                        break;

                      default:
                        var content = this._parseContent(s, j);

                        if (content === null) {
                          this.onError(XMLParserErrorCode.MalformedElement);
                          return;
                        }

                        var isClosed = false;

                        if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {
                          isClosed = true;
                        } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {
                          this.onError(XMLParserErrorCode.UnterminatedElement);
                          return;
                        }

                        this.onBeginElement(content.name, content.attributes, isClosed);
                        j += content.parsed + (isClosed ? 2 : 1);
                        break;
                    }
                  } else {
                    while (j < s.length && s[j] !== "<") {
                      j++;
                    }

                    var text = s.substring(i, j);
                    this.onText(this._resolveEntities(text));
                  }

                  i = j;
                }
              }
            }, {
              key: "onResolveEntity",
              value: function onResolveEntity(name) {
                return "&".concat(name, ";");
              }
            }, {
              key: "onPi",
              value: function onPi(name, value) {}
            }, {
              key: "onComment",
              value: function onComment(text) {}
            }, {
              key: "onCdata",
              value: function onCdata(text) {}
            }, {
              key: "onDoctype",
              value: function onDoctype(doctypeContent) {}
            }, {
              key: "onText",
              value: function onText(text) {}
            }, {
              key: "onBeginElement",
              value: function onBeginElement(name, attributes, isEmpty) {}
            }, {
              key: "onEndElement",
              value: function onEndElement(name) {}
            }, {
              key: "onError",
              value: function onError(code) {}
            }]);

            return XMLParserBase;
          }();

          var SimpleDOMNode = /*#__PURE__*/function () {
            function SimpleDOMNode(nodeName, nodeValue) {
              _classCallCheck(this, SimpleDOMNode);

              this.nodeName = nodeName;
              this.nodeValue = nodeValue;
              Object.defineProperty(this, "parentNode", {
                value: null,
                writable: true
              });
            }

            _createClass(SimpleDOMNode, [{
              key: "hasChildNodes",
              value: function hasChildNodes() {
                return this.childNodes && this.childNodes.length > 0;
              }
            }, {
              key: "firstChild",
              get: function get() {
                return this.childNodes && this.childNodes[0];
              }
            }, {
              key: "nextSibling",
              get: function get() {
                var childNodes = this.parentNode.childNodes;

                if (!childNodes) {
                  return undefined;
                }

                var index = childNodes.indexOf(this);

                if (index === -1) {
                  return undefined;
                }

                return childNodes[index + 1];
              }
            }, {
              key: "textContent",
              get: function get() {
                if (!this.childNodes) {
                  return this.nodeValue || "";
                }

                return this.childNodes.map(function (child) {
                  return child.textContent;
                }).join("");
              }
            }]);

            return SimpleDOMNode;
          }();

          var SimpleXMLParser = /*#__PURE__*/function (_XMLParserBase) {
            _inherits(SimpleXMLParser, _XMLParserBase);

            var _super10 = _createSuper(SimpleXMLParser);

            function SimpleXMLParser() {
              var _this39;

              _classCallCheck(this, SimpleXMLParser);

              _this39 = _super10.call(this);
              _this39._currentFragment = null;
              _this39._stack = null;
              _this39._errorCode = XMLParserErrorCode.NoError;
              return _this39;
            }

            _createClass(SimpleXMLParser, [{
              key: "parseFromString",
              value: function parseFromString(data) {
                this._currentFragment = [];
                this._stack = [];
                this._errorCode = XMLParserErrorCode.NoError;
                this.parseXml(data);

                if (this._errorCode !== XMLParserErrorCode.NoError) {
                  return undefined;
                }

                var _this$_currentFragmen = _slicedToArray(this._currentFragment, 1),
                    documentElement = _this$_currentFragmen[0];

                if (!documentElement) {
                  return undefined;
                }

                return {
                  documentElement: documentElement
                };
              }
            }, {
              key: "onResolveEntity",
              value: function onResolveEntity(name) {
                switch (name) {
                  case "apos":
                    return "'";
                }

                return _get(_getPrototypeOf(SimpleXMLParser.prototype), "onResolveEntity", this).call(this, name);
              }
            }, {
              key: "onText",
              value: function onText(text) {
                if (isWhitespaceString(text)) {
                  return;
                }

                var node = new SimpleDOMNode("#text", text);

                this._currentFragment.push(node);
              }
            }, {
              key: "onCdata",
              value: function onCdata(text) {
                var node = new SimpleDOMNode("#text", text);

                this._currentFragment.push(node);
              }
            }, {
              key: "onBeginElement",
              value: function onBeginElement(name, attributes, isEmpty) {
                var node = new SimpleDOMNode(name);
                node.childNodes = [];

                this._currentFragment.push(node);

                if (isEmpty) {
                  return;
                }

                this._stack.push(this._currentFragment);

                this._currentFragment = node.childNodes;
              }
            }, {
              key: "onEndElement",
              value: function onEndElement(name) {
                this._currentFragment = this._stack.pop() || [];
                var lastElement = this._currentFragment[this._currentFragment.length - 1];

                if (!lastElement) {
                  return;
                }

                for (var i = 0, ii = lastElement.childNodes.length; i < ii; i++) {
                  lastElement.childNodes[i].parentNode = lastElement;
                }
              }
            }, {
              key: "onError",
              value: function onError(code) {
                this._errorCode = code;
              }
            }]);

            return SimpleXMLParser;
          }(XMLParserBase);

          exports.SimpleXMLParser = SimpleXMLParser;
          /***/
        },
        /* 14 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PDFDataTransportStream = void 0;

          var _util = __w_pdfjs_require__(1);

          var PDFDataTransportStream = /*#__PURE__*/function () {
            function PDFDataTransportStream(params, pdfDataRangeTransport) {
              var _this40 = this;

              _classCallCheck(this, PDFDataTransportStream);

              (0, _util.assert)(pdfDataRangeTransport);
              this._queuedChunks = [];
              this._progressiveDone = params.progressiveDone || false;
              var initialData = params.initialData;

              if (initialData && initialData.length > 0) {
                var buffer = new Uint8Array(initialData).buffer;

                this._queuedChunks.push(buffer);
              }

              this._pdfDataRangeTransport = pdfDataRangeTransport;
              this._isStreamingSupported = !params.disableStream;
              this._isRangeSupported = !params.disableRange;
              this._contentLength = params.length;
              this._fullRequestReader = null;
              this._rangeReaders = [];

              this._pdfDataRangeTransport.addRangeListener(function (begin, chunk) {
                _this40._onReceiveData({
                  begin: begin,
                  chunk: chunk
                });
              });

              this._pdfDataRangeTransport.addProgressListener(function (loaded, total) {
                _this40._onProgress({
                  loaded: loaded,
                  total: total
                });
              });

              this._pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {
                _this40._onReceiveData({
                  chunk: chunk
                });
              });

              this._pdfDataRangeTransport.addProgressiveDoneListener(function () {
                _this40._onProgressiveDone();
              });

              this._pdfDataRangeTransport.transportReady();
            }

            _createClass(PDFDataTransportStream, [{
              key: "_onReceiveData",
              value: function _onReceiveData(args) {
                var buffer = new Uint8Array(args.chunk).buffer;

                if (args.begin === undefined) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader._enqueue(buffer);
                  } else {
                    this._queuedChunks.push(buffer);
                  }
                } else {
                  var found = this._rangeReaders.some(function (rangeReader) {
                    if (rangeReader._begin !== args.begin) {
                      return false;
                    }

                    rangeReader._enqueue(buffer);

                    return true;
                  });

                  (0, _util.assert)(found);
                }
              }
            }, {
              key: "_onProgress",
              value: function _onProgress(evt) {
                if (evt.total === undefined) {
                  var firstReader = this._rangeReaders[0];

                  if (firstReader && firstReader.onProgress) {
                    firstReader.onProgress({
                      loaded: evt.loaded
                    });
                  }
                } else {
                  var fullReader = this._fullRequestReader;

                  if (fullReader && fullReader.onProgress) {
                    fullReader.onProgress({
                      loaded: evt.loaded,
                      total: evt.total
                    });
                  }
                }
              }
            }, {
              key: "_onProgressiveDone",
              value: function _onProgressiveDone() {
                if (this._fullRequestReader) {
                  this._fullRequestReader.progressiveDone();
                }

                this._progressiveDone = true;
              }
            }, {
              key: "_removeRangeReader",
              value: function _removeRangeReader(reader) {
                var i = this._rangeReaders.indexOf(reader);

                if (i >= 0) {
                  this._rangeReaders.splice(i, 1);
                }
              }
            }, {
              key: "getFullReader",
              value: function getFullReader() {
                (0, _util.assert)(!this._fullRequestReader);
                var queuedChunks = this._queuedChunks;
                this._queuedChunks = null;
                return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone);
              }
            }, {
              key: "getRangeReader",
              value: function getRangeReader(begin, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }

                var reader = new PDFDataTransportStreamRangeReader(this, begin, end);

                this._pdfDataRangeTransport.requestDataRange(begin, end);

                this._rangeReaders.push(reader);

                return reader;
              }
            }, {
              key: "cancelAllRequests",
              value: function cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }

                var readers = this._rangeReaders.slice(0);

                readers.forEach(function (rangeReader) {
                  rangeReader.cancel(reason);
                });

                this._pdfDataRangeTransport.abort();
              }
            }, {
              key: "_progressiveDataLength",
              get: function get() {
                return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
              }
            }]);

            return PDFDataTransportStream;
          }();

          exports.PDFDataTransportStream = PDFDataTransportStream;

          var PDFDataTransportStreamReader = /*#__PURE__*/function () {
            function PDFDataTransportStreamReader(stream, queuedChunks) {
              var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

              _classCallCheck(this, PDFDataTransportStreamReader);

              this._stream = stream;
              this._done = progressiveDone || false;
              this._filename = null;
              this._queuedChunks = queuedChunks || [];
              this._loaded = 0;

              var _iterator10 = _createForOfIteratorHelper(this._queuedChunks),
                  _step10;

              try {
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  var chunk = _step10.value;
                  this._loaded += chunk.byteLength;
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }

              this._requests = [];
              this._headersReady = Promise.resolve();
              stream._fullRequestReader = this;
              this.onProgress = null;
            }

            _createClass(PDFDataTransportStreamReader, [{
              key: "_enqueue",
              value: function _enqueue(chunk) {
                if (this._done) {
                  return;
                }

                if (this._requests.length > 0) {
                  var requestCapability = this._requests.shift();

                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._queuedChunks.push(chunk);
                }

                this._loaded += chunk.byteLength;
              }
            }, {
              key: "read",
              value: function () {
                var _read = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
                  var chunk, requestCapability;
                  return regeneratorRuntime.wrap(function _callee7$(_context7) {
                    while (1) {
                      switch (_context7.prev = _context7.next) {
                        case 0:
                          if (!(this._queuedChunks.length > 0)) {
                            _context7.next = 3;
                            break;
                          }

                          chunk = this._queuedChunks.shift();
                          return _context7.abrupt("return", {
                            value: chunk,
                            done: false
                          });

                        case 3:
                          if (!this._done) {
                            _context7.next = 5;
                            break;
                          }

                          return _context7.abrupt("return", {
                            value: undefined,
                            done: true
                          });

                        case 5:
                          requestCapability = (0, _util.createPromiseCapability)();

                          this._requests.push(requestCapability);

                          return _context7.abrupt("return", requestCapability.promise);

                        case 8:
                        case "end":
                          return _context7.stop();
                      }
                    }
                  }, _callee7, this);
                }));

                function read() {
                  return _read.apply(this, arguments);
                }

                return read;
              }()
            }, {
              key: "cancel",
              value: function cancel(reason) {
                this._done = true;

                this._requests.forEach(function (requestCapability) {
                  requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                });

                this._requests = [];
              }
            }, {
              key: "progressiveDone",
              value: function progressiveDone() {
                if (this._done) {
                  return;
                }

                this._done = true;
              }
            }, {
              key: "headersReady",
              get: function get() {
                return this._headersReady;
              }
            }, {
              key: "filename",
              get: function get() {
                return this._filename;
              }
            }, {
              key: "isRangeSupported",
              get: function get() {
                return this._stream._isRangeSupported;
              }
            }, {
              key: "isStreamingSupported",
              get: function get() {
                return this._stream._isStreamingSupported;
              }
            }, {
              key: "contentLength",
              get: function get() {
                return this._stream._contentLength;
              }
            }]);

            return PDFDataTransportStreamReader;
          }();

          var PDFDataTransportStreamRangeReader = /*#__PURE__*/function () {
            function PDFDataTransportStreamRangeReader(stream, begin, end) {
              _classCallCheck(this, PDFDataTransportStreamRangeReader);

              this._stream = stream;
              this._begin = begin;
              this._end = end;
              this._queuedChunk = null;
              this._requests = [];
              this._done = false;
              this.onProgress = null;
            }

            _createClass(PDFDataTransportStreamRangeReader, [{
              key: "_enqueue",
              value: function _enqueue(chunk) {
                if (this._done) {
                  return;
                }

                if (this._requests.length === 0) {
                  this._queuedChunk = chunk;
                } else {
                  var requestsCapability = this._requests.shift();

                  requestsCapability.resolve({
                    value: chunk,
                    done: false
                  });

                  this._requests.forEach(function (requestCapability) {
                    requestCapability.resolve({
                      value: undefined,
                      done: true
                    });
                  });

                  this._requests = [];
                }

                this._done = true;

                this._stream._removeRangeReader(this);
              }
            }, {
              key: "read",
              value: function () {
                var _read2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
                  var chunk, requestCapability;
                  return regeneratorRuntime.wrap(function _callee8$(_context8) {
                    while (1) {
                      switch (_context8.prev = _context8.next) {
                        case 0:
                          if (!this._queuedChunk) {
                            _context8.next = 4;
                            break;
                          }

                          chunk = this._queuedChunk;
                          this._queuedChunk = null;
                          return _context8.abrupt("return", {
                            value: chunk,
                            done: false
                          });

                        case 4:
                          if (!this._done) {
                            _context8.next = 6;
                            break;
                          }

                          return _context8.abrupt("return", {
                            value: undefined,
                            done: true
                          });

                        case 6:
                          requestCapability = (0, _util.createPromiseCapability)();

                          this._requests.push(requestCapability);

                          return _context8.abrupt("return", requestCapability.promise);

                        case 9:
                        case "end":
                          return _context8.stop();
                      }
                    }
                  }, _callee8, this);
                }));

                function read() {
                  return _read2.apply(this, arguments);
                }

                return read;
              }()
            }, {
              key: "cancel",
              value: function cancel(reason) {
                this._done = true;

                this._requests.forEach(function (requestCapability) {
                  requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                });

                this._requests = [];

                this._stream._removeRangeReader(this);
              }
            }, {
              key: "isStreamingSupported",
              get: function get() {
                return false;
              }
            }]);

            return PDFDataTransportStreamRangeReader;
          }();
          /***/

        },
        /* 15 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WebGLContext = void 0;

          var _util = __w_pdfjs_require__(1);

          var WebGLContext = /*#__PURE__*/function () {
            function WebGLContext(_ref26) {
              var _ref26$enable = _ref26.enable,
                  enable = _ref26$enable === void 0 ? false : _ref26$enable;

              _classCallCheck(this, WebGLContext);

              this._enabled = enable === true;
            }

            _createClass(WebGLContext, [{
              key: "composeSMask",
              value: function composeSMask(_ref27) {
                var layer = _ref27.layer,
                    mask = _ref27.mask,
                    properties = _ref27.properties;
                return WebGLUtils.composeSMask(layer, mask, properties);
              }
            }, {
              key: "drawFigures",
              value: function drawFigures(_ref28) {
                var width = _ref28.width,
                    height = _ref28.height,
                    backgroundColor = _ref28.backgroundColor,
                    figures = _ref28.figures,
                    context = _ref28.context;
                return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);
              }
            }, {
              key: "clear",
              value: function clear() {
                WebGLUtils.cleanup();
              }
            }, {
              key: "isEnabled",
              get: function get() {
                var enabled = this._enabled;

                if (enabled) {
                  enabled = WebGLUtils.tryInitGL();
                }

                return (0, _util.shadow)(this, "isEnabled", enabled);
              }
            }]);

            return WebGLContext;
          }();

          exports.WebGLContext = WebGLContext;

          var WebGLUtils = function WebGLUtilsClosure() {
            function loadShader(gl, code, shaderType) {
              var shader = gl.createShader(shaderType);
              gl.shaderSource(shader, code);
              gl.compileShader(shader);
              var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

              if (!compiled) {
                var errorMsg = gl.getShaderInfoLog(shader);
                throw new Error("Error during shader compilation: " + errorMsg);
              }

              return shader;
            }

            function createVertexShader(gl, code) {
              return loadShader(gl, code, gl.VERTEX_SHADER);
            }

            function createFragmentShader(gl, code) {
              return loadShader(gl, code, gl.FRAGMENT_SHADER);
            }

            function createProgram(gl, shaders) {
              var program = gl.createProgram();

              for (var i = 0, ii = shaders.length; i < ii; ++i) {
                gl.attachShader(program, shaders[i]);
              }

              gl.linkProgram(program);
              var linked = gl.getProgramParameter(program, gl.LINK_STATUS);

              if (!linked) {
                var errorMsg = gl.getProgramInfoLog(program);
                throw new Error("Error during program linking: " + errorMsg);
              }

              return program;
            }

            function createTexture(gl, image, textureId) {
              gl.activeTexture(textureId);
              var texture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
              return texture;
            }

            var currentGL, currentCanvas;

            function generateGL() {
              if (currentGL) {
                return;
              }

              currentCanvas = document.createElement("canvas");
              currentGL = currentCanvas.getContext("webgl", {
                premultipliedalpha: false
              });
            }

            var smaskVertexShaderCode = "\
  attribute vec2 a_position;                                    \
  attribute vec2 a_texCoord;                                    \
                                                                \
  uniform vec2 u_resolution;                                    \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_texCoord = a_texCoord;                                    \
  }                                                             ";
            var smaskFragmentShaderCode = "\
  precision mediump float;                                      \
                                                                \
  uniform vec4 u_backdrop;                                      \
  uniform int u_subtype;                                        \
  uniform sampler2D u_image;                                    \
  uniform sampler2D u_mask;                                     \
                                                                \
  varying vec2 v_texCoord;                                      \
                                                                \
  void main() {                                                 \
    vec4 imageColor = texture2D(u_image, v_texCoord);           \
    vec4 maskColor = texture2D(u_mask, v_texCoord);             \
    if (u_backdrop.a > 0.0) {                                   \
      maskColor.rgb = maskColor.rgb * maskColor.a +             \
                      u_backdrop.rgb * (1.0 - maskColor.a);     \
    }                                                           \
    float lum;                                                  \
    if (u_subtype == 0) {                                       \
      lum = maskColor.a;                                        \
    } else {                                                    \
      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \
            maskColor.b * 0.11;                                 \
    }                                                           \
    imageColor.a *= lum;                                        \
    imageColor.rgb *= imageColor.a;                             \
    gl_FragColor = imageColor;                                  \
  }                                                             ";
            var smaskCache = null;

            function initSmaskGL() {
              var canvas, gl;
              generateGL();
              canvas = currentCanvas;
              currentCanvas = null;
              gl = currentGL;
              currentGL = null;
              var vertexShader = createVertexShader(gl, smaskVertexShaderCode);
              var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);
              var program = createProgram(gl, [vertexShader, fragmentShader]);
              gl.useProgram(program);
              var cache = {};
              cache.gl = gl;
              cache.canvas = canvas;
              cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
              cache.positionLocation = gl.getAttribLocation(program, "a_position");
              cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop");
              cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype");
              var texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
              var texLayerLocation = gl.getUniformLocation(program, "u_image");
              var texMaskLocation = gl.getUniformLocation(program, "u_mask");
              var texCoordBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
              gl.enableVertexAttribArray(texCoordLocation);
              gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
              gl.uniform1i(texLayerLocation, 0);
              gl.uniform1i(texMaskLocation, 1);
              smaskCache = cache;
            }

            function composeSMask(layer, mask, properties) {
              var width = layer.width,
                  height = layer.height;

              if (!smaskCache) {
                initSmaskGL();
              }

              var cache = smaskCache,
                  canvas = cache.canvas,
                  gl = cache.gl;
              canvas.width = width;
              canvas.height = height;
              gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
              gl.uniform2f(cache.resolutionLocation, width, height);

              if (properties.backdrop) {
                gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);
              } else {
                gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);
              }

              gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0);
              var texture = createTexture(gl, layer, gl.TEXTURE0);
              var maskTexture = createTexture(gl, mask, gl.TEXTURE1);
              var buffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);
              gl.enableVertexAttribArray(cache.positionLocation);
              gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
              gl.clearColor(0, 0, 0, 0);
              gl.enable(gl.BLEND);
              gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              gl.clear(gl.COLOR_BUFFER_BIT);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              gl.flush();
              gl.deleteTexture(texture);
              gl.deleteTexture(maskTexture);
              gl.deleteBuffer(buffer);
              return canvas;
            }

            var figuresVertexShaderCode = "\
  attribute vec2 a_position;                                    \
  attribute vec3 a_color;                                       \
                                                                \
  uniform vec2 u_resolution;                                    \
  uniform vec2 u_scale;                                         \
  uniform vec2 u_offset;                                        \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    vec2 position = (a_position + u_offset) * u_scale;          \
    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \
                                                                \
    v_color = vec4(a_color / 255.0, 1.0);                       \
  }                                                             ";
            var figuresFragmentShaderCode = "\
  precision mediump float;                                      \
                                                                \
  varying vec4 v_color;                                         \
                                                                \
  void main() {                                                 \
    gl_FragColor = v_color;                                     \
  }                                                             ";
            var figuresCache = null;

            function initFiguresGL() {
              var canvas, gl;
              generateGL();
              canvas = currentCanvas;
              currentCanvas = null;
              gl = currentGL;
              currentGL = null;
              var vertexShader = createVertexShader(gl, figuresVertexShaderCode);
              var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);
              var program = createProgram(gl, [vertexShader, fragmentShader]);
              gl.useProgram(program);
              var cache = {};
              cache.gl = gl;
              cache.canvas = canvas;
              cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");
              cache.scaleLocation = gl.getUniformLocation(program, "u_scale");
              cache.offsetLocation = gl.getUniformLocation(program, "u_offset");
              cache.positionLocation = gl.getAttribLocation(program, "a_position");
              cache.colorLocation = gl.getAttribLocation(program, "a_color");
              figuresCache = cache;
            }

            function drawFigures(width, height, backgroundColor, figures, context) {
              if (!figuresCache) {
                initFiguresGL();
              }

              var cache = figuresCache,
                  canvas = cache.canvas,
                  gl = cache.gl;
              canvas.width = width;
              canvas.height = height;
              gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
              gl.uniform2f(cache.resolutionLocation, width, height);
              var count = 0;
              var i, ii, rows;

              for (i = 0, ii = figures.length; i < ii; i++) {
                switch (figures[i].type) {
                  case "lattice":
                    rows = figures[i].coords.length / figures[i].verticesPerRow | 0;
                    count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;
                    break;

                  case "triangles":
                    count += figures[i].coords.length;
                    break;
                }
              }

              var coords = new Float32Array(count * 2);
              var colors = new Uint8Array(count * 3);
              var coordsMap = context.coords,
                  colorsMap = context.colors;
              var pIndex = 0,
                  cIndex = 0;

              for (i = 0, ii = figures.length; i < ii; i++) {
                var figure = figures[i],
                    ps = figure.coords,
                    cs = figure.colors;

                switch (figure.type) {
                  case "lattice":
                    var cols = figure.verticesPerRow;
                    rows = ps.length / cols | 0;

                    for (var row = 1; row < rows; row++) {
                      var offset = row * cols + 1;

                      for (var col = 1; col < cols; col++, offset++) {
                        coords[pIndex] = coordsMap[ps[offset - cols - 1]];
                        coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];
                        coords[pIndex + 2] = coordsMap[ps[offset - cols]];
                        coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];
                        coords[pIndex + 4] = coordsMap[ps[offset - 1]];
                        coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];
                        colors[cIndex] = colorsMap[cs[offset - cols - 1]];
                        colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];
                        colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];
                        colors[cIndex + 3] = colorsMap[cs[offset - cols]];
                        colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];
                        colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];
                        colors[cIndex + 6] = colorsMap[cs[offset - 1]];
                        colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];
                        colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];
                        coords[pIndex + 6] = coords[pIndex + 2];
                        coords[pIndex + 7] = coords[pIndex + 3];
                        coords[pIndex + 8] = coords[pIndex + 4];
                        coords[pIndex + 9] = coords[pIndex + 5];
                        coords[pIndex + 10] = coordsMap[ps[offset]];
                        coords[pIndex + 11] = coordsMap[ps[offset] + 1];
                        colors[cIndex + 9] = colors[cIndex + 3];
                        colors[cIndex + 10] = colors[cIndex + 4];
                        colors[cIndex + 11] = colors[cIndex + 5];
                        colors[cIndex + 12] = colors[cIndex + 6];
                        colors[cIndex + 13] = colors[cIndex + 7];
                        colors[cIndex + 14] = colors[cIndex + 8];
                        colors[cIndex + 15] = colorsMap[cs[offset]];
                        colors[cIndex + 16] = colorsMap[cs[offset] + 1];
                        colors[cIndex + 17] = colorsMap[cs[offset] + 2];
                        pIndex += 12;
                        cIndex += 18;
                      }
                    }

                    break;

                  case "triangles":
                    for (var j = 0, jj = ps.length; j < jj; j++) {
                      coords[pIndex] = coordsMap[ps[j]];
                      coords[pIndex + 1] = coordsMap[ps[j] + 1];
                      colors[cIndex] = colorsMap[cs[j]];
                      colors[cIndex + 1] = colorsMap[cs[j] + 1];
                      colors[cIndex + 2] = colorsMap[cs[j] + 2];
                      pIndex += 2;
                      cIndex += 3;
                    }

                    break;
                }
              }

              if (backgroundColor) {
                gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);
              } else {
                gl.clearColor(0, 0, 0, 0);
              }

              gl.clear(gl.COLOR_BUFFER_BIT);
              var coordsBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
              gl.enableVertexAttribArray(cache.positionLocation);
              gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);
              var colorsBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
              gl.enableVertexAttribArray(cache.colorLocation);
              gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);
              gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);
              gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);
              gl.drawArrays(gl.TRIANGLES, 0, count);
              gl.flush();
              gl.deleteBuffer(coordsBuffer);
              gl.deleteBuffer(colorsBuffer);
              return canvas;
            }

            return {
              tryInitGL: function tryInitGL() {
                try {
                  generateGL();
                  return !!currentGL;
                } catch (ex) {}

                return false;
              },
              composeSMask: composeSMask,
              drawFigures: drawFigures,
              cleanup: function cleanup() {
                if (smaskCache && smaskCache.canvas) {
                  smaskCache.canvas.width = 0;
                  smaskCache.canvas.height = 0;
                }

                if (figuresCache && figuresCache.canvas) {
                  figuresCache.canvas.width = 0;
                  figuresCache.canvas.height = 0;
                }

                smaskCache = null;
                figuresCache = null;
              }
            };
          }();
          /***/

        },
        /* 16 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.renderTextLayer = void 0;

          var _util = __w_pdfjs_require__(1);

          var renderTextLayer = function renderTextLayerClosure() {
            var MAX_TEXT_DIVS_TO_RENDER = 100000;
            var NonWhitespaceRegexp = /\S/;

            function isAllWhitespace(str) {
              return !NonWhitespaceRegexp.test(str);
            }

            function appendText(task, geom, styles) {
              var textDiv = document.createElement("span");
              var textDivProperties = {
                angle: 0,
                canvasWidth: 0,
                isWhitespace: false,
                originalTransform: null,
                paddingBottom: 0,
                paddingLeft: 0,
                paddingRight: 0,
                paddingTop: 0,
                scale: 1
              };

              task._textDivs.push(textDiv);

              if (isAllWhitespace(geom.str)) {
                textDivProperties.isWhitespace = true;

                task._textDivProperties.set(textDiv, textDivProperties);

                return;
              }

              var tx = _util.Util.transform(task._viewport.transform, geom.transform);

              var angle = Math.atan2(tx[1], tx[0]);
              var style = styles[geom.fontName];

              if (style.vertical) {
                angle += Math.PI / 2;
              }

              var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
              var fontAscent = fontHeight;

              if (style.ascent) {
                fontAscent = style.ascent * fontAscent;
              } else if (style.descent) {
                fontAscent = (1 + style.descent) * fontAscent;
              }

              var left, top;

              if (angle === 0) {
                left = tx[4];
                top = tx[5] - fontAscent;
              } else {
                left = tx[4] + fontAscent * Math.sin(angle);
                top = tx[5] - fontAscent * Math.cos(angle);
              }

              textDiv.style.left = "".concat(left, "px");
              textDiv.style.top = "".concat(top, "px");
              textDiv.style.fontSize = "".concat(fontHeight, "px");
              textDiv.style.fontFamily = style.fontFamily;
              textDiv.textContent = geom.str;

              if (task._fontInspectorEnabled) {
                textDiv.dataset.fontName = geom.fontName;
              }

              if (angle !== 0) {
                textDivProperties.angle = angle * (180 / Math.PI);
              }

              if (geom.str.length > 1) {
                if (style.vertical) {
                  textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                } else {
                  textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                }
              }

              task._textDivProperties.set(textDiv, textDivProperties);

              if (task._textContentStream) {
                task._layoutText(textDiv);
              }

              if (task._enhanceTextSelection) {
                var angleCos = 1,
                    angleSin = 0;

                if (angle !== 0) {
                  angleCos = Math.cos(angle);
                  angleSin = Math.sin(angle);
                }

                var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                var divHeight = fontHeight;
                var m, b;

                if (angle !== 0) {
                  m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                  b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                } else {
                  b = [left, top, left + divWidth, top + divHeight];
                }

                task._bounds.push({
                  left: b[0],
                  top: b[1],
                  right: b[2],
                  bottom: b[3],
                  div: textDiv,
                  size: [divWidth, divHeight],
                  m: m
                });
              }
            }

            function render(task) {
              if (task._canceled) {
                return;
              }

              var textDivs = task._textDivs;
              var capability = task._capability;
              var textDivsLength = textDivs.length;

              if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                task._renderingDone = true;
                capability.resolve();
                return;
              }

              if (!task._textContentStream) {
                for (var i = 0; i < textDivsLength; i++) {
                  task._layoutText(textDivs[i]);
                }
              }

              task._renderingDone = true;
              capability.resolve();
            }

            function expand(task) {
              var bounds = task._bounds;
              var viewport = task._viewport;
              var expanded = expandBounds(viewport.width, viewport.height, bounds);

              for (var i = 0; i < expanded.length; i++) {
                var div = bounds[i].div;

                var divProperties = task._textDivProperties.get(div);

                if (divProperties.angle === 0) {
                  divProperties.paddingLeft = bounds[i].left - expanded[i].left;
                  divProperties.paddingTop = bounds[i].top - expanded[i].top;
                  divProperties.paddingRight = expanded[i].right - bounds[i].right;
                  divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;

                  task._textDivProperties.set(div, divProperties);

                  continue;
                }

                var e = expanded[i],
                    b = bounds[i];
                var m = b.m,
                    c = m[0],
                    s = m[1];
                var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                var ts = new Float64Array(64);
                points.forEach(function (p, i) {
                  var t = _util.Util.applyTransform(p, m);

                  ts[i + 0] = c && (e.left - t[0]) / c;
                  ts[i + 4] = s && (e.top - t[1]) / s;
                  ts[i + 8] = c && (e.right - t[0]) / c;
                  ts[i + 12] = s && (e.bottom - t[1]) / s;
                  ts[i + 16] = s && (e.left - t[0]) / -s;
                  ts[i + 20] = c && (e.top - t[1]) / c;
                  ts[i + 24] = s && (e.right - t[0]) / -s;
                  ts[i + 28] = c && (e.bottom - t[1]) / c;
                  ts[i + 32] = c && (e.left - t[0]) / -c;
                  ts[i + 36] = s && (e.top - t[1]) / -s;
                  ts[i + 40] = c && (e.right - t[0]) / -c;
                  ts[i + 44] = s && (e.bottom - t[1]) / -s;
                  ts[i + 48] = s && (e.left - t[0]) / s;
                  ts[i + 52] = c && (e.top - t[1]) / -c;
                  ts[i + 56] = s && (e.right - t[0]) / s;
                  ts[i + 60] = c && (e.bottom - t[1]) / -c;
                });

                var findPositiveMin = function findPositiveMin(ts, offset, count) {
                  var result = 0;

                  for (var i = 0; i < count; i++) {
                    var t = ts[offset++];

                    if (t > 0) {
                      result = result ? Math.min(t, result) : t;
                    }
                  }

                  return result;
                };

                var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;

                task._textDivProperties.set(div, divProperties);
              }
            }

            function expandBounds(width, height, boxes) {
              var bounds = boxes.map(function (box, i) {
                return {
                  x1: box.left,
                  y1: box.top,
                  x2: box.right,
                  y2: box.bottom,
                  index: i,
                  x1New: undefined,
                  x2New: undefined
                };
              });
              expandBoundsLTR(width, bounds);
              var expanded = new Array(boxes.length);
              bounds.forEach(function (b) {
                var i = b.index;
                expanded[i] = {
                  left: b.x1New,
                  top: 0,
                  right: b.x2New,
                  bottom: 0
                };
              });
              boxes.map(function (box, i) {
                var e = expanded[i],
                    b = bounds[i];
                b.x1 = box.top;
                b.y1 = width - e.right;
                b.x2 = box.bottom;
                b.y2 = width - e.left;
                b.index = i;
                b.x1New = undefined;
                b.x2New = undefined;
              });
              expandBoundsLTR(height, bounds);
              bounds.forEach(function (b) {
                var i = b.index;
                expanded[i].top = b.x1New;
                expanded[i].bottom = b.x2New;
              });
              return expanded;
            }

            function expandBoundsLTR(width, bounds) {
              bounds.sort(function (a, b) {
                return a.x1 - b.x1 || a.index - b.index;
              });
              var fakeBoundary = {
                x1: -Infinity,
                y1: -Infinity,
                x2: 0,
                y2: Infinity,
                index: -1,
                x1New: 0,
                x2New: 0
              };
              var horizon = [{
                start: -Infinity,
                end: Infinity,
                boundary: fakeBoundary
              }];
              bounds.forEach(function (boundary) {
                var i = 0;

                while (i < horizon.length && horizon[i].end <= boundary.y1) {
                  i++;
                }

                var j = horizon.length - 1;

                while (j >= 0 && horizon[j].start >= boundary.y2) {
                  j--;
                }

                var horizonPart, affectedBoundary;
                var q,
                    k,
                    maxXNew = -Infinity;

                for (q = i; q <= j; q++) {
                  horizonPart = horizon[q];
                  affectedBoundary = horizonPart.boundary;
                  var xNew;

                  if (affectedBoundary.x2 > boundary.x1) {
                    xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                  } else if (affectedBoundary.x2New === undefined) {
                    xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                  } else {
                    xNew = affectedBoundary.x2New;
                  }

                  if (xNew > maxXNew) {
                    maxXNew = xNew;
                  }
                }

                boundary.x1New = maxXNew;

                for (q = i; q <= j; q++) {
                  horizonPart = horizon[q];
                  affectedBoundary = horizonPart.boundary;

                  if (affectedBoundary.x2New === undefined) {
                    if (affectedBoundary.x2 > boundary.x1) {
                      if (affectedBoundary.index > boundary.index) {
                        affectedBoundary.x2New = affectedBoundary.x2;
                      }
                    } else {
                      affectedBoundary.x2New = maxXNew;
                    }
                  } else if (affectedBoundary.x2New > maxXNew) {
                    affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                  }
                }

                var changedHorizon = [],
                    lastBoundary = null;

                for (q = i; q <= j; q++) {
                  horizonPart = horizon[q];
                  affectedBoundary = horizonPart.boundary;
                  var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;

                  if (lastBoundary === useBoundary) {
                    changedHorizon[changedHorizon.length - 1].end = horizonPart.end;
                  } else {
                    changedHorizon.push({
                      start: horizonPart.start,
                      end: horizonPart.end,
                      boundary: useBoundary
                    });
                    lastBoundary = useBoundary;
                  }
                }

                if (horizon[i].start < boundary.y1) {
                  changedHorizon[0].start = boundary.y1;
                  changedHorizon.unshift({
                    start: horizon[i].start,
                    end: boundary.y1,
                    boundary: horizon[i].boundary
                  });
                }

                if (boundary.y2 < horizon[j].end) {
                  changedHorizon[changedHorizon.length - 1].end = boundary.y2;
                  changedHorizon.push({
                    start: boundary.y2,
                    end: horizon[j].end,
                    boundary: horizon[j].boundary
                  });
                }

                for (q = i; q <= j; q++) {
                  horizonPart = horizon[q];
                  affectedBoundary = horizonPart.boundary;

                  if (affectedBoundary.x2New !== undefined) {
                    continue;
                  }

                  var used = false;

                  for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                    used = horizon[k].boundary === affectedBoundary;
                  }

                  for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                    used = horizon[k].boundary === affectedBoundary;
                  }

                  for (k = 0; !used && k < changedHorizon.length; k++) {
                    used = changedHorizon[k].boundary === affectedBoundary;
                  }

                  if (!used) {
                    affectedBoundary.x2New = maxXNew;
                  }
                }

                Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
              });
              horizon.forEach(function (horizonPart) {
                var affectedBoundary = horizonPart.boundary;

                if (affectedBoundary.x2New === undefined) {
                  affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
                }
              });
            }

            function TextLayerRenderTask(_ref29) {
              var _this41 = this;

              var textContent = _ref29.textContent,
                  textContentStream = _ref29.textContentStream,
                  container = _ref29.container,
                  viewport = _ref29.viewport,
                  textDivs = _ref29.textDivs,
                  textContentItemsStr = _ref29.textContentItemsStr,
                  enhanceTextSelection = _ref29.enhanceTextSelection;
              this._textContent = textContent;
              this._textContentStream = textContentStream;
              this._container = container;
              this._viewport = viewport;
              this._textDivs = textDivs || [];
              this._textContentItemsStr = textContentItemsStr || [];
              this._enhanceTextSelection = !!enhanceTextSelection;
              this._fontInspectorEnabled = !!(globalThis.FontInspector && globalThis.FontInspector.enabled);
              this._reader = null;
              this._layoutTextLastFontSize = null;
              this._layoutTextLastFontFamily = null;
              this._layoutTextCtx = null;
              this._textDivProperties = new WeakMap();
              this._renderingDone = false;
              this._canceled = false;
              this._capability = (0, _util.createPromiseCapability)();
              this._renderTimer = null;
              this._bounds = [];

              this._capability.promise["finally"](function () {
                if (_this41._layoutTextCtx) {
                  _this41._layoutTextCtx.canvas.width = 0;
                  _this41._layoutTextCtx.canvas.height = 0;
                  _this41._layoutTextCtx = null;
                }
              })["catch"](function () {});
            }

            TextLayerRenderTask.prototype = {
              get promise() {
                return this._capability.promise;
              },

              cancel: function TextLayer_cancel() {
                this._canceled = true;

                if (this._reader) {
                  this._reader.cancel(new _util.AbortException("TextLayer task cancelled."));

                  this._reader = null;
                }

                if (this._renderTimer !== null) {
                  clearTimeout(this._renderTimer);
                  this._renderTimer = null;
                }

                this._capability.reject(new Error("TextLayer task cancelled."));
              },
              _processItems: function _processItems(items, styleCache) {
                for (var i = 0, len = items.length; i < len; i++) {
                  this._textContentItemsStr.push(items[i].str);

                  appendText(this, items[i], styleCache);
                }
              },
              _layoutText: function _layoutText(textDiv) {
                var textDivProperties = this._textDivProperties.get(textDiv);

                if (textDivProperties.isWhitespace) {
                  return;
                }

                var transform = "";

                if (textDivProperties.canvasWidth !== 0) {
                  var _textDiv$style = textDiv.style,
                      fontSize = _textDiv$style.fontSize,
                      fontFamily = _textDiv$style.fontFamily;

                  if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                    this._layoutTextCtx.font = "".concat(fontSize, " ").concat(fontFamily);
                    this._layoutTextLastFontSize = fontSize;
                    this._layoutTextLastFontFamily = fontFamily;
                  }

                  var _this$_layoutTextCtx$ = this._layoutTextCtx.measureText(textDiv.textContent),
                      width = _this$_layoutTextCtx$.width;

                  if (width > 0) {
                    textDivProperties.scale = textDivProperties.canvasWidth / width;
                    transform = "scaleX(".concat(textDivProperties.scale, ")");
                  }
                }

                if (textDivProperties.angle !== 0) {
                  transform = "rotate(".concat(textDivProperties.angle, "deg) ").concat(transform);
                }

                if (transform.length > 0) {
                  if (this._enhanceTextSelection) {
                    textDivProperties.originalTransform = transform;
                  }

                  textDiv.style.transform = transform;
                }

                this._textDivProperties.set(textDiv, textDivProperties);

                this._container.appendChild(textDiv);
              },
              _render: function TextLayer_render(timeout) {
                var _this42 = this;

                var capability = (0, _util.createPromiseCapability)();
                var styleCache = Object.create(null);
                var canvas = document.createElement("canvas");
                canvas.mozOpaque = true;
                this._layoutTextCtx = canvas.getContext("2d", {
                  alpha: false
                });

                if (this._textContent) {
                  var textItems = this._textContent.items;
                  var textStyles = this._textContent.styles;

                  this._processItems(textItems, textStyles);

                  capability.resolve();
                } else if (this._textContentStream) {
                  var pump = function pump() {
                    _this42._reader.read().then(function (_ref30) {
                      var value = _ref30.value,
                          done = _ref30.done;

                      if (done) {
                        capability.resolve();
                        return;
                      }

                      Object.assign(styleCache, value.styles);

                      _this42._processItems(value.items, styleCache);

                      pump();
                    }, capability.reject);
                  };

                  this._reader = this._textContentStream.getReader();
                  pump();
                } else {
                  throw new Error('Neither "textContent" nor "textContentStream"' + " parameters specified.");
                }

                capability.promise.then(function () {
                  styleCache = null;

                  if (!timeout) {
                    render(_this42);
                  } else {
                    _this42._renderTimer = setTimeout(function () {
                      render(_this42);
                      _this42._renderTimer = null;
                    }, timeout);
                  }
                }, this._capability.reject);
              },
              expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {
                if (!this._enhanceTextSelection || !this._renderingDone) {
                  return;
                }

                if (this._bounds !== null) {
                  expand(this);
                  this._bounds = null;
                }

                var transformBuf = [],
                    paddingBuf = [];

                for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
                  var div = this._textDivs[i];

                  var divProps = this._textDivProperties.get(div);

                  if (divProps.isWhitespace) {
                    continue;
                  }

                  if (expandDivs) {
                    transformBuf.length = 0;
                    paddingBuf.length = 0;

                    if (divProps.originalTransform) {
                      transformBuf.push(divProps.originalTransform);
                    }

                    if (divProps.paddingTop > 0) {
                      paddingBuf.push("".concat(divProps.paddingTop, "px"));
                      transformBuf.push("translateY(".concat(-divProps.paddingTop, "px)"));
                    } else {
                      paddingBuf.push(0);
                    }

                    if (divProps.paddingRight > 0) {
                      paddingBuf.push("".concat(divProps.paddingRight / divProps.scale, "px"));
                    } else {
                      paddingBuf.push(0);
                    }

                    if (divProps.paddingBottom > 0) {
                      paddingBuf.push("".concat(divProps.paddingBottom, "px"));
                    } else {
                      paddingBuf.push(0);
                    }

                    if (divProps.paddingLeft > 0) {
                      paddingBuf.push("".concat(divProps.paddingLeft / divProps.scale, "px"));
                      transformBuf.push("translateX(".concat(-divProps.paddingLeft / divProps.scale, "px)"));
                    } else {
                      paddingBuf.push(0);
                    }

                    div.style.padding = paddingBuf.join(" ");

                    if (transformBuf.length) {
                      div.style.transform = transformBuf.join(" ");
                    }
                  } else {
                    div.style.padding = null;
                    div.style.transform = divProps.originalTransform;
                  }
                }
              }
            };

            function renderTextLayer(renderParameters) {
              var task = new TextLayerRenderTask({
                textContent: renderParameters.textContent,
                textContentStream: renderParameters.textContentStream,
                container: renderParameters.container,
                viewport: renderParameters.viewport,
                textDivs: renderParameters.textDivs,
                textContentItemsStr: renderParameters.textContentItemsStr,
                enhanceTextSelection: renderParameters.enhanceTextSelection
              });

              task._render(renderParameters.timeout);

              return task;
            }

            return renderTextLayer;
          }();

          exports.renderTextLayer = renderTextLayer;
          /***/
        },
        /* 17 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.AnnotationLayer = void 0;

          var _display_utils = __w_pdfjs_require__(4);

          var _util = __w_pdfjs_require__(1);

          var AnnotationElementFactory = /*#__PURE__*/function () {
            function AnnotationElementFactory() {
              _classCallCheck(this, AnnotationElementFactory);
            }

            _createClass(AnnotationElementFactory, null, [{
              key: "create",
              value: function create(parameters) {
                var subtype = parameters.data.annotationType;

                switch (subtype) {
                  case _util.AnnotationType.LINK:
                    return new LinkAnnotationElement(parameters);

                  case _util.AnnotationType.TEXT:
                    return new TextAnnotationElement(parameters);

                  case _util.AnnotationType.WIDGET:
                    var fieldType = parameters.data.fieldType;

                    switch (fieldType) {
                      case "Tx":
                        return new TextWidgetAnnotationElement(parameters);

                      case "Btn":
                        if (parameters.data.radioButton) {
                          return new RadioButtonWidgetAnnotationElement(parameters);
                        } else if (parameters.data.checkBox) {
                          return new CheckboxWidgetAnnotationElement(parameters);
                        }

                        return new PushButtonWidgetAnnotationElement(parameters);

                      case "Ch":
                        return new ChoiceWidgetAnnotationElement(parameters);
                    }

                    return new WidgetAnnotationElement(parameters);

                  case _util.AnnotationType.POPUP:
                    return new PopupAnnotationElement(parameters);

                  case _util.AnnotationType.FREETEXT:
                    return new FreeTextAnnotationElement(parameters);

                  case _util.AnnotationType.LINE:
                    return new LineAnnotationElement(parameters);

                  case _util.AnnotationType.SQUARE:
                    return new SquareAnnotationElement(parameters);

                  case _util.AnnotationType.CIRCLE:
                    return new CircleAnnotationElement(parameters);

                  case _util.AnnotationType.POLYLINE:
                    return new PolylineAnnotationElement(parameters);

                  case _util.AnnotationType.CARET:
                    return new CaretAnnotationElement(parameters);

                  case _util.AnnotationType.INK:
                    return new InkAnnotationElement(parameters);

                  case _util.AnnotationType.POLYGON:
                    return new PolygonAnnotationElement(parameters);

                  case _util.AnnotationType.HIGHLIGHT:
                    return new HighlightAnnotationElement(parameters);

                  case _util.AnnotationType.UNDERLINE:
                    return new UnderlineAnnotationElement(parameters);

                  case _util.AnnotationType.SQUIGGLY:
                    return new SquigglyAnnotationElement(parameters);

                  case _util.AnnotationType.STRIKEOUT:
                    return new StrikeOutAnnotationElement(parameters);

                  case _util.AnnotationType.STAMP:
                    return new StampAnnotationElement(parameters);

                  case _util.AnnotationType.FILEATTACHMENT:
                    return new FileAttachmentAnnotationElement(parameters);

                  default:
                    return new AnnotationElement(parameters);
                }
              }
            }]);

            return AnnotationElementFactory;
          }();

          var AnnotationElement = /*#__PURE__*/function () {
            function AnnotationElement(parameters) {
              var isRenderable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var ignoreBorder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

              _classCallCheck(this, AnnotationElement);

              this.isRenderable = isRenderable;
              this.data = parameters.data;
              this.layer = parameters.layer;
              this.page = parameters.page;
              this.viewport = parameters.viewport;
              this.linkService = parameters.linkService;
              this.downloadManager = parameters.downloadManager;
              this.imageResourcesPath = parameters.imageResourcesPath;
              this.renderInteractiveForms = parameters.renderInteractiveForms;
              this.svgFactory = parameters.svgFactory;

              if (isRenderable) {
                this.container = this._createContainer(ignoreBorder);
              }
            }

            _createClass(AnnotationElement, [{
              key: "_createContainer",
              value: function _createContainer() {
                var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                var data = this.data,
                    page = this.page,
                    viewport = this.viewport;
                var container = document.createElement("section");
                var width = data.rect[2] - data.rect[0];
                var height = data.rect[3] - data.rect[1];
                container.setAttribute("data-annotation-id", data.id);

                var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

                container.style.transform = "matrix(".concat(viewport.transform.join(","), ")");
                container.style.transformOrigin = "-".concat(rect[0], "px -").concat(rect[1], "px");

                if (!ignoreBorder && data.borderStyle.width > 0) {
                  container.style.borderWidth = "".concat(data.borderStyle.width, "px");

                  if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
                    width = width - 2 * data.borderStyle.width;
                    height = height - 2 * data.borderStyle.width;
                  }

                  var horizontalRadius = data.borderStyle.horizontalCornerRadius;
                  var verticalRadius = data.borderStyle.verticalCornerRadius;

                  if (horizontalRadius > 0 || verticalRadius > 0) {
                    var radius = "".concat(horizontalRadius, "px / ").concat(verticalRadius, "px");
                    container.style.borderRadius = radius;
                  }

                  switch (data.borderStyle.style) {
                    case _util.AnnotationBorderStyleType.SOLID:
                      container.style.borderStyle = "solid";
                      break;

                    case _util.AnnotationBorderStyleType.DASHED:
                      container.style.borderStyle = "dashed";
                      break;

                    case _util.AnnotationBorderStyleType.BEVELED:
                      (0, _util.warn)("Unimplemented border style: beveled");
                      break;

                    case _util.AnnotationBorderStyleType.INSET:
                      (0, _util.warn)("Unimplemented border style: inset");
                      break;

                    case _util.AnnotationBorderStyleType.UNDERLINE:
                      container.style.borderBottomStyle = "solid";
                      break;

                    default:
                      break;
                  }

                  if (data.color) {
                    container.style.borderColor = _util.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
                  } else {
                    container.style.borderWidth = 0;
                  }
                }

                container.style.left = "".concat(rect[0], "px");
                container.style.top = "".concat(rect[1], "px");
                container.style.width = "".concat(width, "px");
                container.style.height = "".concat(height, "px");
                return container;
              }
            }, {
              key: "_createPopup",
              value: function _createPopup(container, trigger, data) {
                if (!trigger) {
                  trigger = document.createElement("div");
                  trigger.style.height = container.style.height;
                  trigger.style.width = container.style.width;
                  container.appendChild(trigger);
                }

                var popupElement = new PopupElement({
                  container: container,
                  trigger: trigger,
                  color: data.color,
                  title: data.title,
                  modificationDate: data.modificationDate,
                  contents: data.contents,
                  hideWrapper: true
                });
                var popup = popupElement.render();
                popup.style.left = container.style.width;
                container.appendChild(popup);
              }
            }, {
              key: "render",
              value: function render() {
                (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
              }
            }]);

            return AnnotationElement;
          }();

          var LinkAnnotationElement = /*#__PURE__*/function (_AnnotationElement) {
            _inherits(LinkAnnotationElement, _AnnotationElement);

            var _super11 = _createSuper(LinkAnnotationElement);

            function LinkAnnotationElement(parameters) {
              _classCallCheck(this, LinkAnnotationElement);

              var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action);
              return _super11.call(this, parameters, isRenderable);
            }

            _createClass(LinkAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "linkAnnotation";
                var data = this.data,
                    linkService = this.linkService;
                var link = document.createElement("a");

                if (data.url) {
                  (0, _display_utils.addLinkAttributes)(link, {
                    url: data.url,
                    target: data.newWindow ? _display_utils.LinkTarget.BLANK : linkService.externalLinkTarget,
                    rel: linkService.externalLinkRel,
                    enabled: linkService.externalLinkEnabled
                  });
                } else if (data.action) {
                  this._bindNamedAction(link, data.action);
                } else {
                  this._bindLink(link, data.dest);
                }

                this.container.appendChild(link);
                return this.container;
              }
            }, {
              key: "_bindLink",
              value: function _bindLink(link, destination) {
                var _this43 = this;

                link.href = this.linkService.getDestinationHash(destination);

                link.onclick = function () {
                  if (destination) {
                    _this43.linkService.navigateTo(destination);
                  }

                  return false;
                };

                if (destination) {
                  link.className = "internalLink";
                }
              }
            }, {
              key: "_bindNamedAction",
              value: function _bindNamedAction(link, action) {
                var _this44 = this;

                link.href = this.linkService.getAnchorUrl("");

                link.onclick = function () {
                  _this44.linkService.executeNamedAction(action);

                  return false;
                };

                link.className = "internalLink";
              }
            }]);

            return LinkAnnotationElement;
          }(AnnotationElement);

          var TextAnnotationElement = /*#__PURE__*/function (_AnnotationElement2) {
            _inherits(TextAnnotationElement, _AnnotationElement2);

            var _super12 = _createSuper(TextAnnotationElement);

            function TextAnnotationElement(parameters) {
              _classCallCheck(this, TextAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              return _super12.call(this, parameters, isRenderable);
            }

            _createClass(TextAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "textAnnotation";
                var image = document.createElement("img");
                image.style.height = this.container.style.height;
                image.style.width = this.container.style.width;
                image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                image.alt = "[{{type}} Annotation]";
                image.dataset.l10nId = "text_annotation_type";
                image.dataset.l10nArgs = JSON.stringify({
                  type: this.data.name
                });

                if (!this.data.hasPopup) {
                  this._createPopup(this.container, image, this.data);
                }

                this.container.appendChild(image);
                return this.container;
              }
            }]);

            return TextAnnotationElement;
          }(AnnotationElement);

          var WidgetAnnotationElement = /*#__PURE__*/function (_AnnotationElement3) {
            _inherits(WidgetAnnotationElement, _AnnotationElement3);

            var _super13 = _createSuper(WidgetAnnotationElement);

            function WidgetAnnotationElement() {
              _classCallCheck(this, WidgetAnnotationElement);

              return _super13.apply(this, arguments);
            }

            _createClass(WidgetAnnotationElement, [{
              key: "render",
              value: function render() {
                return this.container;
              }
            }]);

            return WidgetAnnotationElement;
          }(AnnotationElement);

          var TextWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem) {
            _inherits(TextWidgetAnnotationElement, _WidgetAnnotationElem);

            var _super14 = _createSuper(TextWidgetAnnotationElement);

            function TextWidgetAnnotationElement(parameters) {
              _classCallCheck(this, TextWidgetAnnotationElement);

              var isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
              return _super14.call(this, parameters, isRenderable);
            }

            _createClass(TextWidgetAnnotationElement, [{
              key: "render",
              value: function render() {
                var TEXT_ALIGNMENT = ["left", "center", "right"];
                this.container.className = "textWidgetAnnotation";
                var element = null;

                if (this.renderInteractiveForms) {
                  if (this.data.multiLine) {
                    element = document.createElement("textarea");
                    element.textContent = this.data.fieldValue;
                  } else {
                    element = document.createElement("input");
                    element.type = "text";
                    element.setAttribute("value", this.data.fieldValue);
                  }

                  element.disabled = this.data.readOnly;

                  if (this.data.maxLen !== null) {
                    element.maxLength = this.data.maxLen;
                  }

                  if (this.data.comb) {
                    var fieldWidth = this.data.rect[2] - this.data.rect[0];
                    var combWidth = fieldWidth / this.data.maxLen;
                    element.classList.add("comb");
                    element.style.letterSpacing = "calc(".concat(combWidth, "px - 1ch)");
                  }
                } else {
                  element = document.createElement("div");
                  element.textContent = this.data.fieldValue;
                  element.style.verticalAlign = "middle";
                  element.style.display = "table-cell";
                  var font = null;

                  if (this.data.fontRefName && this.page.commonObjs.has(this.data.fontRefName)) {
                    font = this.page.commonObjs.get(this.data.fontRefName);
                  }

                  this._setTextStyle(element, font);
                }

                if (this.data.textAlignment !== null) {
                  element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                }

                this.container.appendChild(element);
                return this.container;
              }
            }, {
              key: "_setTextStyle",
              value: function _setTextStyle(element, font) {
                var style = element.style;
                style.fontSize = "".concat(this.data.fontSize, "px");
                style.direction = this.data.fontDirection < 0 ? "rtl" : "ltr";

                if (!font) {
                  return;
                }

                var bold = "normal";

                if (font.black) {
                  bold = "900";
                } else if (font.bold) {
                  bold = "bold";
                }

                style.fontWeight = bold;
                style.fontStyle = font.italic ? "italic" : "normal";
                var fontFamily = font.loadedName ? "\"".concat(font.loadedName, "\", ") : "";
                var fallbackName = font.fallbackName || "Helvetica, sans-serif";
                style.fontFamily = fontFamily + fallbackName;
              }
            }]);

            return TextWidgetAnnotationElement;
          }(WidgetAnnotationElement);

          var CheckboxWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem2) {
            _inherits(CheckboxWidgetAnnotationElement, _WidgetAnnotationElem2);

            var _super15 = _createSuper(CheckboxWidgetAnnotationElement);

            function CheckboxWidgetAnnotationElement(parameters) {
              _classCallCheck(this, CheckboxWidgetAnnotationElement);

              return _super15.call(this, parameters, parameters.renderInteractiveForms);
            }

            _createClass(CheckboxWidgetAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "buttonWidgetAnnotation checkBox";
                var element = document.createElement("input");
                element.disabled = this.data.readOnly;
                element.type = "checkbox";

                if (this.data.fieldValue && this.data.fieldValue !== "Off") {
                  element.setAttribute("checked", true);
                }

                this.container.appendChild(element);
                return this.container;
              }
            }]);

            return CheckboxWidgetAnnotationElement;
          }(WidgetAnnotationElement);

          var RadioButtonWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem3) {
            _inherits(RadioButtonWidgetAnnotationElement, _WidgetAnnotationElem3);

            var _super16 = _createSuper(RadioButtonWidgetAnnotationElement);

            function RadioButtonWidgetAnnotationElement(parameters) {
              _classCallCheck(this, RadioButtonWidgetAnnotationElement);

              return _super16.call(this, parameters, parameters.renderInteractiveForms);
            }

            _createClass(RadioButtonWidgetAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "buttonWidgetAnnotation radioButton";
                var element = document.createElement("input");
                element.disabled = this.data.readOnly;
                element.type = "radio";
                element.name = this.data.fieldName;

                if (this.data.fieldValue === this.data.buttonValue) {
                  element.setAttribute("checked", true);
                }

                this.container.appendChild(element);
                return this.container;
              }
            }]);

            return RadioButtonWidgetAnnotationElement;
          }(WidgetAnnotationElement);

          var PushButtonWidgetAnnotationElement = /*#__PURE__*/function (_LinkAnnotationElemen) {
            _inherits(PushButtonWidgetAnnotationElement, _LinkAnnotationElemen);

            var _super17 = _createSuper(PushButtonWidgetAnnotationElement);

            function PushButtonWidgetAnnotationElement() {
              _classCallCheck(this, PushButtonWidgetAnnotationElement);

              return _super17.apply(this, arguments);
            }

            _createClass(PushButtonWidgetAnnotationElement, [{
              key: "render",
              value: function render() {
                var container = _get(_getPrototypeOf(PushButtonWidgetAnnotationElement.prototype), "render", this).call(this);

                container.className = "buttonWidgetAnnotation pushButton";
                return container;
              }
            }]);

            return PushButtonWidgetAnnotationElement;
          }(LinkAnnotationElement);

          var ChoiceWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem4) {
            _inherits(ChoiceWidgetAnnotationElement, _WidgetAnnotationElem4);

            var _super18 = _createSuper(ChoiceWidgetAnnotationElement);

            function ChoiceWidgetAnnotationElement(parameters) {
              _classCallCheck(this, ChoiceWidgetAnnotationElement);

              return _super18.call(this, parameters, parameters.renderInteractiveForms);
            }

            _createClass(ChoiceWidgetAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "choiceWidgetAnnotation";
                var selectElement = document.createElement("select");
                selectElement.disabled = this.data.readOnly;

                if (!this.data.combo) {
                  selectElement.size = this.data.options.length;

                  if (this.data.multiSelect) {
                    selectElement.multiple = true;
                  }
                }

                var _iterator11 = _createForOfIteratorHelper(this.data.options),
                    _step11;

                try {
                  for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                    var option = _step11.value;
                    var optionElement = document.createElement("option");
                    optionElement.textContent = option.displayValue;
                    optionElement.value = option.exportValue;

                    if (this.data.fieldValue.includes(option.displayValue)) {
                      optionElement.setAttribute("selected", true);
                    }

                    selectElement.appendChild(optionElement);
                  }
                } catch (err) {
                  _iterator11.e(err);
                } finally {
                  _iterator11.f();
                }

                this.container.appendChild(selectElement);
                return this.container;
              }
            }]);

            return ChoiceWidgetAnnotationElement;
          }(WidgetAnnotationElement);

          var PopupAnnotationElement = /*#__PURE__*/function (_AnnotationElement4) {
            _inherits(PopupAnnotationElement, _AnnotationElement4);

            var _super19 = _createSuper(PopupAnnotationElement);

            function PopupAnnotationElement(parameters) {
              _classCallCheck(this, PopupAnnotationElement);

              var isRenderable = !!(parameters.data.title || parameters.data.contents);
              return _super19.call(this, parameters, isRenderable);
            }

            _createClass(PopupAnnotationElement, [{
              key: "render",
              value: function render() {
                var IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                this.container.className = "popupAnnotation";

                if (IGNORE_TYPES.includes(this.data.parentType)) {
                  return this.container;
                }

                var selector = "[data-annotation-id=\"".concat(this.data.parentId, "\"]");
                var parentElement = this.layer.querySelector(selector);

                if (!parentElement) {
                  return this.container;
                }

                var popup = new PopupElement({
                  container: this.container,
                  trigger: parentElement,
                  color: this.data.color,
                  title: this.data.title,
                  modificationDate: this.data.modificationDate,
                  contents: this.data.contents
                });
                var parentLeft = parseFloat(parentElement.style.left);
                var parentWidth = parseFloat(parentElement.style.width);
                this.container.style.transformOrigin = "-".concat(parentLeft + parentWidth, "px -").concat(parentElement.style.top);
                this.container.style.left = "".concat(parentLeft + parentWidth, "px");
                this.container.appendChild(popup.render());
                return this.container;
              }
            }]);

            return PopupAnnotationElement;
          }(AnnotationElement);

          var PopupElement = /*#__PURE__*/function () {
            function PopupElement(parameters) {
              _classCallCheck(this, PopupElement);

              this.container = parameters.container;
              this.trigger = parameters.trigger;
              this.color = parameters.color;
              this.title = parameters.title;
              this.modificationDate = parameters.modificationDate;
              this.contents = parameters.contents;
              this.hideWrapper = parameters.hideWrapper || false;
              this.pinned = false;
            }

            _createClass(PopupElement, [{
              key: "render",
              value: function render() {
                var BACKGROUND_ENLIGHT = 0.7;
                var wrapper = document.createElement("div");
                wrapper.className = "popupWrapper";
                this.hideElement = this.hideWrapper ? wrapper : this.container;
                this.hideElement.setAttribute("hidden", true);
                var popup = document.createElement("div");
                popup.className = "popup";
                var color = this.color;

                if (color) {
                  var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                  var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                  var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                  popup.style.backgroundColor = _util.Util.makeCssRgb(r | 0, g | 0, b | 0);
                }

                var title = document.createElement("h1");
                title.textContent = this.title;
                popup.appendChild(title);

                var dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);

                if (dateObject) {
                  var modificationDate = document.createElement("span");
                  modificationDate.textContent = "{{date}}, {{time}}";
                  modificationDate.dataset.l10nId = "annotation_date_string";
                  modificationDate.dataset.l10nArgs = JSON.stringify({
                    date: dateObject.toLocaleDateString(),
                    time: dateObject.toLocaleTimeString()
                  });
                  popup.appendChild(modificationDate);
                }

                var contents = this._formatContents(this.contents);

                popup.appendChild(contents);
                this.trigger.addEventListener("click", this._toggle.bind(this));
                this.trigger.addEventListener("mouseover", this._show.bind(this, false));
                this.trigger.addEventListener("mouseout", this._hide.bind(this, false));
                popup.addEventListener("click", this._hide.bind(this, true));
                wrapper.appendChild(popup);
                return wrapper;
              }
            }, {
              key: "_formatContents",
              value: function _formatContents(contents) {
                var p = document.createElement("p");
                var lines = contents.split(/(?:\r\n?|\n)/);

                for (var i = 0, ii = lines.length; i < ii; ++i) {
                  var line = lines[i];
                  p.appendChild(document.createTextNode(line));

                  if (i < ii - 1) {
                    p.appendChild(document.createElement("br"));
                  }
                }

                return p;
              }
            }, {
              key: "_toggle",
              value: function _toggle() {
                if (this.pinned) {
                  this._hide(true);
                } else {
                  this._show(true);
                }
              }
            }, {
              key: "_show",
              value: function _show() {
                var pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                if (pin) {
                  this.pinned = true;
                }

                if (this.hideElement.hasAttribute("hidden")) {
                  this.hideElement.removeAttribute("hidden");
                  this.container.style.zIndex += 1;
                }
              }
            }, {
              key: "_hide",
              value: function _hide() {
                var unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

                if (unpin) {
                  this.pinned = false;
                }

                if (!this.hideElement.hasAttribute("hidden") && !this.pinned) {
                  this.hideElement.setAttribute("hidden", true);
                  this.container.style.zIndex -= 1;
                }
              }
            }]);

            return PopupElement;
          }();

          var FreeTextAnnotationElement = /*#__PURE__*/function (_AnnotationElement5) {
            _inherits(FreeTextAnnotationElement, _AnnotationElement5);

            var _super20 = _createSuper(FreeTextAnnotationElement);

            function FreeTextAnnotationElement(parameters) {
              _classCallCheck(this, FreeTextAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              return _super20.call(this, parameters, isRenderable, true);
            }

            _createClass(FreeTextAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "freeTextAnnotation";

                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }

                return this.container;
              }
            }]);

            return FreeTextAnnotationElement;
          }(AnnotationElement);

          var LineAnnotationElement = /*#__PURE__*/function (_AnnotationElement6) {
            _inherits(LineAnnotationElement, _AnnotationElement6);

            var _super21 = _createSuper(LineAnnotationElement);

            function LineAnnotationElement(parameters) {
              _classCallCheck(this, LineAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              return _super21.call(this, parameters, isRenderable, true);
            }

            _createClass(LineAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "lineAnnotation";
                var data = this.data;
                var width = data.rect[2] - data.rect[0];
                var height = data.rect[3] - data.rect[1];
                var svg = this.svgFactory.create(width, height);
                var line = this.svgFactory.createElement("svg:line");
                line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                line.setAttribute("stroke-width", data.borderStyle.width || 1);
                line.setAttribute("stroke", "transparent");
                svg.appendChild(line);
                this.container.append(svg);

                this._createPopup(this.container, line, data);

                return this.container;
              }
            }]);

            return LineAnnotationElement;
          }(AnnotationElement);

          var SquareAnnotationElement = /*#__PURE__*/function (_AnnotationElement7) {
            _inherits(SquareAnnotationElement, _AnnotationElement7);

            var _super22 = _createSuper(SquareAnnotationElement);

            function SquareAnnotationElement(parameters) {
              _classCallCheck(this, SquareAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              return _super22.call(this, parameters, isRenderable, true);
            }

            _createClass(SquareAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "squareAnnotation";
                var data = this.data;
                var width = data.rect[2] - data.rect[0];
                var height = data.rect[3] - data.rect[1];
                var svg = this.svgFactory.create(width, height);
                var borderWidth = data.borderStyle.width;
                var square = this.svgFactory.createElement("svg:rect");
                square.setAttribute("x", borderWidth / 2);
                square.setAttribute("y", borderWidth / 2);
                square.setAttribute("width", width - borderWidth);
                square.setAttribute("height", height - borderWidth);
                square.setAttribute("stroke-width", borderWidth || 1);
                square.setAttribute("stroke", "transparent");
                square.setAttribute("fill", "none");
                svg.appendChild(square);
                this.container.append(svg);

                this._createPopup(this.container, square, data);

                return this.container;
              }
            }]);

            return SquareAnnotationElement;
          }(AnnotationElement);

          var CircleAnnotationElement = /*#__PURE__*/function (_AnnotationElement8) {
            _inherits(CircleAnnotationElement, _AnnotationElement8);

            var _super23 = _createSuper(CircleAnnotationElement);

            function CircleAnnotationElement(parameters) {
              _classCallCheck(this, CircleAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              return _super23.call(this, parameters, isRenderable, true);
            }

            _createClass(CircleAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "circleAnnotation";
                var data = this.data;
                var width = data.rect[2] - data.rect[0];
                var height = data.rect[3] - data.rect[1];
                var svg = this.svgFactory.create(width, height);
                var borderWidth = data.borderStyle.width;
                var circle = this.svgFactory.createElement("svg:ellipse");
                circle.setAttribute("cx", width / 2);
                circle.setAttribute("cy", height / 2);
                circle.setAttribute("rx", width / 2 - borderWidth / 2);
                circle.setAttribute("ry", height / 2 - borderWidth / 2);
                circle.setAttribute("stroke-width", borderWidth || 1);
                circle.setAttribute("stroke", "transparent");
                circle.setAttribute("fill", "none");
                svg.appendChild(circle);
                this.container.append(svg);

                this._createPopup(this.container, circle, data);

                return this.container;
              }
            }]);

            return CircleAnnotationElement;
          }(AnnotationElement);

          var PolylineAnnotationElement = /*#__PURE__*/function (_AnnotationElement9) {
            _inherits(PolylineAnnotationElement, _AnnotationElement9);

            var _super24 = _createSuper(PolylineAnnotationElement);

            function PolylineAnnotationElement(parameters) {
              var _this45;

              _classCallCheck(this, PolylineAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              _this45 = _super24.call(this, parameters, isRenderable, true);
              _this45.containerClassName = "polylineAnnotation";
              _this45.svgElementName = "svg:polyline";
              return _this45;
            }

            _createClass(PolylineAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = this.containerClassName;
                var data = this.data;
                var width = data.rect[2] - data.rect[0];
                var height = data.rect[3] - data.rect[1];
                var svg = this.svgFactory.create(width, height);
                var points = [];

                var _iterator12 = _createForOfIteratorHelper(data.vertices),
                    _step12;

                try {
                  for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                    var coordinate = _step12.value;
                    var x = coordinate.x - data.rect[0];
                    var y = data.rect[3] - coordinate.y;
                    points.push(x + "," + y);
                  }
                } catch (err) {
                  _iterator12.e(err);
                } finally {
                  _iterator12.f();
                }

                points = points.join(" ");
                var polyline = this.svgFactory.createElement(this.svgElementName);
                polyline.setAttribute("points", points);
                polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                polyline.setAttribute("stroke", "transparent");
                polyline.setAttribute("fill", "none");
                svg.appendChild(polyline);
                this.container.append(svg);

                this._createPopup(this.container, polyline, data);

                return this.container;
              }
            }]);

            return PolylineAnnotationElement;
          }(AnnotationElement);

          var PolygonAnnotationElement = /*#__PURE__*/function (_PolylineAnnotationEl) {
            _inherits(PolygonAnnotationElement, _PolylineAnnotationEl);

            var _super25 = _createSuper(PolygonAnnotationElement);

            function PolygonAnnotationElement(parameters) {
              var _this46;

              _classCallCheck(this, PolygonAnnotationElement);

              _this46 = _super25.call(this, parameters);
              _this46.containerClassName = "polygonAnnotation";
              _this46.svgElementName = "svg:polygon";
              return _this46;
            }

            return PolygonAnnotationElement;
          }(PolylineAnnotationElement);

          var CaretAnnotationElement = /*#__PURE__*/function (_AnnotationElement10) {
            _inherits(CaretAnnotationElement, _AnnotationElement10);

            var _super26 = _createSuper(CaretAnnotationElement);

            function CaretAnnotationElement(parameters) {
              _classCallCheck(this, CaretAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              return _super26.call(this, parameters, isRenderable, true);
            }

            _createClass(CaretAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "caretAnnotation";

                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }

                return this.container;
              }
            }]);

            return CaretAnnotationElement;
          }(AnnotationElement);

          var InkAnnotationElement = /*#__PURE__*/function (_AnnotationElement11) {
            _inherits(InkAnnotationElement, _AnnotationElement11);

            var _super27 = _createSuper(InkAnnotationElement);

            function InkAnnotationElement(parameters) {
              var _this47;

              _classCallCheck(this, InkAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              _this47 = _super27.call(this, parameters, isRenderable, true);
              _this47.containerClassName = "inkAnnotation";
              _this47.svgElementName = "svg:polyline";
              return _this47;
            }

            _createClass(InkAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = this.containerClassName;
                var data = this.data;
                var width = data.rect[2] - data.rect[0];
                var height = data.rect[3] - data.rect[1];
                var svg = this.svgFactory.create(width, height);

                var _iterator13 = _createForOfIteratorHelper(data.inkLists),
                    _step13;

                try {
                  for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                    var inkList = _step13.value;
                    var points = [];

                    var _iterator14 = _createForOfIteratorHelper(inkList),
                        _step14;

                    try {
                      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                        var coordinate = _step14.value;
                        var x = coordinate.x - data.rect[0];
                        var y = data.rect[3] - coordinate.y;
                        points.push("".concat(x, ",").concat(y));
                      }
                    } catch (err) {
                      _iterator14.e(err);
                    } finally {
                      _iterator14.f();
                    }

                    points = points.join(" ");
                    var polyline = this.svgFactory.createElement(this.svgElementName);
                    polyline.setAttribute("points", points);
                    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                    polyline.setAttribute("stroke", "transparent");
                    polyline.setAttribute("fill", "none");

                    this._createPopup(this.container, polyline, data);

                    svg.appendChild(polyline);
                  }
                } catch (err) {
                  _iterator13.e(err);
                } finally {
                  _iterator13.f();
                }

                this.container.append(svg);
                return this.container;
              }
            }]);

            return InkAnnotationElement;
          }(AnnotationElement);

          var HighlightAnnotationElement = /*#__PURE__*/function (_AnnotationElement12) {
            _inherits(HighlightAnnotationElement, _AnnotationElement12);

            var _super28 = _createSuper(HighlightAnnotationElement);

            function HighlightAnnotationElement(parameters) {
              _classCallCheck(this, HighlightAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              return _super28.call(this, parameters, isRenderable, true);
            }

            _createClass(HighlightAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "highlightAnnotation";

                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }

                return this.container;
              }
            }]);

            return HighlightAnnotationElement;
          }(AnnotationElement);

          var UnderlineAnnotationElement = /*#__PURE__*/function (_AnnotationElement13) {
            _inherits(UnderlineAnnotationElement, _AnnotationElement13);

            var _super29 = _createSuper(UnderlineAnnotationElement);

            function UnderlineAnnotationElement(parameters) {
              _classCallCheck(this, UnderlineAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              return _super29.call(this, parameters, isRenderable, true);
            }

            _createClass(UnderlineAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "underlineAnnotation";

                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }

                return this.container;
              }
            }]);

            return UnderlineAnnotationElement;
          }(AnnotationElement);

          var SquigglyAnnotationElement = /*#__PURE__*/function (_AnnotationElement14) {
            _inherits(SquigglyAnnotationElement, _AnnotationElement14);

            var _super30 = _createSuper(SquigglyAnnotationElement);

            function SquigglyAnnotationElement(parameters) {
              _classCallCheck(this, SquigglyAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              return _super30.call(this, parameters, isRenderable, true);
            }

            _createClass(SquigglyAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "squigglyAnnotation";

                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }

                return this.container;
              }
            }]);

            return SquigglyAnnotationElement;
          }(AnnotationElement);

          var StrikeOutAnnotationElement = /*#__PURE__*/function (_AnnotationElement15) {
            _inherits(StrikeOutAnnotationElement, _AnnotationElement15);

            var _super31 = _createSuper(StrikeOutAnnotationElement);

            function StrikeOutAnnotationElement(parameters) {
              _classCallCheck(this, StrikeOutAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              return _super31.call(this, parameters, isRenderable, true);
            }

            _createClass(StrikeOutAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "strikeoutAnnotation";

                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }

                return this.container;
              }
            }]);

            return StrikeOutAnnotationElement;
          }(AnnotationElement);

          var StampAnnotationElement = /*#__PURE__*/function (_AnnotationElement16) {
            _inherits(StampAnnotationElement, _AnnotationElement16);

            var _super32 = _createSuper(StampAnnotationElement);

            function StampAnnotationElement(parameters) {
              _classCallCheck(this, StampAnnotationElement);

              var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);
              return _super32.call(this, parameters, isRenderable, true);
            }

            _createClass(StampAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "stampAnnotation";

                if (!this.data.hasPopup) {
                  this._createPopup(this.container, null, this.data);
                }

                return this.container;
              }
            }]);

            return StampAnnotationElement;
          }(AnnotationElement);

          var FileAttachmentAnnotationElement = /*#__PURE__*/function (_AnnotationElement17) {
            _inherits(FileAttachmentAnnotationElement, _AnnotationElement17);

            var _super33 = _createSuper(FileAttachmentAnnotationElement);

            function FileAttachmentAnnotationElement(parameters) {
              var _this48;

              _classCallCheck(this, FileAttachmentAnnotationElement);

              _this48 = _super33.call(this, parameters, true);
              var _this48$data$file = _this48.data.file,
                  filename = _this48$data$file.filename,
                  content = _this48$data$file.content;
              _this48.filename = (0, _display_utils.getFilenameFromUrl)(filename);
              _this48.content = content;

              if (_this48.linkService.eventBus) {
                _this48.linkService.eventBus.dispatch("fileattachmentannotation", {
                  source: _assertThisInitialized(_this48),
                  id: (0, _util.stringToPDFString)(filename),
                  filename: filename,
                  content: content
                });
              }

              return _this48;
            }

            _createClass(FileAttachmentAnnotationElement, [{
              key: "render",
              value: function render() {
                this.container.className = "fileAttachmentAnnotation";
                var trigger = document.createElement("div");
                trigger.style.height = this.container.style.height;
                trigger.style.width = this.container.style.width;
                trigger.addEventListener("dblclick", this._download.bind(this));

                if (!this.data.hasPopup && (this.data.title || this.data.contents)) {
                  this._createPopup(this.container, trigger, this.data);
                }

                this.container.appendChild(trigger);
                return this.container;
              }
            }, {
              key: "_download",
              value: function _download() {
                if (!this.downloadManager) {
                  (0, _util.warn)("Download cannot be started due to unavailable download manager");
                  return;
                }

                this.downloadManager.downloadData(this.content, this.filename, "");
              }
            }]);

            return FileAttachmentAnnotationElement;
          }(AnnotationElement);

          var AnnotationLayer = /*#__PURE__*/function () {
            function AnnotationLayer() {
              _classCallCheck(this, AnnotationLayer);
            }

            _createClass(AnnotationLayer, null, [{
              key: "render",
              value: function render(parameters) {
                var sortedAnnotations = [],
                    popupAnnotations = [];

                var _iterator15 = _createForOfIteratorHelper(parameters.annotations),
                    _step15;

                try {
                  for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                    var _data4 = _step15.value;

                    if (!_data4) {
                      continue;
                    }

                    if (_data4.annotationType === _util.AnnotationType.POPUP) {
                      popupAnnotations.push(_data4);
                      continue;
                    }

                    sortedAnnotations.push(_data4);
                  }
                } catch (err) {
                  _iterator15.e(err);
                } finally {
                  _iterator15.f();
                }

                if (popupAnnotations.length) {
                  sortedAnnotations.push.apply(sortedAnnotations, popupAnnotations);
                }

                for (var _i7 = 0, _sortedAnnotations = sortedAnnotations; _i7 < _sortedAnnotations.length; _i7++) {
                  var data = _sortedAnnotations[_i7];
                  var element = AnnotationElementFactory.create({
                    data: data,
                    layer: parameters.div,
                    page: parameters.page,
                    viewport: parameters.viewport,
                    linkService: parameters.linkService,
                    downloadManager: parameters.downloadManager,
                    imageResourcesPath: parameters.imageResourcesPath || "",
                    renderInteractiveForms: parameters.renderInteractiveForms || false,
                    svgFactory: new _display_utils.DOMSVGFactory()
                  });

                  if (element.isRenderable) {
                    parameters.div.appendChild(element.render());
                  }
                }
              }
            }, {
              key: "update",
              value: function update(parameters) {
                var _iterator16 = _createForOfIteratorHelper(parameters.annotations),
                    _step16;

                try {
                  for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                    var data = _step16.value;
                    var element = parameters.div.querySelector("[data-annotation-id=\"".concat(data.id, "\"]"));

                    if (element) {
                      element.style.transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
                    }
                  }
                } catch (err) {
                  _iterator16.e(err);
                } finally {
                  _iterator16.f();
                }

                parameters.div.removeAttribute("hidden");
              }
            }]);

            return AnnotationLayer;
          }();

          exports.AnnotationLayer = AnnotationLayer;
          /***/
        },
        /* 18 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SVGGraphics = void 0;

          var _util = __w_pdfjs_require__(1);

          var _display_utils = __w_pdfjs_require__(4);

          var _is_node = __w_pdfjs_require__(7);

          var SVGGraphics = function SVGGraphics() {
            throw new Error("Not implemented: SVGGraphics");
          };

          exports.SVGGraphics = SVGGraphics;
          {
            var opListToTree = function opListToTree(opList) {
              var opTree = [];
              var tmp = [];

              var _iterator17 = _createForOfIteratorHelper(opList),
                  _step17;

              try {
                for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                  var opListElement = _step17.value;

                  if (opListElement.fn === "save") {
                    opTree.push({
                      fnId: 92,
                      fn: "group",
                      items: []
                    });
                    tmp.push(opTree);
                    opTree = opTree[opTree.length - 1].items;
                    continue;
                  }

                  if (opListElement.fn === "restore") {
                    opTree = tmp.pop();
                  } else {
                    opTree.push(opListElement);
                  }
                }
              } catch (err) {
                _iterator17.e(err);
              } finally {
                _iterator17.f();
              }

              return opTree;
            };

            var pf = function pf(value) {
              if (Number.isInteger(value)) {
                return value.toString();
              }

              var s = value.toFixed(10);
              var i = s.length - 1;

              if (s[i] !== "0") {
                return s;
              }

              do {
                i--;
              } while (s[i] === "0");

              return s.substring(0, s[i] === "." ? i : i + 1);
            };

            var pm = function pm(m) {
              if (m[4] === 0 && m[5] === 0) {
                if (m[1] === 0 && m[2] === 0) {
                  if (m[0] === 1 && m[3] === 1) {
                    return "";
                  }

                  return "scale(".concat(pf(m[0]), " ").concat(pf(m[3]), ")");
                }

                if (m[0] === m[3] && m[1] === -m[2]) {
                  var a = Math.acos(m[0]) * 180 / Math.PI;
                  return "rotate(".concat(pf(a), ")");
                }
              } else {
                if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                  return "translate(".concat(pf(m[4]), " ").concat(pf(m[5]), ")");
                }
              }

              return "matrix(".concat(pf(m[0]), " ").concat(pf(m[1]), " ").concat(pf(m[2]), " ").concat(pf(m[3]), " ").concat(pf(m[4]), " ") + "".concat(pf(m[5]), ")");
            };

            var SVG_DEFAULTS = {
              fontStyle: "normal",
              fontWeight: "normal",
              fillColor: "#000000"
            };
            var XML_NS = "http://www.w3.org/XML/1998/namespace";
            var XLINK_NS = "http://www.w3.org/1999/xlink";
            var LINE_CAP_STYLES = ["butt", "round", "square"];
            var LINE_JOIN_STYLES = ["miter", "round", "bevel"];

            var convertImgDataToPng = function () {
              var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
              var CHUNK_WRAPPER_SIZE = 12;
              var crcTable = new Int32Array(256);

              for (var i = 0; i < 256; i++) {
                var c = i;

                for (var h = 0; h < 8; h++) {
                  if (c & 1) {
                    c = 0xedb88320 ^ c >> 1 & 0x7fffffff;
                  } else {
                    c = c >> 1 & 0x7fffffff;
                  }
                }

                crcTable[i] = c;
              }

              function crc32(data, start, end) {
                var crc = -1;

                for (var _i8 = start; _i8 < end; _i8++) {
                  var a = (crc ^ data[_i8]) & 0xff;
                  var b = crcTable[a];
                  crc = crc >>> 8 ^ b;
                }

                return crc ^ -1;
              }

              function writePngChunk(type, body, data, offset) {
                var p = offset;
                var len = body.length;
                data[p] = len >> 24 & 0xff;
                data[p + 1] = len >> 16 & 0xff;
                data[p + 2] = len >> 8 & 0xff;
                data[p + 3] = len & 0xff;
                p += 4;
                data[p] = type.charCodeAt(0) & 0xff;
                data[p + 1] = type.charCodeAt(1) & 0xff;
                data[p + 2] = type.charCodeAt(2) & 0xff;
                data[p + 3] = type.charCodeAt(3) & 0xff;
                p += 4;
                data.set(body, p);
                p += body.length;
                var crc = crc32(data, offset + 4, p);
                data[p] = crc >> 24 & 0xff;
                data[p + 1] = crc >> 16 & 0xff;
                data[p + 2] = crc >> 8 & 0xff;
                data[p + 3] = crc & 0xff;
              }

              function adler32(data, start, end) {
                var a = 1;
                var b = 0;

                for (var _i9 = start; _i9 < end; ++_i9) {
                  a = (a + (data[_i9] & 0xff)) % 65521;
                  b = (b + a) % 65521;
                }

                return b << 16 | a;
              }

              function deflateSync(literals) {
                if (!_is_node.isNodeJS) {
                  return deflateSyncUncompressed(literals);
                }

                try {
                  var input;

                  if (parseInt(process.versions.node) >= 8) {
                    input = literals;
                  } else {
                    input = Buffer.from(literals);
                  }

                  var output = __webpack_require__(
                  /*! zlib */
                  4).deflateSync(input, {
                    level: 9
                  });

                  return output instanceof Uint8Array ? output : new Uint8Array(output);
                } catch (e) {
                  (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                }

                return deflateSyncUncompressed(literals);
              }

              function deflateSyncUncompressed(literals) {
                var len = literals.length;
                var maxBlockLength = 0xffff;
                var deflateBlocks = Math.ceil(len / maxBlockLength);
                var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
                var pi = 0;
                idat[pi++] = 0x78;
                idat[pi++] = 0x9c;
                var pos = 0;

                while (len > maxBlockLength) {
                  idat[pi++] = 0x00;
                  idat[pi++] = 0xff;
                  idat[pi++] = 0xff;
                  idat[pi++] = 0x00;
                  idat[pi++] = 0x00;
                  idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                  pi += maxBlockLength;
                  pos += maxBlockLength;
                  len -= maxBlockLength;
                }

                idat[pi++] = 0x01;
                idat[pi++] = len & 0xff;
                idat[pi++] = len >> 8 & 0xff;
                idat[pi++] = ~len & 0xffff & 0xff;
                idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
                idat.set(literals.subarray(pos), pi);
                pi += literals.length - pos;
                var adler = adler32(literals, 0, literals.length);
                idat[pi++] = adler >> 24 & 0xff;
                idat[pi++] = adler >> 16 & 0xff;
                idat[pi++] = adler >> 8 & 0xff;
                idat[pi++] = adler & 0xff;
                return idat;
              }

              function encode(imgData, kind, forceDataSchema, isMask) {
                var width = imgData.width;
                var height = imgData.height;
                var bitDepth, colorType, lineSize;
                var bytes = imgData.data;

                switch (kind) {
                  case _util.ImageKind.GRAYSCALE_1BPP:
                    colorType = 0;
                    bitDepth = 1;
                    lineSize = width + 7 >> 3;
                    break;

                  case _util.ImageKind.RGB_24BPP:
                    colorType = 2;
                    bitDepth = 8;
                    lineSize = width * 3;
                    break;

                  case _util.ImageKind.RGBA_32BPP:
                    colorType = 6;
                    bitDepth = 8;
                    lineSize = width * 4;
                    break;

                  default:
                    throw new Error("invalid format");
                }

                var literals = new Uint8Array((1 + lineSize) * height);
                var offsetLiterals = 0,
                    offsetBytes = 0;

                for (var y = 0; y < height; ++y) {
                  literals[offsetLiterals++] = 0;
                  literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                  offsetBytes += lineSize;
                  offsetLiterals += lineSize;
                }

                if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
                  offsetLiterals = 0;

                  for (var _y = 0; _y < height; _y++) {
                    offsetLiterals++;

                    for (var _i10 = 0; _i10 < lineSize; _i10++) {
                      literals[offsetLiterals++] ^= 0xff;
                    }
                  }
                }

                var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
                var idat = deflateSync(literals);
                var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                var data = new Uint8Array(pngLength);
                var offset = 0;
                data.set(PNG_HEADER, offset);
                offset += PNG_HEADER.length;
                writePngChunk("IHDR", ihdr, data, offset);
                offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                writePngChunk("IDATA", idat, data, offset);
                offset += CHUNK_WRAPPER_SIZE + idat.length;
                writePngChunk("IEND", new Uint8Array(0), data, offset);
                return (0, _util.createObjectURL)(data, "image/png", forceDataSchema);
              }

              return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
                var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                return encode(imgData, kind, forceDataSchema, isMask);
              };
            }();

            var SVGExtraState = /*#__PURE__*/function () {
              function SVGExtraState() {
                _classCallCheck(this, SVGExtraState);

                this.fontSizeScale = 1;
                this.fontWeight = SVG_DEFAULTS.fontWeight;
                this.fontSize = 0;
                this.textMatrix = _util.IDENTITY_MATRIX;
                this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
                this.leading = 0;
                this.textRenderingMode = _util.TextRenderingMode.FILL;
                this.textMatrixScale = 1;
                this.x = 0;
                this.y = 0;
                this.lineX = 0;
                this.lineY = 0;
                this.charSpacing = 0;
                this.wordSpacing = 0;
                this.textHScale = 1;
                this.textRise = 0;
                this.fillColor = SVG_DEFAULTS.fillColor;
                this.strokeColor = "#000000";
                this.fillAlpha = 1;
                this.strokeAlpha = 1;
                this.lineWidth = 1;
                this.lineJoin = "";
                this.lineCap = "";
                this.miterLimit = 0;
                this.dashArray = [];
                this.dashPhase = 0;
                this.dependencies = [];
                this.activeClipUrl = null;
                this.clipGroup = null;
                this.maskId = "";
              }

              _createClass(SVGExtraState, [{
                key: "clone",
                value: function clone() {
                  return Object.create(this);
                }
              }, {
                key: "setCurrentPoint",
                value: function setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
              }]);

              return SVGExtraState;
            }();

            var clipCount = 0;
            var maskCount = 0;
            var shadingCount = 0;

            exports.SVGGraphics = SVGGraphics = /*#__PURE__*/function () {
              function SVGGraphics(commonObjs, objs, forceDataSchema) {
                _classCallCheck(this, SVGGraphics);

                this.svgFactory = new _display_utils.DOMSVGFactory();
                this.current = new SVGExtraState();
                this.transformMatrix = _util.IDENTITY_MATRIX;
                this.transformStack = [];
                this.extraStack = [];
                this.commonObjs = commonObjs;
                this.objs = objs;
                this.pendingClip = null;
                this.pendingEOFill = false;
                this.embedFonts = false;
                this.embeddedFonts = Object.create(null);
                this.cssStyle = null;
                this.forceDataSchema = !!forceDataSchema;
                this._operatorIdMapping = [];

                for (var op in _util.OPS) {
                  this._operatorIdMapping[_util.OPS[op]] = op;
                }
              }

              _createClass(SVGGraphics, [{
                key: "save",
                value: function save() {
                  this.transformStack.push(this.transformMatrix);
                  var old = this.current;
                  this.extraStack.push(old);
                  this.current = old.clone();
                }
              }, {
                key: "restore",
                value: function restore() {
                  this.transformMatrix = this.transformStack.pop();
                  this.current = this.extraStack.pop();
                  this.pendingClip = null;
                  this.tgrp = null;
                }
              }, {
                key: "group",
                value: function group(items) {
                  this.save();
                  this.executeOpTree(items);
                  this.restore();
                }
              }, {
                key: "loadDependencies",
                value: function loadDependencies(operatorList) {
                  var _this49 = this;

                  var fnArray = operatorList.fnArray;
                  var argsArray = operatorList.argsArray;

                  for (var i = 0, ii = fnArray.length; i < ii; i++) {
                    if (fnArray[i] !== _util.OPS.dependency) {
                      continue;
                    }

                    var _iterator18 = _createForOfIteratorHelper(argsArray[i]),
                        _step18;

                    try {
                      var _loop = function _loop() {
                        var obj = _step18.value;
                        var objsPool = obj.startsWith("g_") ? _this49.commonObjs : _this49.objs;
                        var promise = new Promise(function (resolve) {
                          objsPool.get(obj, resolve);
                        });

                        _this49.current.dependencies.push(promise);
                      };

                      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                        _loop();
                      }
                    } catch (err) {
                      _iterator18.e(err);
                    } finally {
                      _iterator18.f();
                    }
                  }

                  return Promise.all(this.current.dependencies);
                }
              }, {
                key: "transform",
                value: function transform(a, b, c, d, e, f) {
                  var transformMatrix = [a, b, c, d, e, f];
                  this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
                  this.tgrp = null;
                }
              }, {
                key: "getSVG",
                value: function getSVG(operatorList, viewport) {
                  var _this50 = this;

                  this.viewport = viewport;

                  var svgElement = this._initialize(viewport);

                  return this.loadDependencies(operatorList).then(function () {
                    _this50.transformMatrix = _util.IDENTITY_MATRIX;

                    _this50.executeOpTree(_this50.convertOpList(operatorList));

                    return svgElement;
                  });
                }
              }, {
                key: "convertOpList",
                value: function convertOpList(operatorList) {
                  var operatorIdMapping = this._operatorIdMapping;
                  var argsArray = operatorList.argsArray;
                  var fnArray = operatorList.fnArray;
                  var opList = [];

                  for (var i = 0, ii = fnArray.length; i < ii; i++) {
                    var fnId = fnArray[i];
                    opList.push({
                      fnId: fnId,
                      fn: operatorIdMapping[fnId],
                      args: argsArray[i]
                    });
                  }

                  return opListToTree(opList);
                }
              }, {
                key: "executeOpTree",
                value: function executeOpTree(opTree) {
                  var _iterator19 = _createForOfIteratorHelper(opTree),
                      _step19;

                  try {
                    for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                      var opTreeElement = _step19.value;
                      var fn = opTreeElement.fn;
                      var fnId = opTreeElement.fnId;
                      var args = opTreeElement.args;

                      switch (fnId | 0) {
                        case _util.OPS.beginText:
                          this.beginText();
                          break;

                        case _util.OPS.dependency:
                          break;

                        case _util.OPS.setLeading:
                          this.setLeading(args);
                          break;

                        case _util.OPS.setLeadingMoveText:
                          this.setLeadingMoveText(args[0], args[1]);
                          break;

                        case _util.OPS.setFont:
                          this.setFont(args);
                          break;

                        case _util.OPS.showText:
                          this.showText(args[0]);
                          break;

                        case _util.OPS.showSpacedText:
                          this.showText(args[0]);
                          break;

                        case _util.OPS.endText:
                          this.endText();
                          break;

                        case _util.OPS.moveText:
                          this.moveText(args[0], args[1]);
                          break;

                        case _util.OPS.setCharSpacing:
                          this.setCharSpacing(args[0]);
                          break;

                        case _util.OPS.setWordSpacing:
                          this.setWordSpacing(args[0]);
                          break;

                        case _util.OPS.setHScale:
                          this.setHScale(args[0]);
                          break;

                        case _util.OPS.setTextMatrix:
                          this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;

                        case _util.OPS.setTextRise:
                          this.setTextRise(args[0]);
                          break;

                        case _util.OPS.setTextRenderingMode:
                          this.setTextRenderingMode(args[0]);
                          break;

                        case _util.OPS.setLineWidth:
                          this.setLineWidth(args[0]);
                          break;

                        case _util.OPS.setLineJoin:
                          this.setLineJoin(args[0]);
                          break;

                        case _util.OPS.setLineCap:
                          this.setLineCap(args[0]);
                          break;

                        case _util.OPS.setMiterLimit:
                          this.setMiterLimit(args[0]);
                          break;

                        case _util.OPS.setFillRGBColor:
                          this.setFillRGBColor(args[0], args[1], args[2]);
                          break;

                        case _util.OPS.setStrokeRGBColor:
                          this.setStrokeRGBColor(args[0], args[1], args[2]);
                          break;

                        case _util.OPS.setStrokeColorN:
                          this.setStrokeColorN(args);
                          break;

                        case _util.OPS.setFillColorN:
                          this.setFillColorN(args);
                          break;

                        case _util.OPS.shadingFill:
                          this.shadingFill(args[0]);
                          break;

                        case _util.OPS.setDash:
                          this.setDash(args[0], args[1]);
                          break;

                        case _util.OPS.setRenderingIntent:
                          this.setRenderingIntent(args[0]);
                          break;

                        case _util.OPS.setFlatness:
                          this.setFlatness(args[0]);
                          break;

                        case _util.OPS.setGState:
                          this.setGState(args[0]);
                          break;

                        case _util.OPS.fill:
                          this.fill();
                          break;

                        case _util.OPS.eoFill:
                          this.eoFill();
                          break;

                        case _util.OPS.stroke:
                          this.stroke();
                          break;

                        case _util.OPS.fillStroke:
                          this.fillStroke();
                          break;

                        case _util.OPS.eoFillStroke:
                          this.eoFillStroke();
                          break;

                        case _util.OPS.clip:
                          this.clip("nonzero");
                          break;

                        case _util.OPS.eoClip:
                          this.clip("evenodd");
                          break;

                        case _util.OPS.paintSolidColorImageMask:
                          this.paintSolidColorImageMask();
                          break;

                        case _util.OPS.paintJpegXObject:
                          this.paintJpegXObject(args[0], args[1], args[2]);
                          break;

                        case _util.OPS.paintImageXObject:
                          this.paintImageXObject(args[0]);
                          break;

                        case _util.OPS.paintInlineImageXObject:
                          this.paintInlineImageXObject(args[0]);
                          break;

                        case _util.OPS.paintImageMaskXObject:
                          this.paintImageMaskXObject(args[0]);
                          break;

                        case _util.OPS.paintFormXObjectBegin:
                          this.paintFormXObjectBegin(args[0], args[1]);
                          break;

                        case _util.OPS.paintFormXObjectEnd:
                          this.paintFormXObjectEnd();
                          break;

                        case _util.OPS.closePath:
                          this.closePath();
                          break;

                        case _util.OPS.closeStroke:
                          this.closeStroke();
                          break;

                        case _util.OPS.closeFillStroke:
                          this.closeFillStroke();
                          break;

                        case _util.OPS.closeEOFillStroke:
                          this.closeEOFillStroke();
                          break;

                        case _util.OPS.nextLine:
                          this.nextLine();
                          break;

                        case _util.OPS.transform:
                          this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;

                        case _util.OPS.constructPath:
                          this.constructPath(args[0], args[1]);
                          break;

                        case _util.OPS.endPath:
                          this.endPath();
                          break;

                        case 92:
                          this.group(opTreeElement.items);
                          break;

                        default:
                          (0, _util.warn)("Unimplemented operator ".concat(fn));
                          break;
                      }
                    }
                  } catch (err) {
                    _iterator19.e(err);
                  } finally {
                    _iterator19.f();
                  }
                }
              }, {
                key: "setWordSpacing",
                value: function setWordSpacing(wordSpacing) {
                  this.current.wordSpacing = wordSpacing;
                }
              }, {
                key: "setCharSpacing",
                value: function setCharSpacing(charSpacing) {
                  this.current.charSpacing = charSpacing;
                }
              }, {
                key: "nextLine",
                value: function nextLine() {
                  this.moveText(0, this.current.leading);
                }
              }, {
                key: "setTextMatrix",
                value: function setTextMatrix(a, b, c, d, e, f) {
                  var current = this.current;
                  current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
                  current.textMatrixScale = Math.sqrt(a * a + b * b);
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.xcoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtElement.appendChild(current.tspan);
                }
              }, {
                key: "beginText",
                value: function beginText() {
                  var current = this.current;
                  current.x = current.lineX = 0;
                  current.y = current.lineY = 0;
                  current.textMatrix = _util.IDENTITY_MATRIX;
                  current.lineMatrix = _util.IDENTITY_MATRIX;
                  current.textMatrixScale = 1;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.txtElement = this.svgFactory.createElement("svg:text");
                  current.txtgrp = this.svgFactory.createElement("svg:g");
                  current.xcoords = [];
                }
              }, {
                key: "moveText",
                value: function moveText(x, y) {
                  var current = this.current;
                  current.x = current.lineX += x;
                  current.y = current.lineY += y;
                  current.xcoords = [];
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                }
              }, {
                key: "showText",
                value: function showText(glyphs) {
                  var current = this.current;
                  var font = current.font;
                  var fontSize = current.fontSize;

                  if (fontSize === 0) {
                    return;
                  }

                  var charSpacing = current.charSpacing;
                  var wordSpacing = current.wordSpacing;
                  var fontDirection = current.fontDirection;
                  var textHScale = current.textHScale * fontDirection;
                  var vertical = font.vertical;
                  var widthAdvanceScale = fontSize * current.fontMatrix[0];
                  var x = 0;

                  var _iterator20 = _createForOfIteratorHelper(glyphs),
                      _step20;

                  try {
                    for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                      var glyph = _step20.value;

                      if (glyph === null) {
                        x += fontDirection * wordSpacing;
                        continue;
                      } else if ((0, _util.isNum)(glyph)) {
                        x += -glyph * fontSize * 0.001;
                        continue;
                      }

                      var width = glyph.width;
                      var character = glyph.fontChar;
                      var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      var charWidth = width * widthAdvanceScale + spacing * fontDirection;

                      if (!glyph.isInFont && !font.missingFile) {
                        x += charWidth;
                        continue;
                      }

                      current.xcoords.push(current.x + x);
                      current.tspan.textContent += character;
                      x += charWidth;
                    }
                  } catch (err) {
                    _iterator20.e(err);
                  } finally {
                    _iterator20.f();
                  }

                  if (vertical) {
                    current.y -= x * textHScale;
                  } else {
                    current.x += x * textHScale;
                  }

                  current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                  current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));

                  if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                    current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                  }

                  if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                    current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                  }

                  var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

                  if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                    if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                      current.tspan.setAttributeNS(null, "fill", current.fillColor);
                    }

                    if (current.fillAlpha < 1) {
                      current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    }
                  } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
                    current.tspan.setAttributeNS(null, "fill", "transparent");
                  } else {
                    current.tspan.setAttributeNS(null, "fill", "none");
                  }

                  if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                    var lineWidthScale = 1 / (current.textMatrixScale || 1);

                    this._setStrokeAttributes(current.tspan, lineWidthScale);
                  }

                  var textMatrix = current.textMatrix;

                  if (current.textRise !== 0) {
                    textMatrix = textMatrix.slice();
                    textMatrix[5] += current.textRise;
                  }

                  current.txtElement.setAttributeNS(null, "transform", "".concat(pm(textMatrix), " scale(").concat(pf(textHScale), ", -1)"));
                  current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                  current.txtElement.appendChild(current.tspan);
                  current.txtgrp.appendChild(current.txtElement);

                  this._ensureTransformGroup().appendChild(current.txtElement);
                }
              }, {
                key: "setLeadingMoveText",
                value: function setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                }
              }, {
                key: "addFontStyle",
                value: function addFontStyle(fontObj) {
                  if (!this.cssStyle) {
                    this.cssStyle = this.svgFactory.createElement("svg:style");
                    this.cssStyle.setAttributeNS(null, "type", "text/css");
                    this.defs.appendChild(this.cssStyle);
                  }

                  var url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                  this.cssStyle.textContent += "@font-face { font-family: \"".concat(fontObj.loadedName, "\";") + " src: url(".concat(url, "); }\n");
                }
              }, {
                key: "setFont",
                value: function setFont(details) {
                  var current = this.current;
                  var fontObj = this.commonObjs.get(details[0]);
                  var size = details[1];
                  current.font = fontObj;

                  if (this.embedFonts && fontObj.data && !this.embeddedFonts[fontObj.loadedName]) {
                    this.addFontStyle(fontObj);
                    this.embeddedFonts[fontObj.loadedName] = fontObj;
                  }

                  current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;
                  var bold = "normal";

                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }

                  var italic = fontObj.italic ? "italic" : "normal";

                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }

                  current.fontSize = size;
                  current.fontFamily = fontObj.loadedName;
                  current.fontWeight = bold;
                  current.fontStyle = italic;
                  current.tspan = this.svgFactory.createElement("svg:tspan");
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  current.xcoords = [];
                }
              }, {
                key: "endText",
                value: function endText() {
                  var current = this.current;

                  if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement && current.txtElement.hasChildNodes()) {
                    current.element = current.txtElement;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
              }, {
                key: "setLineWidth",
                value: function setLineWidth(width) {
                  if (width > 0) {
                    this.current.lineWidth = width;
                  }
                }
              }, {
                key: "setLineCap",
                value: function setLineCap(style) {
                  this.current.lineCap = LINE_CAP_STYLES[style];
                }
              }, {
                key: "setLineJoin",
                value: function setLineJoin(style) {
                  this.current.lineJoin = LINE_JOIN_STYLES[style];
                }
              }, {
                key: "setMiterLimit",
                value: function setMiterLimit(limit) {
                  this.current.miterLimit = limit;
                }
              }, {
                key: "setStrokeAlpha",
                value: function setStrokeAlpha(strokeAlpha) {
                  this.current.strokeAlpha = strokeAlpha;
                }
              }, {
                key: "setStrokeRGBColor",
                value: function setStrokeRGBColor(r, g, b) {
                  this.current.strokeColor = _util.Util.makeCssRgb(r, g, b);
                }
              }, {
                key: "setFillAlpha",
                value: function setFillAlpha(fillAlpha) {
                  this.current.fillAlpha = fillAlpha;
                }
              }, {
                key: "setFillRGBColor",
                value: function setFillRGBColor(r, g, b) {
                  this.current.fillColor = _util.Util.makeCssRgb(r, g, b);
                  this.current.tspan = this.svgFactory.createElement("svg:tspan");
                  this.current.xcoords = [];
                }
              }, {
                key: "setStrokeColorN",
                value: function setStrokeColorN(args) {
                  this.current.strokeColor = this._makeColorN_Pattern(args);
                }
              }, {
                key: "setFillColorN",
                value: function setFillColorN(args) {
                  this.current.fillColor = this._makeColorN_Pattern(args);
                }
              }, {
                key: "shadingFill",
                value: function shadingFill(args) {
                  var width = this.viewport.width;
                  var height = this.viewport.height;

                  var inv = _util.Util.inverseTransform(this.transformMatrix);

                  var bl = _util.Util.applyTransform([0, 0], inv);

                  var br = _util.Util.applyTransform([0, height], inv);

                  var ul = _util.Util.applyTransform([width, 0], inv);

                  var ur = _util.Util.applyTransform([width, height], inv);

                  var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                  var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                  var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                  var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                  var rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", x0);
                  rect.setAttributeNS(null, "y", y0);
                  rect.setAttributeNS(null, "width", x1 - x0);
                  rect.setAttributeNS(null, "height", y1 - y0);
                  rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));

                  this._ensureTransformGroup().appendChild(rect);
                }
              }, {
                key: "_makeColorN_Pattern",
                value: function _makeColorN_Pattern(args) {
                  if (args[0] === "TilingPattern") {
                    return this._makeTilingPattern(args);
                  }

                  return this._makeShadingPattern(args);
                }
              }, {
                key: "_makeTilingPattern",
                value: function _makeTilingPattern(args) {
                  var color = args[1];
                  var operatorList = args[2];
                  var matrix = args[3] || _util.IDENTITY_MATRIX;

                  var _args$ = _slicedToArray(args[4], 4),
                      x0 = _args$[0],
                      y0 = _args$[1],
                      x1 = _args$[2],
                      y1 = _args$[3];

                  var xstep = args[5];
                  var ystep = args[6];
                  var paintType = args[7];
                  var tilingId = "shading".concat(shadingCount++);

                  var _util$Util$applyTrans = _util.Util.applyTransform([x0, y0], matrix),
                      _util$Util$applyTrans2 = _slicedToArray(_util$Util$applyTrans, 2),
                      tx0 = _util$Util$applyTrans2[0],
                      ty0 = _util$Util$applyTrans2[1];

                  var _util$Util$applyTrans3 = _util.Util.applyTransform([x1, y1], matrix),
                      _util$Util$applyTrans4 = _slicedToArray(_util$Util$applyTrans3, 2),
                      tx1 = _util$Util$applyTrans4[0],
                      ty1 = _util$Util$applyTrans4[1];

                  var _util$Util$singularVa = _util.Util.singularValueDecompose2dScale(matrix),
                      _util$Util$singularVa2 = _slicedToArray(_util$Util$singularVa, 2),
                      xscale = _util$Util$singularVa2[0],
                      yscale = _util$Util$singularVa2[1];

                  var txstep = xstep * xscale;
                  var tystep = ystep * yscale;
                  var tiling = this.svgFactory.createElement("svg:pattern");
                  tiling.setAttributeNS(null, "id", tilingId);
                  tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                  tiling.setAttributeNS(null, "width", txstep);
                  tiling.setAttributeNS(null, "height", tystep);
                  tiling.setAttributeNS(null, "x", "".concat(tx0));
                  tiling.setAttributeNS(null, "y", "".concat(ty0));
                  var svg = this.svg;
                  var transformMatrix = this.transformMatrix;
                  var fillColor = this.current.fillColor;
                  var strokeColor = this.current.strokeColor;
                  var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                  this.svg = bbox;
                  this.transformMatrix = matrix;

                  if (paintType === 2) {
                    var _util$Util;

                    var cssColor = (_util$Util = _util.Util).makeCssRgb.apply(_util$Util, _toConsumableArray(color));

                    this.current.fillColor = cssColor;
                    this.current.strokeColor = cssColor;
                  }

                  this.executeOpTree(this.convertOpList(operatorList));
                  this.svg = svg;
                  this.transformMatrix = transformMatrix;
                  this.current.fillColor = fillColor;
                  this.current.strokeColor = strokeColor;
                  tiling.appendChild(bbox.childNodes[0]);
                  this.defs.appendChild(tiling);
                  return "url(#".concat(tilingId, ")");
                }
              }, {
                key: "_makeShadingPattern",
                value: function _makeShadingPattern(args) {
                  switch (args[0]) {
                    case "RadialAxial":
                      var shadingId = "shading".concat(shadingCount++);
                      var colorStops = args[3];
                      var gradient;

                      switch (args[1]) {
                        case "axial":
                          var point0 = args[4];
                          var point1 = args[5];
                          gradient = this.svgFactory.createElement("svg:linearGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "x1", point0[0]);
                          gradient.setAttributeNS(null, "y1", point0[1]);
                          gradient.setAttributeNS(null, "x2", point1[0]);
                          gradient.setAttributeNS(null, "y2", point1[1]);
                          break;

                        case "radial":
                          var focalPoint = args[4];
                          var circlePoint = args[5];
                          var focalRadius = args[6];
                          var circleRadius = args[7];
                          gradient = this.svgFactory.createElement("svg:radialGradient");
                          gradient.setAttributeNS(null, "id", shadingId);
                          gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                          gradient.setAttributeNS(null, "cx", circlePoint[0]);
                          gradient.setAttributeNS(null, "cy", circlePoint[1]);
                          gradient.setAttributeNS(null, "r", circleRadius);
                          gradient.setAttributeNS(null, "fx", focalPoint[0]);
                          gradient.setAttributeNS(null, "fy", focalPoint[1]);
                          gradient.setAttributeNS(null, "fr", focalRadius);
                          break;

                        default:
                          throw new Error("Unknown RadialAxial type: ".concat(args[1]));
                      }

                      var _iterator21 = _createForOfIteratorHelper(colorStops),
                          _step21;

                      try {
                        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                          var colorStop = _step21.value;
                          var stop = this.svgFactory.createElement("svg:stop");
                          stop.setAttributeNS(null, "offset", colorStop[0]);
                          stop.setAttributeNS(null, "stop-color", colorStop[1]);
                          gradient.appendChild(stop);
                        }
                      } catch (err) {
                        _iterator21.e(err);
                      } finally {
                        _iterator21.f();
                      }

                      this.defs.appendChild(gradient);
                      return "url(#".concat(shadingId, ")");

                    case "Mesh":
                      (0, _util.warn)("Unimplemented pattern Mesh");
                      return null;

                    case "Dummy":
                      return "hotpink";

                    default:
                      throw new Error("Unknown IR type: ".concat(args[0]));
                  }
                }
              }, {
                key: "setDash",
                value: function setDash(dashArray, dashPhase) {
                  this.current.dashArray = dashArray;
                  this.current.dashPhase = dashPhase;
                }
              }, {
                key: "constructPath",
                value: function constructPath(ops, args) {
                  var current = this.current;
                  var x = current.x,
                      y = current.y;
                  var d = [];
                  var j = 0;

                  var _iterator22 = _createForOfIteratorHelper(ops),
                      _step22;

                  try {
                    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                      var op = _step22.value;

                      switch (op | 0) {
                        case _util.OPS.rectangle:
                          x = args[j++];
                          y = args[j++];
                          var width = args[j++];
                          var height = args[j++];
                          var xw = x + width;
                          var yh = y + height;
                          d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                          break;

                        case _util.OPS.moveTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("M", pf(x), pf(y));
                          break;

                        case _util.OPS.lineTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("L", pf(x), pf(y));
                          break;

                        case _util.OPS.curveTo:
                          x = args[j + 4];
                          y = args[j + 5];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                          j += 6;
                          break;

                        case _util.OPS.curveTo2:
                          d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                          x = args[j + 2];
                          y = args[j + 3];
                          j += 4;
                          break;

                        case _util.OPS.curveTo3:
                          x = args[j + 2];
                          y = args[j + 3];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                          j += 4;
                          break;

                        case _util.OPS.closePath:
                          d.push("Z");
                          break;
                      }
                    }
                  } catch (err) {
                    _iterator22.e(err);
                  } finally {
                    _iterator22.f();
                  }

                  d = d.join(" ");

                  if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
                    d = current.path.getAttributeNS(null, "d") + d;
                  } else {
                    current.path = this.svgFactory.createElement("svg:path");

                    this._ensureTransformGroup().appendChild(current.path);
                  }

                  current.path.setAttributeNS(null, "d", d);
                  current.path.setAttributeNS(null, "fill", "none");
                  current.element = current.path;
                  current.setCurrentPoint(x, y);
                }
              }, {
                key: "endPath",
                value: function endPath() {
                  var current = this.current;
                  current.path = null;

                  if (!this.pendingClip) {
                    return;
                  }

                  if (!current.element) {
                    this.pendingClip = null;
                    return;
                  }

                  var clipId = "clippath".concat(clipCount++);
                  var clipPath = this.svgFactory.createElement("svg:clipPath");
                  clipPath.setAttributeNS(null, "id", clipId);
                  clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                  var clipElement = current.element.cloneNode(true);

                  if (this.pendingClip === "evenodd") {
                    clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                  } else {
                    clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                  }

                  this.pendingClip = null;
                  clipPath.appendChild(clipElement);
                  this.defs.appendChild(clipPath);

                  if (current.activeClipUrl) {
                    current.clipGroup = null;
                    this.extraStack.forEach(function (prev) {
                      prev.clipGroup = null;
                    });
                    clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                  }

                  current.activeClipUrl = "url(#".concat(clipId, ")");
                  this.tgrp = null;
                }
              }, {
                key: "clip",
                value: function clip(type) {
                  this.pendingClip = type;
                }
              }, {
                key: "closePath",
                value: function closePath() {
                  var current = this.current;

                  if (current.path) {
                    var d = "".concat(current.path.getAttributeNS(null, "d"), "Z");
                    current.path.setAttributeNS(null, "d", d);
                  }
                }
              }, {
                key: "setLeading",
                value: function setLeading(leading) {
                  this.current.leading = -leading;
                }
              }, {
                key: "setTextRise",
                value: function setTextRise(textRise) {
                  this.current.textRise = textRise;
                }
              }, {
                key: "setTextRenderingMode",
                value: function setTextRenderingMode(textRenderingMode) {
                  this.current.textRenderingMode = textRenderingMode;
                }
              }, {
                key: "setHScale",
                value: function setHScale(scale) {
                  this.current.textHScale = scale / 100;
                }
              }, {
                key: "setRenderingIntent",
                value: function setRenderingIntent(intent) {}
              }, {
                key: "setFlatness",
                value: function setFlatness(flatness) {}
              }, {
                key: "setGState",
                value: function setGState(states) {
                  var _iterator23 = _createForOfIteratorHelper(states),
                      _step23;

                  try {
                    for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                      var _step23$value = _slicedToArray(_step23.value, 2),
                          key = _step23$value[0],
                          value = _step23$value[1];

                      switch (key) {
                        case "LW":
                          this.setLineWidth(value);
                          break;

                        case "LC":
                          this.setLineCap(value);
                          break;

                        case "LJ":
                          this.setLineJoin(value);
                          break;

                        case "ML":
                          this.setMiterLimit(value);
                          break;

                        case "D":
                          this.setDash(value[0], value[1]);
                          break;

                        case "RI":
                          this.setRenderingIntent(value);
                          break;

                        case "FL":
                          this.setFlatness(value);
                          break;

                        case "Font":
                          this.setFont(value);
                          break;

                        case "CA":
                          this.setStrokeAlpha(value);
                          break;

                        case "ca":
                          this.setFillAlpha(value);
                          break;

                        default:
                          (0, _util.warn)("Unimplemented graphic state operator ".concat(key));
                          break;
                      }
                    }
                  } catch (err) {
                    _iterator23.e(err);
                  } finally {
                    _iterator23.f();
                  }
                }
              }, {
                key: "fill",
                value: function fill() {
                  var current = this.current;

                  if (current.element) {
                    current.element.setAttributeNS(null, "fill", current.fillColor);
                    current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                    this.endPath();
                  }
                }
              }, {
                key: "stroke",
                value: function stroke() {
                  var current = this.current;

                  if (current.element) {
                    this._setStrokeAttributes(current.element);

                    current.element.setAttributeNS(null, "fill", "none");
                    this.endPath();
                  }
                }
              }, {
                key: "_setStrokeAttributes",
                value: function _setStrokeAttributes(element) {
                  var lineWidthScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                  var current = this.current;
                  var dashArray = current.dashArray;

                  if (lineWidthScale !== 1 && dashArray.length > 0) {
                    dashArray = dashArray.map(function (value) {
                      return lineWidthScale * value;
                    });
                  }

                  element.setAttributeNS(null, "stroke", current.strokeColor);
                  element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                  element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                  element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                  element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                  element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                  element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                  element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                }
              }, {
                key: "eoFill",
                value: function eoFill() {
                  if (this.current.element) {
                    this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                  }

                  this.fill();
                }
              }, {
                key: "fillStroke",
                value: function fillStroke() {
                  this.stroke();
                  this.fill();
                }
              }, {
                key: "eoFillStroke",
                value: function eoFillStroke() {
                  if (this.current.element) {
                    this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                  }

                  this.fillStroke();
                }
              }, {
                key: "closeStroke",
                value: function closeStroke() {
                  this.closePath();
                  this.stroke();
                }
              }, {
                key: "closeFillStroke",
                value: function closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
              }, {
                key: "closeEOFillStroke",
                value: function closeEOFillStroke() {
                  this.closePath();
                  this.eoFillStroke();
                }
              }, {
                key: "paintSolidColorImageMask",
                value: function paintSolidColorImageMask() {
                  var rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", "1px");
                  rect.setAttributeNS(null, "height", "1px");
                  rect.setAttributeNS(null, "fill", this.current.fillColor);

                  this._ensureTransformGroup().appendChild(rect);
                }
              }, {
                key: "paintJpegXObject",
                value: function paintJpegXObject(objId, w, h) {
                  var imgObj = this.objs.get(objId);
                  var imgEl = this.svgFactory.createElement("svg:image");
                  imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgObj.src);
                  imgEl.setAttributeNS(null, "width", pf(w));
                  imgEl.setAttributeNS(null, "height", pf(h));
                  imgEl.setAttributeNS(null, "x", "0");
                  imgEl.setAttributeNS(null, "y", pf(-h));
                  imgEl.setAttributeNS(null, "transform", "scale(".concat(pf(1 / w), " ").concat(pf(-1 / h), ")"));

                  this._ensureTransformGroup().appendChild(imgEl);
                }
              }, {
                key: "paintImageXObject",
                value: function paintImageXObject(objId) {
                  var imgData = this.objs.get(objId);

                  if (!imgData) {
                    (0, _util.warn)("Dependent image with object ID ".concat(objId, " is not ready yet"));
                    return;
                  }

                  this.paintInlineImageXObject(imgData);
                }
              }, {
                key: "paintInlineImageXObject",
                value: function paintInlineImageXObject(imgData, mask) {
                  var width = imgData.width;
                  var height = imgData.height;
                  var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                  var cliprect = this.svgFactory.createElement("svg:rect");
                  cliprect.setAttributeNS(null, "x", "0");
                  cliprect.setAttributeNS(null, "y", "0");
                  cliprect.setAttributeNS(null, "width", pf(width));
                  cliprect.setAttributeNS(null, "height", pf(height));
                  this.current.element = cliprect;
                  this.clip("nonzero");
                  var imgEl = this.svgFactory.createElement("svg:image");
                  imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                  imgEl.setAttributeNS(null, "x", "0");
                  imgEl.setAttributeNS(null, "y", pf(-height));
                  imgEl.setAttributeNS(null, "width", pf(width) + "px");
                  imgEl.setAttributeNS(null, "height", pf(height) + "px");
                  imgEl.setAttributeNS(null, "transform", "scale(".concat(pf(1 / width), " ").concat(pf(-1 / height), ")"));

                  if (mask) {
                    mask.appendChild(imgEl);
                  } else {
                    this._ensureTransformGroup().appendChild(imgEl);
                  }
                }
              }, {
                key: "paintImageMaskXObject",
                value: function paintImageMaskXObject(imgData) {
                  var current = this.current;
                  var width = imgData.width;
                  var height = imgData.height;
                  var fillColor = current.fillColor;
                  current.maskId = "mask".concat(maskCount++);
                  var mask = this.svgFactory.createElement("svg:mask");
                  mask.setAttributeNS(null, "id", current.maskId);
                  var rect = this.svgFactory.createElement("svg:rect");
                  rect.setAttributeNS(null, "x", "0");
                  rect.setAttributeNS(null, "y", "0");
                  rect.setAttributeNS(null, "width", pf(width));
                  rect.setAttributeNS(null, "height", pf(height));
                  rect.setAttributeNS(null, "fill", fillColor);
                  rect.setAttributeNS(null, "mask", "url(#".concat(current.maskId, ")"));
                  this.defs.appendChild(mask);

                  this._ensureTransformGroup().appendChild(rect);

                  this.paintInlineImageXObject(imgData, mask);
                }
              }, {
                key: "paintFormXObjectBegin",
                value: function paintFormXObjectBegin(matrix, bbox) {
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                  }

                  if (bbox) {
                    var width = bbox[2] - bbox[0];
                    var height = bbox[3] - bbox[1];
                    var cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", bbox[0]);
                    cliprect.setAttributeNS(null, "y", bbox[1]);
                    cliprect.setAttributeNS(null, "width", pf(width));
                    cliprect.setAttributeNS(null, "height", pf(height));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    this.endPath();
                  }
                }
              }, {
                key: "paintFormXObjectEnd",
                value: function paintFormXObjectEnd() {}
              }, {
                key: "_initialize",
                value: function _initialize(viewport) {
                  var svg = this.svgFactory.create(viewport.width, viewport.height);
                  var definitions = this.svgFactory.createElement("svg:defs");
                  svg.appendChild(definitions);
                  this.defs = definitions;
                  var rootGroup = this.svgFactory.createElement("svg:g");
                  rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                  svg.appendChild(rootGroup);
                  this.svg = rootGroup;
                  return svg;
                }
              }, {
                key: "_ensureClipGroup",
                value: function _ensureClipGroup() {
                  if (!this.current.clipGroup) {
                    var clipGroup = this.svgFactory.createElement("svg:g");
                    clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                    this.svg.appendChild(clipGroup);
                    this.current.clipGroup = clipGroup;
                  }

                  return this.current.clipGroup;
                }
              }, {
                key: "_ensureTransformGroup",
                value: function _ensureTransformGroup() {
                  if (!this.tgrp) {
                    this.tgrp = this.svgFactory.createElement("svg:g");
                    this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));

                    if (this.current.activeClipUrl) {
                      this._ensureClipGroup().appendChild(this.tgrp);
                    } else {
                      this.svg.appendChild(this.tgrp);
                    }
                  }

                  return this.tgrp;
                }
              }]);

              return SVGGraphics;
            }();
          }
          /***/
        },
        /* 19 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PDFNodeStream = void 0;

          var _util = __w_pdfjs_require__(1);

          var _network_utils = __w_pdfjs_require__(20);

          var fs = __webpack_require__(
          /*! fs */
          5);

          var http = __webpack_require__(
          /*! http */
          6);

          var https = __webpack_require__(
          /*! https */
          7);

          var url = __webpack_require__(
          /*! url */
          8);

          var fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;

          function parseUrl(sourceUrl) {
            var parsedUrl = url.parse(sourceUrl);

            if (parsedUrl.protocol === "file:" || parsedUrl.host) {
              return parsedUrl;
            }

            if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
              return url.parse("file:///".concat(sourceUrl));
            }

            if (!parsedUrl.host) {
              parsedUrl.protocol = "file:";
            }

            return parsedUrl;
          }

          var PDFNodeStream = /*#__PURE__*/function () {
            function PDFNodeStream(source) {
              _classCallCheck(this, PDFNodeStream);

              this.source = source;
              this.url = parseUrl(source.url);
              this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
              this.isFsUrl = this.url.protocol === "file:";
              this.httpHeaders = this.isHttp && source.httpHeaders || {};
              this._fullRequestReader = null;
              this._rangeRequestReaders = [];
            }

            _createClass(PDFNodeStream, [{
              key: "getFullReader",
              value: function getFullReader() {
                (0, _util.assert)(!this._fullRequestReader);
                this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                return this._fullRequestReader;
              }
            }, {
              key: "getRangeReader",
              value: function getRangeReader(start, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }

                var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);

                this._rangeRequestReaders.push(rangeReader);

                return rangeReader;
              }
            }, {
              key: "cancelAllRequests",
              value: function cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }

                var readers = this._rangeRequestReaders.slice(0);

                readers.forEach(function (reader) {
                  reader.cancel(reason);
                });
              }
            }, {
              key: "_progressiveDataLength",
              get: function get() {
                return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
              }
            }]);

            return PDFNodeStream;
          }();

          exports.PDFNodeStream = PDFNodeStream;

          var BaseFullReader = /*#__PURE__*/function () {
            function BaseFullReader(stream) {
              _classCallCheck(this, BaseFullReader);

              this._url = stream.url;
              this._done = false;
              this._storedError = null;
              this.onProgress = null;
              var source = stream.source;
              this._contentLength = source.length;
              this._loaded = 0;
              this._filename = null;
              this._disableRange = source.disableRange || false;
              this._rangeChunkSize = source.rangeChunkSize;

              if (!this._rangeChunkSize && !this._disableRange) {
                this._disableRange = true;
              }

              this._isStreamingSupported = !source.disableStream;
              this._isRangeSupported = !source.disableRange;
              this._readableStream = null;
              this._readCapability = (0, _util.createPromiseCapability)();
              this._headersCapability = (0, _util.createPromiseCapability)();
            }

            _createClass(BaseFullReader, [{
              key: "read",
              value: function () {
                var _read3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
                  var chunk, buffer;
                  return regeneratorRuntime.wrap(function _callee9$(_context9) {
                    while (1) {
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          _context9.next = 2;
                          return this._readCapability.promise;

                        case 2:
                          if (!this._done) {
                            _context9.next = 4;
                            break;
                          }

                          return _context9.abrupt("return", {
                            value: undefined,
                            done: true
                          });

                        case 4:
                          if (!this._storedError) {
                            _context9.next = 6;
                            break;
                          }

                          throw this._storedError;

                        case 6:
                          chunk = this._readableStream.read();

                          if (!(chunk === null)) {
                            _context9.next = 10;
                            break;
                          }

                          this._readCapability = (0, _util.createPromiseCapability)();
                          return _context9.abrupt("return", this.read());

                        case 10:
                          this._loaded += chunk.length;

                          if (this.onProgress) {
                            this.onProgress({
                              loaded: this._loaded,
                              total: this._contentLength
                            });
                          }

                          buffer = new Uint8Array(chunk).buffer;
                          return _context9.abrupt("return", {
                            value: buffer,
                            done: false
                          });

                        case 14:
                        case "end":
                          return _context9.stop();
                      }
                    }
                  }, _callee9, this);
                }));

                function read() {
                  return _read3.apply(this, arguments);
                }

                return read;
              }()
            }, {
              key: "cancel",
              value: function cancel(reason) {
                if (!this._readableStream) {
                  this._error(reason);

                  return;
                }

                this._readableStream.destroy(reason);
              }
            }, {
              key: "_error",
              value: function _error(reason) {
                this._storedError = reason;

                this._readCapability.resolve();
              }
            }, {
              key: "_setReadableStream",
              value: function _setReadableStream(readableStream) {
                var _this51 = this;

                this._readableStream = readableStream;
                readableStream.on("readable", function () {
                  _this51._readCapability.resolve();
                });
                readableStream.on("end", function () {
                  readableStream.destroy();
                  _this51._done = true;

                  _this51._readCapability.resolve();
                });
                readableStream.on("error", function (reason) {
                  _this51._error(reason);
                });

                if (!this._isStreamingSupported && this._isRangeSupported) {
                  this._error(new _util.AbortException("streaming is disabled"));
                }

                if (this._storedError) {
                  this._readableStream.destroy(this._storedError);
                }
              }
            }, {
              key: "headersReady",
              get: function get() {
                return this._headersCapability.promise;
              }
            }, {
              key: "filename",
              get: function get() {
                return this._filename;
              }
            }, {
              key: "contentLength",
              get: function get() {
                return this._contentLength;
              }
            }, {
              key: "isRangeSupported",
              get: function get() {
                return this._isRangeSupported;
              }
            }, {
              key: "isStreamingSupported",
              get: function get() {
                return this._isStreamingSupported;
              }
            }]);

            return BaseFullReader;
          }();

          var BaseRangeReader = /*#__PURE__*/function () {
            function BaseRangeReader(stream) {
              _classCallCheck(this, BaseRangeReader);

              this._url = stream.url;
              this._done = false;
              this._storedError = null;
              this.onProgress = null;
              this._loaded = 0;
              this._readableStream = null;
              this._readCapability = (0, _util.createPromiseCapability)();
              var source = stream.source;
              this._isStreamingSupported = !source.disableStream;
            }

            _createClass(BaseRangeReader, [{
              key: "read",
              value: function () {
                var _read4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
                  var chunk, buffer;
                  return regeneratorRuntime.wrap(function _callee10$(_context10) {
                    while (1) {
                      switch (_context10.prev = _context10.next) {
                        case 0:
                          _context10.next = 2;
                          return this._readCapability.promise;

                        case 2:
                          if (!this._done) {
                            _context10.next = 4;
                            break;
                          }

                          return _context10.abrupt("return", {
                            value: undefined,
                            done: true
                          });

                        case 4:
                          if (!this._storedError) {
                            _context10.next = 6;
                            break;
                          }

                          throw this._storedError;

                        case 6:
                          chunk = this._readableStream.read();

                          if (!(chunk === null)) {
                            _context10.next = 10;
                            break;
                          }

                          this._readCapability = (0, _util.createPromiseCapability)();
                          return _context10.abrupt("return", this.read());

                        case 10:
                          this._loaded += chunk.length;

                          if (this.onProgress) {
                            this.onProgress({
                              loaded: this._loaded
                            });
                          }

                          buffer = new Uint8Array(chunk).buffer;
                          return _context10.abrupt("return", {
                            value: buffer,
                            done: false
                          });

                        case 14:
                        case "end":
                          return _context10.stop();
                      }
                    }
                  }, _callee10, this);
                }));

                function read() {
                  return _read4.apply(this, arguments);
                }

                return read;
              }()
            }, {
              key: "cancel",
              value: function cancel(reason) {
                if (!this._readableStream) {
                  this._error(reason);

                  return;
                }

                this._readableStream.destroy(reason);
              }
            }, {
              key: "_error",
              value: function _error(reason) {
                this._storedError = reason;

                this._readCapability.resolve();
              }
            }, {
              key: "_setReadableStream",
              value: function _setReadableStream(readableStream) {
                var _this52 = this;

                this._readableStream = readableStream;
                readableStream.on("readable", function () {
                  _this52._readCapability.resolve();
                });
                readableStream.on("end", function () {
                  readableStream.destroy();
                  _this52._done = true;

                  _this52._readCapability.resolve();
                });
                readableStream.on("error", function (reason) {
                  _this52._error(reason);
                });

                if (this._storedError) {
                  this._readableStream.destroy(this._storedError);
                }
              }
            }, {
              key: "isStreamingSupported",
              get: function get() {
                return this._isStreamingSupported;
              }
            }]);

            return BaseRangeReader;
          }();

          function createRequestOptions(url, headers) {
            return {
              protocol: url.protocol,
              auth: url.auth,
              host: url.hostname,
              port: url.port,
              path: url.path,
              method: "GET",
              headers: headers
            };
          }

          var PDFNodeStreamFullReader = /*#__PURE__*/function (_BaseFullReader) {
            _inherits(PDFNodeStreamFullReader, _BaseFullReader);

            var _super34 = _createSuper(PDFNodeStreamFullReader);

            function PDFNodeStreamFullReader(stream) {
              var _this53;

              _classCallCheck(this, PDFNodeStreamFullReader);

              _this53 = _super34.call(this, stream);

              var handleResponse = function handleResponse(response) {
                if (response.statusCode === 404) {
                  var error = new _util.MissingPDFException("Missing PDF \"".concat(_this53._url, "\"."));
                  _this53._storedError = error;

                  _this53._headersCapability.reject(error);

                  return;
                }

                _this53._headersCapability.resolve();

                _this53._setReadableStream(response);

                var getResponseHeader = function getResponseHeader(name) {
                  return _this53._readableStream.headers[name.toLowerCase()];
                };

                var _ref31 = (0, _network_utils.validateRangeRequestCapabilities)({
                  getResponseHeader: getResponseHeader,
                  isHttp: stream.isHttp,
                  rangeChunkSize: _this53._rangeChunkSize,
                  disableRange: _this53._disableRange
                }),
                    allowRangeRequests = _ref31.allowRangeRequests,
                    suggestedLength = _ref31.suggestedLength;

                _this53._isRangeSupported = allowRangeRequests;
                _this53._contentLength = suggestedLength || _this53._contentLength;
                _this53._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
              };

              _this53._request = null;

              if (_this53._url.protocol === "http:") {
                _this53._request = http.request(createRequestOptions(_this53._url, stream.httpHeaders), handleResponse);
              } else {
                _this53._request = https.request(createRequestOptions(_this53._url, stream.httpHeaders), handleResponse);
              }

              _this53._request.on("error", function (reason) {
                _this53._storedError = reason;

                _this53._headersCapability.reject(reason);
              });

              _this53._request.end();

              return _this53;
            }

            return PDFNodeStreamFullReader;
          }(BaseFullReader);

          var PDFNodeStreamRangeReader = /*#__PURE__*/function (_BaseRangeReader) {
            _inherits(PDFNodeStreamRangeReader, _BaseRangeReader);

            var _super35 = _createSuper(PDFNodeStreamRangeReader);

            function PDFNodeStreamRangeReader(stream, start, end) {
              var _this54;

              _classCallCheck(this, PDFNodeStreamRangeReader);

              _this54 = _super35.call(this, stream);
              _this54._httpHeaders = {};

              for (var property in stream.httpHeaders) {
                var value = stream.httpHeaders[property];

                if (typeof value === "undefined") {
                  continue;
                }

                _this54._httpHeaders[property] = value;
              }

              _this54._httpHeaders["Range"] = "bytes=".concat(start, "-").concat(end - 1);

              var handleResponse = function handleResponse(response) {
                if (response.statusCode === 404) {
                  var error = new _util.MissingPDFException("Missing PDF \"".concat(_this54._url, "\"."));
                  _this54._storedError = error;
                  return;
                }

                _this54._setReadableStream(response);
              };

              _this54._request = null;

              if (_this54._url.protocol === "http:") {
                _this54._request = http.request(createRequestOptions(_this54._url, _this54._httpHeaders), handleResponse);
              } else {
                _this54._request = https.request(createRequestOptions(_this54._url, _this54._httpHeaders), handleResponse);
              }

              _this54._request.on("error", function (reason) {
                _this54._storedError = reason;
              });

              _this54._request.end();

              return _this54;
            }

            return PDFNodeStreamRangeReader;
          }(BaseRangeReader);

          var PDFNodeStreamFsFullReader = /*#__PURE__*/function (_BaseFullReader2) {
            _inherits(PDFNodeStreamFsFullReader, _BaseFullReader2);

            var _super36 = _createSuper(PDFNodeStreamFsFullReader);

            function PDFNodeStreamFsFullReader(stream) {
              var _this55;

              _classCallCheck(this, PDFNodeStreamFsFullReader);

              _this55 = _super36.call(this, stream);
              var path = decodeURIComponent(_this55._url.path);

              if (fileUriRegex.test(_this55._url.href)) {
                path = path.replace(/^\//, "");
              }

              fs.lstat(path, function (error, stat) {
                if (error) {
                  if (error.code === "ENOENT") {
                    error = new _util.MissingPDFException("Missing PDF \"".concat(path, "\"."));
                  }

                  _this55._storedError = error;

                  _this55._headersCapability.reject(error);

                  return;
                }

                _this55._contentLength = stat.size;

                _this55._setReadableStream(fs.createReadStream(path));

                _this55._headersCapability.resolve();
              });
              return _this55;
            }

            return PDFNodeStreamFsFullReader;
          }(BaseFullReader);

          var PDFNodeStreamFsRangeReader = /*#__PURE__*/function (_BaseRangeReader2) {
            _inherits(PDFNodeStreamFsRangeReader, _BaseRangeReader2);

            var _super37 = _createSuper(PDFNodeStreamFsRangeReader);

            function PDFNodeStreamFsRangeReader(stream, start, end) {
              var _this56;

              _classCallCheck(this, PDFNodeStreamFsRangeReader);

              _this56 = _super37.call(this, stream);
              var path = decodeURIComponent(_this56._url.path);

              if (fileUriRegex.test(_this56._url.href)) {
                path = path.replace(/^\//, "");
              }

              _this56._setReadableStream(fs.createReadStream(path, {
                start: start,
                end: end - 1
              }));

              return _this56;
            }

            return PDFNodeStreamFsRangeReader;
          }(BaseRangeReader);
          /***/

        },
        /* 20 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.createResponseStatusError = createResponseStatusError;
          exports.extractFilenameFromHeader = extractFilenameFromHeader;
          exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
          exports.validateResponseStatus = validateResponseStatus;

          var _util = __w_pdfjs_require__(1);

          var _content_disposition = __w_pdfjs_require__(21);

          function validateRangeRequestCapabilities(_ref32) {
            var getResponseHeader = _ref32.getResponseHeader,
                isHttp = _ref32.isHttp,
                rangeChunkSize = _ref32.rangeChunkSize,
                disableRange = _ref32.disableRange;
            (0, _util.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
            var returnValues = {
              allowRangeRequests: false,
              suggestedLength: undefined
            };
            var length = parseInt(getResponseHeader("Content-Length"), 10);

            if (!Number.isInteger(length)) {
              return returnValues;
            }

            returnValues.suggestedLength = length;

            if (length <= 2 * rangeChunkSize) {
              return returnValues;
            }

            if (disableRange || !isHttp) {
              return returnValues;
            }

            if (getResponseHeader("Accept-Ranges") !== "bytes") {
              return returnValues;
            }

            var contentEncoding = getResponseHeader("Content-Encoding") || "identity";

            if (contentEncoding !== "identity") {
              return returnValues;
            }

            returnValues.allowRangeRequests = true;
            return returnValues;
          }

          function extractFilenameFromHeader(getResponseHeader) {
            var contentDisposition = getResponseHeader("Content-Disposition");

            if (contentDisposition) {
              var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);

              if (filename.includes("%")) {
                try {
                  filename = decodeURIComponent(filename);
                } catch (ex) {}
              }

              if (/\.pdf$/i.test(filename)) {
                return filename;
              }
            }

            return null;
          }

          function createResponseStatusError(status, url) {
            if (status === 404 || status === 0 && url.startsWith("file:")) {
              return new _util.MissingPDFException('Missing PDF "' + url + '".');
            }

            return new _util.UnexpectedResponseException("Unexpected server response (" + status + ') while retrieving PDF "' + url + '".', status);
          }

          function validateResponseStatus(status) {
            return status === 200 || status === 206;
          }
          /***/

        },
        /* 21 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;

          function getFilenameFromContentDispositionHeader(contentDisposition) {
            var needsEncodingFixup = true;
            var tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);

            if (tmp) {
              tmp = tmp[1];
              var filename = rfc2616unquote(tmp);
              filename = unescape(filename);
              filename = rfc5987decode(filename);
              filename = rfc2047decode(filename);
              return fixupEncoding(filename);
            }

            tmp = rfc2231getparam(contentDisposition);

            if (tmp) {
              var _filename = rfc2047decode(tmp);

              return fixupEncoding(_filename);
            }

            tmp = toParamRegExp("filename", "i").exec(contentDisposition);

            if (tmp) {
              tmp = tmp[1];

              var _filename2 = rfc2616unquote(tmp);

              _filename2 = rfc2047decode(_filename2);
              return fixupEncoding(_filename2);
            }

            function toParamRegExp(attributePattern, flags) {
              return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
            }

            function textdecode(encoding, value) {
              if (encoding) {
                if (!/^[\x00-\xFF]+$/.test(value)) {
                  return value;
                }

                try {
                  var decoder = new TextDecoder(encoding, {
                    fatal: true
                  });
                  var bytes = Array.from(value, function (ch) {
                    return ch.charCodeAt(0) & 0xff;
                  });
                  value = decoder.decode(new Uint8Array(bytes));
                  needsEncodingFixup = false;
                } catch (e) {
                  if (/^utf-?8$/i.test(encoding)) {
                    try {
                      value = decodeURIComponent(escape(value));
                      needsEncodingFixup = false;
                    } catch (err) {}
                  }
                }
              }

              return value;
            }

            function fixupEncoding(value) {
              if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                value = textdecode("utf-8", value);

                if (needsEncodingFixup) {
                  value = textdecode("iso-8859-1", value);
                }
              }

              return value;
            }

            function rfc2231getparam(contentDisposition) {
              var matches = [];
              var match;
              var iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");

              while ((match = iter.exec(contentDisposition)) !== null) {
                var _match = match,
                    _match2 = _slicedToArray(_match, 4),
                    n = _match2[1],
                    quot = _match2[2],
                    part = _match2[3];

                n = parseInt(n, 10);

                if (n in matches) {
                  if (n === 0) {
                    break;
                  }

                  continue;
                }

                matches[n] = [quot, part];
              }

              var parts = [];

              for (var _n2 = 0; _n2 < matches.length; ++_n2) {
                if (!(_n2 in matches)) {
                  break;
                }

                var _matches$_n = _slicedToArray(matches[_n2], 2),
                    _quot = _matches$_n[0],
                    _part = _matches$_n[1];

                _part = rfc2616unquote(_part);

                if (_quot) {
                  _part = unescape(_part);

                  if (_n2 === 0) {
                    _part = rfc5987decode(_part);
                  }
                }

                parts.push(_part);
              }

              return parts.join("");
            }

            function rfc2616unquote(value) {
              if (value.startsWith('"')) {
                var parts = value.slice(1).split('\\"');

                for (var i = 0; i < parts.length; ++i) {
                  var quotindex = parts[i].indexOf('"');

                  if (quotindex !== -1) {
                    parts[i] = parts[i].slice(0, quotindex);
                    parts.length = i + 1;
                  }

                  parts[i] = parts[i].replace(/\\(.)/g, "$1");
                }

                value = parts.join('"');
              }

              return value;
            }

            function rfc5987decode(extvalue) {
              var encodingend = extvalue.indexOf("'");

              if (encodingend === -1) {
                return extvalue;
              }

              var encoding = extvalue.slice(0, encodingend);
              var langvalue = extvalue.slice(encodingend + 1);
              var value = langvalue.replace(/^[^']*'/, "");
              return textdecode(encoding, value);
            }

            function rfc2047decode(value) {
              if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                return value;
              }

              return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (_, charset, encoding, text) {
                if (encoding === "q" || encoding === "Q") {
                  text = text.replace(/_/g, " ");
                  text = text.replace(/=([0-9a-fA-F]{2})/g, function (_, hex) {
                    return String.fromCharCode(parseInt(hex, 16));
                  });
                  return textdecode(charset, text);
                }

                try {
                  text = atob(text);
                } catch (e) {}

                return textdecode(charset, text);
              });
            }

            return "";
          }
          /***/

        },
        /* 22 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PDFNetworkStream = void 0;

          var _util = __w_pdfjs_require__(1);

          var _network_utils = __w_pdfjs_require__(20);

          ;
          var OK_RESPONSE = 200;
          var PARTIAL_CONTENT_RESPONSE = 206;

          function getArrayBuffer(xhr) {
            var data = xhr.response;

            if (typeof data !== "string") {
              return data;
            }

            var array = (0, _util.stringToBytes)(data);
            return array.buffer;
          }

          var NetworkManager = /*#__PURE__*/function () {
            function NetworkManager(url, args) {
              _classCallCheck(this, NetworkManager);

              this.url = url;
              args = args || {};
              this.isHttp = /^https?:/i.test(url);
              this.httpHeaders = this.isHttp && args.httpHeaders || {};
              this.withCredentials = args.withCredentials || false;

              this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                return new XMLHttpRequest();
              };

              this.currXhrId = 0;
              this.pendingRequests = Object.create(null);
            }

            _createClass(NetworkManager, [{
              key: "requestRange",
              value: function requestRange(begin, end, listeners) {
                var args = {
                  begin: begin,
                  end: end
                };

                for (var prop in listeners) {
                  args[prop] = listeners[prop];
                }

                return this.request(args);
              }
            }, {
              key: "requestFull",
              value: function requestFull(listeners) {
                return this.request(listeners);
              }
            }, {
              key: "request",
              value: function request(args) {
                var xhr = this.getXhr();
                var xhrId = this.currXhrId++;
                var pendingRequest = this.pendingRequests[xhrId] = {
                  xhr: xhr
                };
                xhr.open("GET", this.url);
                xhr.withCredentials = this.withCredentials;

                for (var property in this.httpHeaders) {
                  var value = this.httpHeaders[property];

                  if (typeof value === "undefined") {
                    continue;
                  }

                  xhr.setRequestHeader(property, value);
                }

                if (this.isHttp && "begin" in args && "end" in args) {
                  xhr.setRequestHeader("Range", "bytes=".concat(args.begin, "-").concat(args.end - 1));
                  pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                } else {
                  pendingRequest.expectedStatus = OK_RESPONSE;
                }

                xhr.responseType = "arraybuffer";

                if (args.onError) {
                  xhr.onerror = function (evt) {
                    args.onError(xhr.status);
                  };
                }

                xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                xhr.onprogress = this.onProgress.bind(this, xhrId);
                pendingRequest.onHeadersReceived = args.onHeadersReceived;
                pendingRequest.onDone = args.onDone;
                pendingRequest.onError = args.onError;
                pendingRequest.onProgress = args.onProgress;
                xhr.send(null);
                return xhrId;
              }
            }, {
              key: "onProgress",
              value: function onProgress(xhrId, evt) {
                var pendingRequest = this.pendingRequests[xhrId];

                if (!pendingRequest) {
                  return;
                }

                if (pendingRequest.onProgress) {
                  pendingRequest.onProgress(evt);
                }
              }
            }, {
              key: "onStateChange",
              value: function onStateChange(xhrId, evt) {
                var pendingRequest = this.pendingRequests[xhrId];

                if (!pendingRequest) {
                  return;
                }

                var xhr = pendingRequest.xhr;

                if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                  pendingRequest.onHeadersReceived();
                  delete pendingRequest.onHeadersReceived;
                }

                if (xhr.readyState !== 4) {
                  return;
                }

                if (!(xhrId in this.pendingRequests)) {
                  return;
                }

                delete this.pendingRequests[xhrId];

                if (xhr.status === 0 && this.isHttp) {
                  if (pendingRequest.onError) {
                    pendingRequest.onError(xhr.status);
                  }

                  return;
                }

                var xhrStatus = xhr.status || OK_RESPONSE;
                var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;

                if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                  if (pendingRequest.onError) {
                    pendingRequest.onError(xhr.status);
                  }

                  return;
                }

                var chunk = getArrayBuffer(xhr);

                if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                  var rangeHeader = xhr.getResponseHeader("Content-Range");
                  var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                  pendingRequest.onDone({
                    begin: parseInt(matches[1], 10),
                    chunk: chunk
                  });
                } else if (chunk) {
                  pendingRequest.onDone({
                    begin: 0,
                    chunk: chunk
                  });
                } else if (pendingRequest.onError) {
                  pendingRequest.onError(xhr.status);
                }
              }
            }, {
              key: "hasPendingRequests",
              value: function hasPendingRequests() {
                for (var xhrId in this.pendingRequests) {
                  return true;
                }

                return false;
              }
            }, {
              key: "getRequestXhr",
              value: function getRequestXhr(xhrId) {
                return this.pendingRequests[xhrId].xhr;
              }
            }, {
              key: "isPendingRequest",
              value: function isPendingRequest(xhrId) {
                return xhrId in this.pendingRequests;
              }
            }, {
              key: "abortAllRequests",
              value: function abortAllRequests() {
                for (var xhrId in this.pendingRequests) {
                  this.abortRequest(xhrId | 0);
                }
              }
            }, {
              key: "abortRequest",
              value: function abortRequest(xhrId) {
                var xhr = this.pendingRequests[xhrId].xhr;
                delete this.pendingRequests[xhrId];
                xhr.abort();
              }
            }]);

            return NetworkManager;
          }();

          var PDFNetworkStream = /*#__PURE__*/function () {
            function PDFNetworkStream(source) {
              _classCallCheck(this, PDFNetworkStream);

              this._source = source;
              this._manager = new NetworkManager(source.url, {
                httpHeaders: source.httpHeaders,
                withCredentials: source.withCredentials
              });
              this._rangeChunkSize = source.rangeChunkSize;
              this._fullRequestReader = null;
              this._rangeRequestReaders = [];
            }

            _createClass(PDFNetworkStream, [{
              key: "_onRangeRequestReaderClosed",
              value: function _onRangeRequestReaderClosed(reader) {
                var i = this._rangeRequestReaders.indexOf(reader);

                if (i >= 0) {
                  this._rangeRequestReaders.splice(i, 1);
                }
              }
            }, {
              key: "getFullReader",
              value: function getFullReader() {
                (0, _util.assert)(!this._fullRequestReader);
                this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                return this._fullRequestReader;
              }
            }, {
              key: "getRangeReader",
              value: function getRangeReader(begin, end) {
                var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                reader.onClosed = this._onRangeRequestReaderClosed.bind(this);

                this._rangeRequestReaders.push(reader);

                return reader;
              }
            }, {
              key: "cancelAllRequests",
              value: function cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }

                var readers = this._rangeRequestReaders.slice(0);

                readers.forEach(function (reader) {
                  reader.cancel(reason);
                });
              }
            }]);

            return PDFNetworkStream;
          }();

          exports.PDFNetworkStream = PDFNetworkStream;

          var PDFNetworkStreamFullRequestReader = /*#__PURE__*/function () {
            function PDFNetworkStreamFullRequestReader(manager, source) {
              _classCallCheck(this, PDFNetworkStreamFullRequestReader);

              this._manager = manager;
              var args = {
                onHeadersReceived: this._onHeadersReceived.bind(this),
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = source.url;
              this._fullRequestId = manager.requestFull(args);
              this._headersReceivedCapability = (0, _util.createPromiseCapability)();
              this._disableRange = source.disableRange || false;
              this._contentLength = source.length;
              this._rangeChunkSize = source.rangeChunkSize;

              if (!this._rangeChunkSize && !this._disableRange) {
                this._disableRange = true;
              }

              this._isStreamingSupported = false;
              this._isRangeSupported = false;
              this._cachedChunks = [];
              this._requests = [];
              this._done = false;
              this._storedError = undefined;
              this._filename = null;
              this.onProgress = null;
            }

            _createClass(PDFNetworkStreamFullRequestReader, [{
              key: "_onHeadersReceived",
              value: function _onHeadersReceived() {
                var fullRequestXhrId = this._fullRequestId;

                var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);

                var getResponseHeader = function getResponseHeader(name) {
                  return fullRequestXhr.getResponseHeader(name);
                };

                var _ref33 = (0, _network_utils.validateRangeRequestCapabilities)({
                  getResponseHeader: getResponseHeader,
                  isHttp: this._manager.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                }),
                    allowRangeRequests = _ref33.allowRangeRequests,
                    suggestedLength = _ref33.suggestedLength;

                if (allowRangeRequests) {
                  this._isRangeSupported = true;
                }

                this._contentLength = suggestedLength || this._contentLength;
                this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

                if (this._isRangeSupported) {
                  this._manager.abortRequest(fullRequestXhrId);
                }

                this._headersReceivedCapability.resolve();
              }
            }, {
              key: "_onDone",
              value: function _onDone(args) {
                if (args) {
                  if (this._requests.length > 0) {
                    var requestCapability = this._requests.shift();

                    requestCapability.resolve({
                      value: args.chunk,
                      done: false
                    });
                  } else {
                    this._cachedChunks.push(args.chunk);
                  }
                }

                this._done = true;

                if (this._cachedChunks.length > 0) {
                  return;
                }

                this._requests.forEach(function (requestCapability) {
                  requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                });

                this._requests = [];
              }
            }, {
              key: "_onError",
              value: function _onError(status) {
                var url = this._url;
                var exception = (0, _network_utils.createResponseStatusError)(status, url);
                this._storedError = exception;

                this._headersReceivedCapability.reject(exception);

                this._requests.forEach(function (requestCapability) {
                  requestCapability.reject(exception);
                });

                this._requests = [];
                this._cachedChunks = [];
              }
            }, {
              key: "_onProgress",
              value: function _onProgress(data) {
                if (this.onProgress) {
                  this.onProgress({
                    loaded: data.loaded,
                    total: data.lengthComputable ? data.total : this._contentLength
                  });
                }
              }
            }, {
              key: "read",
              value: function () {
                var _read5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
                  var chunk, requestCapability;
                  return regeneratorRuntime.wrap(function _callee11$(_context11) {
                    while (1) {
                      switch (_context11.prev = _context11.next) {
                        case 0:
                          if (!this._storedError) {
                            _context11.next = 2;
                            break;
                          }

                          throw this._storedError;

                        case 2:
                          if (!(this._cachedChunks.length > 0)) {
                            _context11.next = 5;
                            break;
                          }

                          chunk = this._cachedChunks.shift();
                          return _context11.abrupt("return", {
                            value: chunk,
                            done: false
                          });

                        case 5:
                          if (!this._done) {
                            _context11.next = 7;
                            break;
                          }

                          return _context11.abrupt("return", {
                            value: undefined,
                            done: true
                          });

                        case 7:
                          requestCapability = (0, _util.createPromiseCapability)();

                          this._requests.push(requestCapability);

                          return _context11.abrupt("return", requestCapability.promise);

                        case 10:
                        case "end":
                          return _context11.stop();
                      }
                    }
                  }, _callee11, this);
                }));

                function read() {
                  return _read5.apply(this, arguments);
                }

                return read;
              }()
            }, {
              key: "cancel",
              value: function cancel(reason) {
                this._done = true;

                this._headersReceivedCapability.reject(reason);

                this._requests.forEach(function (requestCapability) {
                  requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                });

                this._requests = [];

                if (this._manager.isPendingRequest(this._fullRequestId)) {
                  this._manager.abortRequest(this._fullRequestId);
                }

                this._fullRequestReader = null;
              }
            }, {
              key: "filename",
              get: function get() {
                return this._filename;
              }
            }, {
              key: "isRangeSupported",
              get: function get() {
                return this._isRangeSupported;
              }
            }, {
              key: "isStreamingSupported",
              get: function get() {
                return this._isStreamingSupported;
              }
            }, {
              key: "contentLength",
              get: function get() {
                return this._contentLength;
              }
            }, {
              key: "headersReady",
              get: function get() {
                return this._headersReceivedCapability.promise;
              }
            }]);

            return PDFNetworkStreamFullRequestReader;
          }();

          var PDFNetworkStreamRangeRequestReader = /*#__PURE__*/function () {
            function PDFNetworkStreamRangeRequestReader(manager, begin, end) {
              _classCallCheck(this, PDFNetworkStreamRangeRequestReader);

              this._manager = manager;
              var args = {
                onDone: this._onDone.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._requestId = manager.requestRange(begin, end, args);
              this._requests = [];
              this._queuedChunk = null;
              this._done = false;
              this.onProgress = null;
              this.onClosed = null;
            }

            _createClass(PDFNetworkStreamRangeRequestReader, [{
              key: "_close",
              value: function _close() {
                if (this.onClosed) {
                  this.onClosed(this);
                }
              }
            }, {
              key: "_onDone",
              value: function _onDone(data) {
                var chunk = data.chunk;

                if (this._requests.length > 0) {
                  var requestCapability = this._requests.shift();

                  requestCapability.resolve({
                    value: chunk,
                    done: false
                  });
                } else {
                  this._queuedChunk = chunk;
                }

                this._done = true;

                this._requests.forEach(function (requestCapability) {
                  requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                });

                this._requests = [];

                this._close();
              }
            }, {
              key: "_onProgress",
              value: function _onProgress(evt) {
                if (!this.isStreamingSupported && this.onProgress) {
                  this.onProgress({
                    loaded: evt.loaded
                  });
                }
              }
            }, {
              key: "read",
              value: function () {
                var _read6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
                  var chunk, requestCapability;
                  return regeneratorRuntime.wrap(function _callee12$(_context12) {
                    while (1) {
                      switch (_context12.prev = _context12.next) {
                        case 0:
                          if (!(this._queuedChunk !== null)) {
                            _context12.next = 4;
                            break;
                          }

                          chunk = this._queuedChunk;
                          this._queuedChunk = null;
                          return _context12.abrupt("return", {
                            value: chunk,
                            done: false
                          });

                        case 4:
                          if (!this._done) {
                            _context12.next = 6;
                            break;
                          }

                          return _context12.abrupt("return", {
                            value: undefined,
                            done: true
                          });

                        case 6:
                          requestCapability = (0, _util.createPromiseCapability)();

                          this._requests.push(requestCapability);

                          return _context12.abrupt("return", requestCapability.promise);

                        case 9:
                        case "end":
                          return _context12.stop();
                      }
                    }
                  }, _callee12, this);
                }));

                function read() {
                  return _read6.apply(this, arguments);
                }

                return read;
              }()
            }, {
              key: "cancel",
              value: function cancel(reason) {
                this._done = true;

                this._requests.forEach(function (requestCapability) {
                  requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                });

                this._requests = [];

                if (this._manager.isPendingRequest(this._requestId)) {
                  this._manager.abortRequest(this._requestId);
                }

                this._close();
              }
            }, {
              key: "isStreamingSupported",
              get: function get() {
                return false;
              }
            }]);

            return PDFNetworkStreamRangeRequestReader;
          }();
          /***/

        },
        /* 23 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PDFFetchStream = void 0;

          var _util = __w_pdfjs_require__(1);

          var _network_utils = __w_pdfjs_require__(20);

          function createFetchOptions(headers, withCredentials, abortController) {
            return {
              method: "GET",
              headers: headers,
              signal: abortController && abortController.signal,
              mode: "cors",
              credentials: withCredentials ? "include" : "same-origin",
              redirect: "follow"
            };
          }

          function createHeaders(httpHeaders) {
            var headers = new Headers();

            for (var property in httpHeaders) {
              var value = httpHeaders[property];

              if (typeof value === "undefined") {
                continue;
              }

              headers.append(property, value);
            }

            return headers;
          }

          var PDFFetchStream = /*#__PURE__*/function () {
            function PDFFetchStream(source) {
              _classCallCheck(this, PDFFetchStream);

              this.source = source;
              this.isHttp = /^https?:/i.test(source.url);
              this.httpHeaders = this.isHttp && source.httpHeaders || {};
              this._fullRequestReader = null;
              this._rangeRequestReaders = [];
            }

            _createClass(PDFFetchStream, [{
              key: "getFullReader",
              value: function getFullReader() {
                (0, _util.assert)(!this._fullRequestReader);
                this._fullRequestReader = new PDFFetchStreamReader(this);
                return this._fullRequestReader;
              }
            }, {
              key: "getRangeReader",
              value: function getRangeReader(begin, end) {
                if (end <= this._progressiveDataLength) {
                  return null;
                }

                var reader = new PDFFetchStreamRangeReader(this, begin, end);

                this._rangeRequestReaders.push(reader);

                return reader;
              }
            }, {
              key: "cancelAllRequests",
              value: function cancelAllRequests(reason) {
                if (this._fullRequestReader) {
                  this._fullRequestReader.cancel(reason);
                }

                var readers = this._rangeRequestReaders.slice(0);

                readers.forEach(function (reader) {
                  reader.cancel(reason);
                });
              }
            }, {
              key: "_progressiveDataLength",
              get: function get() {
                return this._fullRequestReader ? this._fullRequestReader._loaded : 0;
              }
            }]);

            return PDFFetchStream;
          }();

          exports.PDFFetchStream = PDFFetchStream;

          var PDFFetchStreamReader = /*#__PURE__*/function () {
            function PDFFetchStreamReader(stream) {
              var _this57 = this;

              _classCallCheck(this, PDFFetchStreamReader);

              this._stream = stream;
              this._reader = null;
              this._loaded = 0;
              this._filename = null;
              var source = stream.source;
              this._withCredentials = source.withCredentials || false;
              this._contentLength = source.length;
              this._headersCapability = (0, _util.createPromiseCapability)();
              this._disableRange = source.disableRange || false;
              this._rangeChunkSize = source.rangeChunkSize;

              if (!this._rangeChunkSize && !this._disableRange) {
                this._disableRange = true;
              }

              if (typeof AbortController !== "undefined") {
                this._abortController = new AbortController();
              }

              this._isStreamingSupported = !source.disableStream;
              this._isRangeSupported = !source.disableRange;
              this._headers = createHeaders(this._stream.httpHeaders);
              var url = source.url;
              fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {
                if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                  throw (0, _network_utils.createResponseStatusError)(response.status, url);
                }

                _this57._reader = response.body.getReader();

                _this57._headersCapability.resolve();

                var getResponseHeader = function getResponseHeader(name) {
                  return response.headers.get(name);
                };

                var _ref34 = (0, _network_utils.validateRangeRequestCapabilities)({
                  getResponseHeader: getResponseHeader,
                  isHttp: _this57._stream.isHttp,
                  rangeChunkSize: _this57._rangeChunkSize,
                  disableRange: _this57._disableRange
                }),
                    allowRangeRequests = _ref34.allowRangeRequests,
                    suggestedLength = _ref34.suggestedLength;

                _this57._isRangeSupported = allowRangeRequests;
                _this57._contentLength = suggestedLength || _this57._contentLength;
                _this57._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

                if (!_this57._isStreamingSupported && _this57._isRangeSupported) {
                  _this57.cancel(new _util.AbortException("Streaming is disabled."));
                }
              })["catch"](this._headersCapability.reject);
              this.onProgress = null;
            }

            _createClass(PDFFetchStreamReader, [{
              key: "read",
              value: function () {
                var _read7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
                  var _yield$this$_reader$r, value, done, buffer;

                  return regeneratorRuntime.wrap(function _callee13$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          _context13.next = 2;
                          return this._headersCapability.promise;

                        case 2:
                          _context13.next = 4;
                          return this._reader.read();

                        case 4:
                          _yield$this$_reader$r = _context13.sent;
                          value = _yield$this$_reader$r.value;
                          done = _yield$this$_reader$r.done;

                          if (!done) {
                            _context13.next = 9;
                            break;
                          }

                          return _context13.abrupt("return", {
                            value: value,
                            done: done
                          });

                        case 9:
                          this._loaded += value.byteLength;

                          if (this.onProgress) {
                            this.onProgress({
                              loaded: this._loaded,
                              total: this._contentLength
                            });
                          }

                          buffer = new Uint8Array(value).buffer;
                          return _context13.abrupt("return", {
                            value: buffer,
                            done: false
                          });

                        case 13:
                        case "end":
                          return _context13.stop();
                      }
                    }
                  }, _callee13, this);
                }));

                function read() {
                  return _read7.apply(this, arguments);
                }

                return read;
              }()
            }, {
              key: "cancel",
              value: function cancel(reason) {
                if (this._reader) {
                  this._reader.cancel(reason);
                }

                if (this._abortController) {
                  this._abortController.abort();
                }
              }
            }, {
              key: "headersReady",
              get: function get() {
                return this._headersCapability.promise;
              }
            }, {
              key: "filename",
              get: function get() {
                return this._filename;
              }
            }, {
              key: "contentLength",
              get: function get() {
                return this._contentLength;
              }
            }, {
              key: "isRangeSupported",
              get: function get() {
                return this._isRangeSupported;
              }
            }, {
              key: "isStreamingSupported",
              get: function get() {
                return this._isStreamingSupported;
              }
            }]);

            return PDFFetchStreamReader;
          }();

          var PDFFetchStreamRangeReader = /*#__PURE__*/function () {
            function PDFFetchStreamRangeReader(stream, begin, end) {
              var _this58 = this;

              _classCallCheck(this, PDFFetchStreamRangeReader);

              this._stream = stream;
              this._reader = null;
              this._loaded = 0;
              var source = stream.source;
              this._withCredentials = source.withCredentials || false;
              this._readCapability = (0, _util.createPromiseCapability)();
              this._isStreamingSupported = !source.disableStream;

              if (typeof AbortController !== "undefined") {
                this._abortController = new AbortController();
              }

              this._headers = createHeaders(this._stream.httpHeaders);

              this._headers.append("Range", "bytes=".concat(begin, "-").concat(end - 1));

              var url = source.url;
              fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {
                if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                  throw (0, _network_utils.createResponseStatusError)(response.status, url);
                }

                _this58._readCapability.resolve();

                _this58._reader = response.body.getReader();
              });
              this.onProgress = null;
            }

            _createClass(PDFFetchStreamRangeReader, [{
              key: "read",
              value: function () {
                var _read8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
                  var _yield$this$_reader$r2, value, done, buffer;

                  return regeneratorRuntime.wrap(function _callee14$(_context14) {
                    while (1) {
                      switch (_context14.prev = _context14.next) {
                        case 0:
                          _context14.next = 2;
                          return this._readCapability.promise;

                        case 2:
                          _context14.next = 4;
                          return this._reader.read();

                        case 4:
                          _yield$this$_reader$r2 = _context14.sent;
                          value = _yield$this$_reader$r2.value;
                          done = _yield$this$_reader$r2.done;

                          if (!done) {
                            _context14.next = 9;
                            break;
                          }

                          return _context14.abrupt("return", {
                            value: value,
                            done: done
                          });

                        case 9:
                          this._loaded += value.byteLength;

                          if (this.onProgress) {
                            this.onProgress({
                              loaded: this._loaded
                            });
                          }

                          buffer = new Uint8Array(value).buffer;
                          return _context14.abrupt("return", {
                            value: buffer,
                            done: false
                          });

                        case 13:
                        case "end":
                          return _context14.stop();
                      }
                    }
                  }, _callee14, this);
                }));

                function read() {
                  return _read8.apply(this, arguments);
                }

                return read;
              }()
            }, {
              key: "cancel",
              value: function cancel(reason) {
                if (this._reader) {
                  this._reader.cancel(reason);
                }

                if (this._abortController) {
                  this._abortController.abort();
                }
              }
            }, {
              key: "isStreamingSupported",
              get: function get() {
                return this._isStreamingSupported;
              }
            }]);

            return PDFFetchStreamRangeReader;
          }();
          /***/

        }
        /******/
        ])
      );
    }); //# sourceMappingURL=pdf.js.map

    /***/

  },

  /***/
  "./node_modules/pdfjs-dist/web/pdf_viewer.js":
  /*!***************************************************!*\
    !*** ./node_modules/pdfjs-dist/web/pdf_viewer.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesPdfjsDistWebPdf_viewerJs(module, exports, __webpack_require__) {
    /**
     * @licstart The following is the entire license notice for the
     * Javascript code in this page
     *
     * Copyright 2020 Mozilla Foundation
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * @licend The above is the entire license notice for the
     * Javascript code in this page
     */
    (function webpackUniversalModuleDefinition(root, factory) {
      if (true) module.exports = factory();else {}
    })(this, function () {
      return (
        /******/
        function (modules) {
          // webpackBootstrap

          /******/
          // The module cache

          /******/
          var installedModules = {};
          /******/

          /******/
          // The require function

          /******/

          function __w_pdfjs_require__(moduleId) {
            /******/

            /******/
            // Check if module is in cache

            /******/
            if (installedModules[moduleId]) {
              /******/
              return installedModules[moduleId].exports;
              /******/
            }
            /******/
            // Create a new module (and put it into the cache)

            /******/


            var module = installedModules[moduleId] = {
              /******/
              i: moduleId,

              /******/
              l: false,

              /******/
              exports: {}
              /******/

            };
            /******/

            /******/
            // Execute the module function

            /******/

            modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
            /******/

            /******/
            // Flag the module as loaded

            /******/

            module.l = true;
            /******/

            /******/
            // Return the exports of the module

            /******/

            return module.exports;
            /******/
          }
          /******/

          /******/

          /******/
          // expose the modules object (__webpack_modules__)

          /******/


          __w_pdfjs_require__.m = modules;
          /******/

          /******/
          // expose the module cache

          /******/

          __w_pdfjs_require__.c = installedModules;
          /******/

          /******/
          // define getter function for harmony exports

          /******/

          __w_pdfjs_require__.d = function (exports, name, getter) {
            /******/
            if (!__w_pdfjs_require__.o(exports, name)) {
              /******/
              Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
              });
              /******/
            }
            /******/

          };
          /******/

          /******/
          // define __esModule on exports

          /******/


          __w_pdfjs_require__.r = function (exports) {
            /******/
            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
              /******/
              Object.defineProperty(exports, Symbol.toStringTag, {
                value: 'Module'
              });
              /******/
            }
            /******/


            Object.defineProperty(exports, '__esModule', {
              value: true
            });
            /******/
          };
          /******/

          /******/
          // create a fake namespace object

          /******/
          // mode & 1: value is a module id, require it

          /******/
          // mode & 2: merge all properties of value into the ns

          /******/
          // mode & 4: return value when already ns object

          /******/
          // mode & 8|1: behave like require

          /******/


          __w_pdfjs_require__.t = function (value, mode) {
            /******/
            if (mode & 1) value = __w_pdfjs_require__(value);
            /******/

            if (mode & 8) return value;
            /******/

            if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
            /******/

            var ns = Object.create(null);
            /******/

            __w_pdfjs_require__.r(ns);
            /******/


            Object.defineProperty(ns, 'default', {
              enumerable: true,
              value: value
            });
            /******/

            if (mode & 2 && typeof value != 'string') for (var key in value) {
              __w_pdfjs_require__.d(ns, key, function (key) {
                return value[key];
              }.bind(null, key));
            }
            /******/

            return ns;
            /******/
          };
          /******/

          /******/
          // getDefaultExport function for compatibility with non-harmony modules

          /******/


          __w_pdfjs_require__.n = function (module) {
            /******/
            var getter = module && module.__esModule ?
            /******/
            function getDefault() {
              return module['default'];
            } :
            /******/
            function getModuleExports() {
              return module;
            };
            /******/

            __w_pdfjs_require__.d(getter, 'a', getter);
            /******/


            return getter;
            /******/
          };
          /******/

          /******/
          // Object.prototype.hasOwnProperty.call

          /******/


          __w_pdfjs_require__.o = function (object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          /******/

          /******/
          // __webpack_public_path__

          /******/


          __w_pdfjs_require__.p = "";
          /******/

          /******/

          /******/
          // Load entry module and return exports

          /******/

          return __w_pdfjs_require__(__w_pdfjs_require__.s = 0);
          /******/
        }(
        /************************************************************************/

        /******/
        [
        /* 0 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          Object.defineProperty(exports, "AnnotationLayerBuilder", {
            enumerable: true,
            get: function get() {
              return _annotation_layer_builder.AnnotationLayerBuilder;
            }
          });
          Object.defineProperty(exports, "DefaultAnnotationLayerFactory", {
            enumerable: true,
            get: function get() {
              return _annotation_layer_builder.DefaultAnnotationLayerFactory;
            }
          });
          Object.defineProperty(exports, "DefaultTextLayerFactory", {
            enumerable: true,
            get: function get() {
              return _text_layer_builder.DefaultTextLayerFactory;
            }
          });
          Object.defineProperty(exports, "TextLayerBuilder", {
            enumerable: true,
            get: function get() {
              return _text_layer_builder.TextLayerBuilder;
            }
          });
          Object.defineProperty(exports, "EventBus", {
            enumerable: true,
            get: function get() {
              return _ui_utils.EventBus;
            }
          });
          Object.defineProperty(exports, "NullL10n", {
            enumerable: true,
            get: function get() {
              return _ui_utils.NullL10n;
            }
          });
          Object.defineProperty(exports, "ProgressBar", {
            enumerable: true,
            get: function get() {
              return _ui_utils.ProgressBar;
            }
          });
          Object.defineProperty(exports, "PDFLinkService", {
            enumerable: true,
            get: function get() {
              return _pdf_link_service.PDFLinkService;
            }
          });
          Object.defineProperty(exports, "SimpleLinkService", {
            enumerable: true,
            get: function get() {
              return _pdf_link_service.SimpleLinkService;
            }
          });
          Object.defineProperty(exports, "DownloadManager", {
            enumerable: true,
            get: function get() {
              return _download_manager.DownloadManager;
            }
          });
          Object.defineProperty(exports, "GenericL10n", {
            enumerable: true,
            get: function get() {
              return _genericl10n.GenericL10n;
            }
          });
          Object.defineProperty(exports, "PDFFindController", {
            enumerable: true,
            get: function get() {
              return _pdf_find_controller.PDFFindController;
            }
          });
          Object.defineProperty(exports, "PDFHistory", {
            enumerable: true,
            get: function get() {
              return _pdf_history.PDFHistory;
            }
          });
          Object.defineProperty(exports, "PDFPageView", {
            enumerable: true,
            get: function get() {
              return _pdf_page_view.PDFPageView;
            }
          });
          Object.defineProperty(exports, "PDFSinglePageViewer", {
            enumerable: true,
            get: function get() {
              return _pdf_single_page_viewer.PDFSinglePageViewer;
            }
          });
          Object.defineProperty(exports, "PDFViewer", {
            enumerable: true,
            get: function get() {
              return _pdf_viewer.PDFViewer;
            }
          });

          var _annotation_layer_builder = __w_pdfjs_require__(1);

          var _text_layer_builder = __w_pdfjs_require__(5);

          var _ui_utils = __w_pdfjs_require__(3);

          var _pdf_link_service = __w_pdfjs_require__(4);

          var _download_manager = __w_pdfjs_require__(6);

          var _genericl10n = __w_pdfjs_require__(7);

          var _pdf_find_controller = __w_pdfjs_require__(9);

          var _pdf_history = __w_pdfjs_require__(11);

          var _pdf_page_view = __w_pdfjs_require__(12);

          var _pdf_single_page_viewer = __w_pdfjs_require__(15);

          var _pdf_viewer = __w_pdfjs_require__(17);

          var pdfjsVersion = '2.4.456';
          var pdfjsBuild = '228a591c';
          /***/
        },
        /* 1 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.DefaultAnnotationLayerFactory = exports.AnnotationLayerBuilder = void 0;

          var _pdfjsLib = __w_pdfjs_require__(2);

          var _ui_utils = __w_pdfjs_require__(3);

          var _pdf_link_service = __w_pdfjs_require__(4);

          var AnnotationLayerBuilder = /*#__PURE__*/function () {
            function AnnotationLayerBuilder(_ref35) {
              var pageDiv = _ref35.pageDiv,
                  pdfPage = _ref35.pdfPage,
                  linkService = _ref35.linkService,
                  downloadManager = _ref35.downloadManager,
                  _ref35$imageResources = _ref35.imageResourcesPath,
                  imageResourcesPath = _ref35$imageResources === void 0 ? "" : _ref35$imageResources,
                  _ref35$renderInteract = _ref35.renderInteractiveForms,
                  renderInteractiveForms = _ref35$renderInteract === void 0 ? false : _ref35$renderInteract,
                  _ref35$l10n = _ref35.l10n,
                  l10n = _ref35$l10n === void 0 ? _ui_utils.NullL10n : _ref35$l10n;

              _classCallCheck(this, AnnotationLayerBuilder);

              this.pageDiv = pageDiv;
              this.pdfPage = pdfPage;
              this.linkService = linkService;
              this.downloadManager = downloadManager;
              this.imageResourcesPath = imageResourcesPath;
              this.renderInteractiveForms = renderInteractiveForms;
              this.l10n = l10n;
              this.div = null;
              this._cancelled = false;
            }

            _createClass(AnnotationLayerBuilder, [{
              key: "render",
              value: function render(viewport) {
                var _this59 = this;

                var intent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "display";
                this.pdfPage.getAnnotations({
                  intent: intent
                }).then(function (annotations) {
                  if (_this59._cancelled) {
                    return;
                  }

                  var parameters = {
                    viewport: viewport.clone({
                      dontFlip: true
                    }),
                    div: _this59.div,
                    annotations: annotations,
                    page: _this59.pdfPage,
                    imageResourcesPath: _this59.imageResourcesPath,
                    renderInteractiveForms: _this59.renderInteractiveForms,
                    linkService: _this59.linkService,
                    downloadManager: _this59.downloadManager
                  };

                  if (_this59.div) {
                    _pdfjsLib.AnnotationLayer.update(parameters);
                  } else {
                    if (annotations.length === 0) {
                      return;
                    }

                    _this59.div = document.createElement("div");
                    _this59.div.className = "annotationLayer";

                    _this59.pageDiv.appendChild(_this59.div);

                    parameters.div = _this59.div;

                    _pdfjsLib.AnnotationLayer.render(parameters);

                    _this59.l10n.translate(_this59.div);
                  }
                });
              }
            }, {
              key: "cancel",
              value: function cancel() {
                this._cancelled = true;
              }
            }, {
              key: "hide",
              value: function hide() {
                if (!this.div) {
                  return;
                }

                this.div.setAttribute("hidden", "true");
              }
            }]);

            return AnnotationLayerBuilder;
          }();

          exports.AnnotationLayerBuilder = AnnotationLayerBuilder;

          var DefaultAnnotationLayerFactory = /*#__PURE__*/function () {
            function DefaultAnnotationLayerFactory() {
              _classCallCheck(this, DefaultAnnotationLayerFactory);
            }

            _createClass(DefaultAnnotationLayerFactory, [{
              key: "createAnnotationLayerBuilder",
              value: function createAnnotationLayerBuilder(pageDiv, pdfPage) {
                var imageResourcesPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
                var renderInteractiveForms = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                var l10n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _ui_utils.NullL10n;
                return new AnnotationLayerBuilder({
                  pageDiv: pageDiv,
                  pdfPage: pdfPage,
                  imageResourcesPath: imageResourcesPath,
                  renderInteractiveForms: renderInteractiveForms,
                  linkService: new _pdf_link_service.SimpleLinkService(),
                  l10n: l10n
                });
              }
            }]);

            return DefaultAnnotationLayerFactory;
          }();

          exports.DefaultAnnotationLayerFactory = DefaultAnnotationLayerFactory;
          /***/
        },
        /* 2 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          var pdfjsLib;

          if (typeof window !== "undefined" && window["pdfjs-dist/build/pdf"]) {
            pdfjsLib = window["pdfjs-dist/build/pdf"];
          } else {
            pdfjsLib = __webpack_require__(
            /*! ../build/pdf.js */
            "./node_modules/pdfjs-dist/build/pdf.js");
          }

          module.exports = pdfjsLib;
          /***/
        },
        /* 3 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.isValidRotation = isValidRotation;
          exports.isValidScrollMode = isValidScrollMode;
          exports.isValidSpreadMode = isValidSpreadMode;
          exports.isPortraitOrientation = isPortraitOrientation;
          exports.getGlobalEventBus = getGlobalEventBus;
          exports.clamp = clamp;
          exports.getPDFFileNameFromURL = getPDFFileNameFromURL;
          exports.noContextMenuHandler = noContextMenuHandler;
          exports.parseQueryString = parseQueryString;
          exports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;
          exports.getVisibleElements = getVisibleElements;
          exports.roundToDivide = roundToDivide;
          exports.getPageSizeInches = getPageSizeInches;
          exports.approximateFraction = approximateFraction;
          exports.getOutputScale = getOutputScale;
          exports.scrollIntoView = scrollIntoView;
          exports.watchScroll = watchScroll;
          exports.binarySearchFirstItem = binarySearchFirstItem;
          exports.normalizeWheelEventDelta = normalizeWheelEventDelta;
          exports.waitOnEventOrTimeout = waitOnEventOrTimeout;
          exports.moveToEndOfArray = moveToEndOfArray;
          exports.WaitOnType = exports.animationStarted = exports.ProgressBar = exports.EventBus = exports.NullL10n = exports.SpreadMode = exports.ScrollMode = exports.TextLayerMode = exports.RendererType = exports.PresentationModeState = exports.VERTICAL_PADDING = exports.SCROLLBAR_PADDING = exports.MAX_AUTO_SCALE = exports.UNKNOWN_SCALE = exports.MAX_SCALE = exports.MIN_SCALE = exports.DEFAULT_SCALE = exports.DEFAULT_SCALE_VALUE = exports.CSS_UNITS = exports.AutoPrintRegExp = void 0;
          var CSS_UNITS = 96.0 / 72.0;
          exports.CSS_UNITS = CSS_UNITS;
          var DEFAULT_SCALE_VALUE = "auto";
          exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
          var DEFAULT_SCALE = 1.0;
          exports.DEFAULT_SCALE = DEFAULT_SCALE;
          var MIN_SCALE = 0.1;
          exports.MIN_SCALE = MIN_SCALE;
          var MAX_SCALE = 10.0;
          exports.MAX_SCALE = MAX_SCALE;
          var UNKNOWN_SCALE = 0;
          exports.UNKNOWN_SCALE = UNKNOWN_SCALE;
          var MAX_AUTO_SCALE = 1.25;
          exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
          var SCROLLBAR_PADDING = 40;
          exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
          var VERTICAL_PADDING = 5;
          exports.VERTICAL_PADDING = VERTICAL_PADDING;
          var PresentationModeState = {
            UNKNOWN: 0,
            NORMAL: 1,
            CHANGING: 2,
            FULLSCREEN: 3
          };
          exports.PresentationModeState = PresentationModeState;
          var RendererType = {
            CANVAS: "canvas",
            SVG: "svg"
          };
          exports.RendererType = RendererType;
          var TextLayerMode = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_ENHANCE: 2
          };
          exports.TextLayerMode = TextLayerMode;
          var ScrollMode = {
            UNKNOWN: -1,
            VERTICAL: 0,
            HORIZONTAL: 1,
            WRAPPED: 2
          };
          exports.ScrollMode = ScrollMode;
          var SpreadMode = {
            UNKNOWN: -1,
            NONE: 0,
            ODD: 1,
            EVEN: 2
          };
          exports.SpreadMode = SpreadMode;
          var AutoPrintRegExp = /\bprint\s*\(/;
          exports.AutoPrintRegExp = AutoPrintRegExp;

          function formatL10nValue(text, args) {
            if (!args) {
              return text;
            }

            return text.replace(/\{\{\s*(\w+)\s*\}\}/g, function (all, name) {
              return name in args ? args[name] : "{{" + name + "}}";
            });
          }

          var NullL10n = {
            getLanguage: function getLanguage() {
              return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
                return regeneratorRuntime.wrap(function _callee15$(_context15) {
                  while (1) {
                    switch (_context15.prev = _context15.next) {
                      case 0:
                        return _context15.abrupt("return", "en-us");

                      case 1:
                      case "end":
                        return _context15.stop();
                    }
                  }
                }, _callee15);
              }))();
            },
            getDirection: function getDirection() {
              return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
                return regeneratorRuntime.wrap(function _callee16$(_context16) {
                  while (1) {
                    switch (_context16.prev = _context16.next) {
                      case 0:
                        return _context16.abrupt("return", "ltr");

                      case 1:
                      case "end":
                        return _context16.stop();
                    }
                  }
                }, _callee16);
              }))();
            },
            get: function get(property, args, fallback) {
              return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
                return regeneratorRuntime.wrap(function _callee17$(_context17) {
                  while (1) {
                    switch (_context17.prev = _context17.next) {
                      case 0:
                        return _context17.abrupt("return", formatL10nValue(fallback, args));

                      case 1:
                      case "end":
                        return _context17.stop();
                    }
                  }
                }, _callee17);
              }))();
            },
            translate: function translate(element) {
              return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
                return regeneratorRuntime.wrap(function _callee18$(_context18) {
                  while (1) {
                    switch (_context18.prev = _context18.next) {
                      case 0:
                      case "end":
                        return _context18.stop();
                    }
                  }
                }, _callee18);
              }))();
            }
          };
          exports.NullL10n = NullL10n;

          function getOutputScale(ctx) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
            var pixelRatio = devicePixelRatio / backingStoreRatio;
            return {
              sx: pixelRatio,
              sy: pixelRatio,
              scaled: pixelRatio !== 1
            };
          }

          function scrollIntoView(element, spot) {
            var skipOverflowHiddenElements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var parent = element.offsetParent;

            if (!parent) {
              console.error("offsetParent is not set -- cannot scroll");
              return;
            }

            var offsetY = element.offsetTop + element.clientTop;
            var offsetX = element.offsetLeft + element.clientLeft;

            while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || skipOverflowHiddenElements && getComputedStyle(parent).overflow === "hidden") {
              if (parent.dataset._scaleY) {
                offsetY /= parent.dataset._scaleY;
                offsetX /= parent.dataset._scaleX;
              }

              offsetY += parent.offsetTop;
              offsetX += parent.offsetLeft;
              parent = parent.offsetParent;

              if (!parent) {
                return;
              }
            }

            if (spot) {
              if (spot.top !== undefined) {
                offsetY += spot.top;
              }

              if (spot.left !== undefined) {
                offsetX += spot.left;
                parent.scrollLeft = offsetX;
              }
            }

            parent.scrollTop = offsetY;
          }

          function watchScroll(viewAreaElement, callback) {
            var debounceScroll = function debounceScroll(evt) {
              if (rAF) {
                return;
              }

              rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
                rAF = null;
                var currentX = viewAreaElement.scrollLeft;
                var lastX = state.lastX;

                if (currentX !== lastX) {
                  state.right = currentX > lastX;
                }

                state.lastX = currentX;
                var currentY = viewAreaElement.scrollTop;
                var lastY = state.lastY;

                if (currentY !== lastY) {
                  state.down = currentY > lastY;
                }

                state.lastY = currentY;
                callback(state);
              });
            };

            var state = {
              right: true,
              down: true,
              lastX: viewAreaElement.scrollLeft,
              lastY: viewAreaElement.scrollTop,
              _eventHandler: debounceScroll
            };
            var rAF = null;
            viewAreaElement.addEventListener("scroll", debounceScroll, true);
            return state;
          }

          function parseQueryString(query) {
            var parts = query.split("&");
            var params = Object.create(null);

            for (var i = 0, ii = parts.length; i < ii; ++i) {
              var param = parts[i].split("=");
              var key = param[0].toLowerCase();
              var value = param.length > 1 ? param[1] : null;
              params[decodeURIComponent(key)] = decodeURIComponent(value);
            }

            return params;
          }

          function binarySearchFirstItem(items, condition) {
            var minIndex = 0;
            var maxIndex = items.length - 1;

            if (items.length === 0 || !condition(items[maxIndex])) {
              return items.length;
            }

            if (condition(items[minIndex])) {
              return minIndex;
            }

            while (minIndex < maxIndex) {
              var currentIndex = minIndex + maxIndex >> 1;
              var currentItem = items[currentIndex];

              if (condition(currentItem)) {
                maxIndex = currentIndex;
              } else {
                minIndex = currentIndex + 1;
              }
            }

            return minIndex;
          }

          function approximateFraction(x) {
            if (Math.floor(x) === x) {
              return [x, 1];
            }

            var xinv = 1 / x;
            var limit = 8;

            if (xinv > limit) {
              return [1, limit];
            } else if (Math.floor(xinv) === xinv) {
              return [1, xinv];
            }

            var x_ = x > 1 ? xinv : x;
            var a = 0,
                b = 1,
                c = 1,
                d = 1;

            while (true) {
              var p = a + c,
                  q = b + d;

              if (q > limit) {
                break;
              }

              if (x_ <= p / q) {
                c = p;
                d = q;
              } else {
                a = p;
                b = q;
              }
            }

            var result;

            if (x_ - a / b < c / d - x_) {
              result = x_ === x ? [a, b] : [b, a];
            } else {
              result = x_ === x ? [c, d] : [d, c];
            }

            return result;
          }

          function roundToDivide(x, div) {
            var r = x % div;
            return r === 0 ? x : Math.round(x - r + div);
          }

          function getPageSizeInches(_ref36) {
            var view = _ref36.view,
                userUnit = _ref36.userUnit,
                rotate = _ref36.rotate;

            var _view = _slicedToArray(view, 4),
                x1 = _view[0],
                y1 = _view[1],
                x2 = _view[2],
                y2 = _view[3];

            var changeOrientation = rotate % 180 !== 0;
            var width = (x2 - x1) / 72 * userUnit;
            var height = (y2 - y1) / 72 * userUnit;
            return {
              width: changeOrientation ? height : width,
              height: changeOrientation ? width : height
            };
          }

          function backtrackBeforeAllVisibleElements(index, views, top) {
            if (index < 2) {
              return index;
            }

            var elt = views[index].div;
            var pageTop = elt.offsetTop + elt.clientTop;

            if (pageTop >= top) {
              elt = views[index - 1].div;
              pageTop = elt.offsetTop + elt.clientTop;
            }

            for (var i = index - 2; i >= 0; --i) {
              elt = views[i].div;

              if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
                break;
              }

              index = i;
            }

            return index;
          }

          function getVisibleElements(scrollEl, views) {
            var sortByVisibility = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var horizontal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            var top = scrollEl.scrollTop,
                bottom = top + scrollEl.clientHeight;
            var left = scrollEl.scrollLeft,
                right = left + scrollEl.clientWidth;

            function isElementBottomAfterViewTop(view) {
              var element = view.div;
              var elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
              return elementBottom > top;
            }

            function isElementRightAfterViewLeft(view) {
              var element = view.div;
              var elementRight = element.offsetLeft + element.clientLeft + element.clientWidth;
              return elementRight > left;
            }

            var visible = [],
                numViews = views.length;
            var firstVisibleElementInd = numViews === 0 ? 0 : binarySearchFirstItem(views, horizontal ? isElementRightAfterViewLeft : isElementBottomAfterViewTop);

            if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
              firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
            }

            var lastEdge = horizontal ? right : -1;

            for (var i = firstVisibleElementInd; i < numViews; i++) {
              var view = views[i],
                  element = view.div;
              var currentWidth = element.offsetLeft + element.clientLeft;
              var currentHeight = element.offsetTop + element.clientTop;
              var viewWidth = element.clientWidth,
                  viewHeight = element.clientHeight;
              var viewRight = currentWidth + viewWidth;
              var viewBottom = currentHeight + viewHeight;

              if (lastEdge === -1) {
                if (viewBottom >= bottom) {
                  lastEdge = viewBottom;
                }
              } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
                break;
              }

              if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
                continue;
              }

              var hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
              var hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
              var percent = (viewHeight - hiddenHeight) * (viewWidth - hiddenWidth) * 100 / viewHeight / viewWidth | 0;
              visible.push({
                id: view.id,
                x: currentWidth,
                y: currentHeight,
                view: view,
                percent: percent
              });
            }

            var first = visible[0],
                last = visible[visible.length - 1];

            if (sortByVisibility) {
              visible.sort(function (a, b) {
                var pc = a.percent - b.percent;

                if (Math.abs(pc) > 0.001) {
                  return -pc;
                }

                return a.id - b.id;
              });
            }

            return {
              first: first,
              last: last,
              views: visible
            };
          }

          function noContextMenuHandler(evt) {
            evt.preventDefault();
          }

          function isDataSchema(url) {
            var i = 0;
            var ii = url.length;

            while (i < ii && url[i].trim() === "") {
              i++;
            }

            return url.substring(i, i + 5).toLowerCase() === "data:";
          }

          function getPDFFileNameFromURL(url) {
            var defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "document.pdf";

            if (typeof url !== "string") {
              return defaultFilename;
            }

            if (isDataSchema(url)) {
              console.warn("getPDFFileNameFromURL: " + 'ignoring "data:" URL for performance reasons.');
              return defaultFilename;
            }

            var reURI = /^(?:(?:[^:]+:)?\/\/[^\/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
            var reFilename = /[^\/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
            var splitURI = reURI.exec(url);
            var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);

            if (suggestedFilename) {
              suggestedFilename = suggestedFilename[0];

              if (suggestedFilename.includes("%")) {
                try {
                  suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                } catch (ex) {}
              }
            }

            return suggestedFilename || defaultFilename;
          }

          function normalizeWheelEventDelta(evt) {
            var delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY);
            var angle = Math.atan2(evt.deltaY, evt.deltaX);

            if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
              delta = -delta;
            }

            var MOUSE_DOM_DELTA_PIXEL_MODE = 0;
            var MOUSE_DOM_DELTA_LINE_MODE = 1;
            var MOUSE_PIXELS_PER_LINE = 30;
            var MOUSE_LINES_PER_PAGE = 30;

            if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
              delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
            } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
              delta /= MOUSE_LINES_PER_PAGE;
            }

            return delta;
          }

          function isValidRotation(angle) {
            return Number.isInteger(angle) && angle % 90 === 0;
          }

          function isValidScrollMode(mode) {
            return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
          }

          function isValidSpreadMode(mode) {
            return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
          }

          function isPortraitOrientation(size) {
            return size.width <= size.height;
          }

          var WaitOnType = {
            EVENT: "event",
            TIMEOUT: "timeout"
          };
          exports.WaitOnType = WaitOnType;

          function waitOnEventOrTimeout(_ref37) {
            var target = _ref37.target,
                name = _ref37.name,
                _ref37$delay = _ref37.delay,
                delay = _ref37$delay === void 0 ? 0 : _ref37$delay;
            return new Promise(function (resolve, reject) {
              if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
                throw new Error("waitOnEventOrTimeout - invalid parameters.");
              }

              function handler(type) {
                if (target instanceof EventBus) {
                  target._off(name, eventHandler);
                } else {
                  target.removeEventListener(name, eventHandler);
                }

                if (timeout) {
                  clearTimeout(timeout);
                }

                resolve(type);
              }

              var eventHandler = handler.bind(null, WaitOnType.EVENT);

              if (target instanceof EventBus) {
                target._on(name, eventHandler);
              } else {
                target.addEventListener(name, eventHandler);
              }

              var timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
              var timeout = setTimeout(timeoutHandler, delay);
            });
          }

          var animationStarted = new Promise(function (resolve) {
            window.requestAnimationFrame(resolve);
          });
          exports.animationStarted = animationStarted;

          function dispatchDOMEvent(eventName) {
            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var details = Object.create(null);

            if (args && args.length > 0) {
              var obj = args[0];

              for (var key in obj) {
                var value = obj[key];

                if (key === "source") {
                  if (value === window || value === document) {
                    return;
                  }

                  continue;
                }

                details[key] = value;
              }
            }

            var event = document.createEvent("CustomEvent");
            event.initCustomEvent(eventName, true, true, details);
            document.dispatchEvent(event);
          }

          var EventBus = /*#__PURE__*/function () {
            function EventBus() {
              var _ref38 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  _ref38$dispatchToDOM = _ref38.dispatchToDOM,
                  dispatchToDOM = _ref38$dispatchToDOM === void 0 ? false : _ref38$dispatchToDOM;

              _classCallCheck(this, EventBus);

              this._listeners = Object.create(null);
              this._dispatchToDOM = dispatchToDOM === true;

              if (dispatchToDOM) {
                console.error("The `eventBusDispatchToDOM` option/preference is deprecated, " + "add event listeners to the EventBus instance rather than the DOM.");
              }
            }

            _createClass(EventBus, [{
              key: "on",
              value: function on(eventName, listener) {
                this._on(eventName, listener, {
                  external: true
                });
              }
            }, {
              key: "off",
              value: function off(eventName, listener) {
                this._off(eventName, listener, {
                  external: true
                });
              }
            }, {
              key: "dispatch",
              value: function dispatch(eventName) {
                var eventListeners = this._listeners[eventName];

                if (!eventListeners || eventListeners.length === 0) {
                  if (this._dispatchToDOM) {
                    var _args19 = Array.prototype.slice.call(arguments, 1);

                    dispatchDOMEvent(eventName, _args19);
                  }

                  return;
                }

                var args = Array.prototype.slice.call(arguments, 1);
                var externalListeners;
                eventListeners.slice(0).forEach(function (_ref39) {
                  var listener = _ref39.listener,
                      external = _ref39.external;

                  if (external) {
                    if (!externalListeners) {
                      externalListeners = [];
                    }

                    externalListeners.push(listener);
                    return;
                  }

                  listener.apply(null, args);
                });

                if (externalListeners) {
                  externalListeners.forEach(function (listener) {
                    listener.apply(null, args);
                  });
                  externalListeners = null;
                }

                if (this._dispatchToDOM) {
                  dispatchDOMEvent(eventName, args);
                }
              }
            }, {
              key: "_on",
              value: function _on(eventName, listener) {
                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var eventListeners = this._listeners[eventName];

                if (!eventListeners) {
                  this._listeners[eventName] = eventListeners = [];
                }

                eventListeners.push({
                  listener: listener,
                  external: (options && options.external) === true
                });
              }
            }, {
              key: "_off",
              value: function _off(eventName, listener) {
                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var eventListeners = this._listeners[eventName];

                if (!eventListeners) {
                  return;
                }

                for (var i = 0, ii = eventListeners.length; i < ii; i++) {
                  if (eventListeners[i].listener === listener) {
                    eventListeners.splice(i, 1);
                    return;
                  }
                }
              }
            }]);

            return EventBus;
          }();

          exports.EventBus = EventBus;
          var globalEventBus = null;

          function getGlobalEventBus() {
            var dispatchToDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            console.error("getGlobalEventBus is deprecated, use a manually created EventBus instance instead.");

            if (!globalEventBus) {
              globalEventBus = new EventBus({
                dispatchToDOM: dispatchToDOM
              });
            }

            return globalEventBus;
          }

          function clamp(v, min, max) {
            return Math.min(Math.max(v, min), max);
          }

          var ProgressBar = /*#__PURE__*/function () {
            function ProgressBar(id) {
              var _ref40 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                  height = _ref40.height,
                  width = _ref40.width,
                  units = _ref40.units;

              _classCallCheck(this, ProgressBar);

              this.visible = true;
              this.div = document.querySelector(id + " .progress");
              this.bar = this.div.parentNode;
              this.height = height || 100;
              this.width = width || 100;
              this.units = units || "%";
              this.div.style.height = this.height + this.units;
              this.percent = 0;
            }

            _createClass(ProgressBar, [{
              key: "_updateBar",
              value: function _updateBar() {
                if (this._indeterminate) {
                  this.div.classList.add("indeterminate");
                  this.div.style.width = this.width + this.units;
                  return;
                }

                this.div.classList.remove("indeterminate");
                var progressSize = this.width * this._percent / 100;
                this.div.style.width = progressSize + this.units;
              }
            }, {
              key: "setWidth",
              value: function setWidth(viewer) {
                if (!viewer) {
                  return;
                }

                var container = viewer.parentNode;
                var scrollbarWidth = container.offsetWidth - viewer.offsetWidth;

                if (scrollbarWidth > 0) {
                  this.bar.style.width = "calc(100% - ".concat(scrollbarWidth, "px)");
                }
              }
            }, {
              key: "hide",
              value: function hide() {
                if (!this.visible) {
                  return;
                }

                this.visible = false;
                this.bar.classList.add("hidden");
                document.body.classList.remove("loadingInProgress");
              }
            }, {
              key: "show",
              value: function show() {
                if (this.visible) {
                  return;
                }

                this.visible = true;
                document.body.classList.add("loadingInProgress");
                this.bar.classList.remove("hidden");
              }
            }, {
              key: "percent",
              get: function get() {
                return this._percent;
              },
              set: function set(val) {
                this._indeterminate = isNaN(val);
                this._percent = clamp(val, 0, 100);

                this._updateBar();
              }
            }]);

            return ProgressBar;
          }();

          exports.ProgressBar = ProgressBar;

          function moveToEndOfArray(arr, condition) {
            var moved = [],
                len = arr.length;
            var write = 0;

            for (var read = 0; read < len; ++read) {
              if (condition(arr[read])) {
                moved.push(arr[read]);
              } else {
                arr[write] = arr[read];
                ++write;
              }
            }

            for (var _read9 = 0; write < len; ++_read9, ++write) {
              arr[write] = moved[_read9];
            }
          }
          /***/

        },
        /* 4 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SimpleLinkService = exports.PDFLinkService = void 0;

          var _ui_utils = __w_pdfjs_require__(3);

          var PDFLinkService = /*#__PURE__*/function () {
            function PDFLinkService() {
              var _ref41 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  eventBus = _ref41.eventBus,
                  _ref41$externalLinkTa = _ref41.externalLinkTarget,
                  externalLinkTarget = _ref41$externalLinkTa === void 0 ? null : _ref41$externalLinkTa,
                  _ref41$externalLinkRe = _ref41.externalLinkRel,
                  externalLinkRel = _ref41$externalLinkRe === void 0 ? null : _ref41$externalLinkRe,
                  _ref41$externalLinkEn = _ref41.externalLinkEnabled,
                  externalLinkEnabled = _ref41$externalLinkEn === void 0 ? true : _ref41$externalLinkEn,
                  _ref41$ignoreDestinat = _ref41.ignoreDestinationZoom,
                  ignoreDestinationZoom = _ref41$ignoreDestinat === void 0 ? false : _ref41$ignoreDestinat;

              _classCallCheck(this, PDFLinkService);

              this.eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();
              this.externalLinkTarget = externalLinkTarget;
              this.externalLinkRel = externalLinkRel;
              this.externalLinkEnabled = externalLinkEnabled;
              this._ignoreDestinationZoom = ignoreDestinationZoom;
              this.baseUrl = null;
              this.pdfDocument = null;
              this.pdfViewer = null;
              this.pdfHistory = null;
              this._pagesRefCache = null;
            }

            _createClass(PDFLinkService, [{
              key: "setDocument",
              value: function setDocument(pdfDocument) {
                var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                this.baseUrl = baseUrl;
                this.pdfDocument = pdfDocument;
                this._pagesRefCache = Object.create(null);
              }
            }, {
              key: "setViewer",
              value: function setViewer(pdfViewer) {
                this.pdfViewer = pdfViewer;
              }
            }, {
              key: "setHistory",
              value: function setHistory(pdfHistory) {
                this.pdfHistory = pdfHistory;
              }
            }, {
              key: "navigateTo",
              value: function navigateTo(dest) {
                var _this60 = this;

                var goToDestination = function goToDestination(_ref42) {
                  var namedDest = _ref42.namedDest,
                      explicitDest = _ref42.explicitDest;
                  var destRef = explicitDest[0];
                  var pageNumber;

                  if (destRef instanceof Object) {
                    pageNumber = _this60._cachedPageNumber(destRef);

                    if (pageNumber === null) {
                      _this60.pdfDocument.getPageIndex(destRef).then(function (pageIndex) {
                        _this60.cachePageRef(pageIndex + 1, destRef);

                        goToDestination({
                          namedDest: namedDest,
                          explicitDest: explicitDest
                        });
                      })["catch"](function () {
                        console.error("PDFLinkService.navigateTo: \"".concat(destRef, "\" is not ") + "a valid page reference, for dest=\"".concat(dest, "\"."));
                      });

                      return;
                    }
                  } else if (Number.isInteger(destRef)) {
                    pageNumber = destRef + 1;
                  } else {
                    console.error("PDFLinkService.navigateTo: \"".concat(destRef, "\" is not ") + "a valid destination reference, for dest=\"".concat(dest, "\"."));
                    return;
                  }

                  if (!pageNumber || pageNumber < 1 || pageNumber > _this60.pagesCount) {
                    console.error("PDFLinkService.navigateTo: \"".concat(pageNumber, "\" is not ") + "a valid page number, for dest=\"".concat(dest, "\"."));
                    return;
                  }

                  if (_this60.pdfHistory) {
                    _this60.pdfHistory.pushCurrentPosition();

                    _this60.pdfHistory.push({
                      namedDest: namedDest,
                      explicitDest: explicitDest,
                      pageNumber: pageNumber
                    });
                  }

                  _this60.pdfViewer.scrollPageIntoView({
                    pageNumber: pageNumber,
                    destArray: explicitDest,
                    ignoreDestinationZoom: _this60._ignoreDestinationZoom
                  });
                };

                new Promise(function (resolve, reject) {
                  if (typeof dest === "string") {
                    _this60.pdfDocument.getDestination(dest).then(function (destArray) {
                      resolve({
                        namedDest: dest,
                        explicitDest: destArray
                      });
                    });

                    return;
                  }

                  resolve({
                    namedDest: "",
                    explicitDest: dest
                  });
                }).then(function (data) {
                  if (!Array.isArray(data.explicitDest)) {
                    console.error("PDFLinkService.navigateTo: \"".concat(data.explicitDest, "\" is") + " not a valid destination array, for dest=\"".concat(dest, "\"."));
                    return;
                  }

                  goToDestination(data);
                });
              }
            }, {
              key: "getDestinationHash",
              value: function getDestinationHash(dest) {
                if (typeof dest === "string") {
                  return this.getAnchorUrl("#" + escape(dest));
                }

                if (Array.isArray(dest)) {
                  var str = JSON.stringify(dest);
                  return this.getAnchorUrl("#" + escape(str));
                }

                return this.getAnchorUrl("");
              }
            }, {
              key: "getAnchorUrl",
              value: function getAnchorUrl(anchor) {
                return (this.baseUrl || "") + anchor;
              }
            }, {
              key: "setHash",
              value: function setHash(hash) {
                var pageNumber, dest;

                if (hash.includes("=")) {
                  var params = (0, _ui_utils.parseQueryString)(hash);

                  if ("search" in params) {
                    this.eventBus.dispatch("findfromurlhash", {
                      source: this,
                      query: params["search"].replace(/"/g, ""),
                      phraseSearch: params["phrase"] === "true"
                    });
                  }

                  if ("nameddest" in params) {
                    this.navigateTo(params.nameddest);
                    return;
                  }

                  if ("page" in params) {
                    pageNumber = params.page | 0 || 1;
                  }

                  if ("zoom" in params) {
                    var zoomArgs = params.zoom.split(",");
                    var zoomArg = zoomArgs[0];
                    var zoomArgNumber = parseFloat(zoomArg);

                    if (!zoomArg.includes("Fit")) {
                      dest = [null, {
                        name: "XYZ"
                      }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
                    } else {
                      if (zoomArg === "Fit" || zoomArg === "FitB") {
                        dest = [null, {
                          name: zoomArg
                        }];
                      } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
                        dest = [null, {
                          name: zoomArg
                        }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
                      } else if (zoomArg === "FitR") {
                        if (zoomArgs.length !== 5) {
                          console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
                        } else {
                          dest = [null, {
                            name: zoomArg
                          }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
                        }
                      } else {
                        console.error("PDFLinkService.setHash: \"".concat(zoomArg, "\" is not ") + "a valid zoom value.");
                      }
                    }
                  }

                  if (dest) {
                    this.pdfViewer.scrollPageIntoView({
                      pageNumber: pageNumber || this.page,
                      destArray: dest,
                      allowNegativeOffset: true
                    });
                  } else if (pageNumber) {
                    this.page = pageNumber;
                  }

                  if ("pagemode" in params) {
                    this.eventBus.dispatch("pagemode", {
                      source: this,
                      mode: params.pagemode
                    });
                  }
                } else {
                  dest = unescape(hash);

                  try {
                    dest = JSON.parse(dest);

                    if (!Array.isArray(dest)) {
                      dest = dest.toString();
                    }
                  } catch (ex) {}

                  if (typeof dest === "string" || isValidExplicitDestination(dest)) {
                    this.navigateTo(dest);
                    return;
                  }

                  console.error("PDFLinkService.setHash: \"".concat(unescape(hash), "\" is not ") + "a valid destination.");
                }
              }
            }, {
              key: "executeNamedAction",
              value: function executeNamedAction(action) {
                switch (action) {
                  case "GoBack":
                    if (this.pdfHistory) {
                      this.pdfHistory.back();
                    }

                    break;

                  case "GoForward":
                    if (this.pdfHistory) {
                      this.pdfHistory.forward();
                    }

                    break;

                  case "NextPage":
                    if (this.page < this.pagesCount) {
                      this.page++;
                    }

                    break;

                  case "PrevPage":
                    if (this.page > 1) {
                      this.page--;
                    }

                    break;

                  case "LastPage":
                    this.page = this.pagesCount;
                    break;

                  case "FirstPage":
                    this.page = 1;
                    break;

                  default:
                    break;
                }

                this.eventBus.dispatch("namedaction", {
                  source: this,
                  action: action
                });
              }
            }, {
              key: "cachePageRef",
              value: function cachePageRef(pageNum, pageRef) {
                if (!pageRef) {
                  return;
                }

                var refStr = pageRef.gen === 0 ? "".concat(pageRef.num, "R") : "".concat(pageRef.num, "R").concat(pageRef.gen);
                this._pagesRefCache[refStr] = pageNum;
              }
            }, {
              key: "_cachedPageNumber",
              value: function _cachedPageNumber(pageRef) {
                var refStr = pageRef.gen === 0 ? "".concat(pageRef.num, "R") : "".concat(pageRef.num, "R").concat(pageRef.gen);
                return this._pagesRefCache && this._pagesRefCache[refStr] || null;
              }
            }, {
              key: "isPageVisible",
              value: function isPageVisible(pageNumber) {
                return this.pdfViewer.isPageVisible(pageNumber);
              }
            }, {
              key: "pagesCount",
              get: function get() {
                return this.pdfDocument ? this.pdfDocument.numPages : 0;
              }
            }, {
              key: "page",
              get: function get() {
                return this.pdfViewer.currentPageNumber;
              },
              set: function set(value) {
                this.pdfViewer.currentPageNumber = value;
              }
            }, {
              key: "rotation",
              get: function get() {
                return this.pdfViewer.pagesRotation;
              },
              set: function set(value) {
                this.pdfViewer.pagesRotation = value;
              }
            }]);

            return PDFLinkService;
          }();

          exports.PDFLinkService = PDFLinkService;

          function isValidExplicitDestination(dest) {
            if (!Array.isArray(dest)) {
              return false;
            }

            var destLength = dest.length;

            if (destLength < 2) {
              return false;
            }

            var page = dest[0];

            if (!(typeof page === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
              return false;
            }

            var zoom = dest[1];

            if (!(typeof zoom === "object" && typeof zoom.name === "string")) {
              return false;
            }

            var allowNull = true;

            switch (zoom.name) {
              case "XYZ":
                if (destLength !== 5) {
                  return false;
                }

                break;

              case "Fit":
              case "FitB":
                return destLength === 2;

              case "FitH":
              case "FitBH":
              case "FitV":
              case "FitBV":
                if (destLength !== 3) {
                  return false;
                }

                break;

              case "FitR":
                if (destLength !== 6) {
                  return false;
                }

                allowNull = false;
                break;

              default:
                return false;
            }

            for (var i = 2; i < destLength; i++) {
              var param = dest[i];

              if (!(typeof param === "number" || allowNull && param === null)) {
                return false;
              }
            }

            return true;
          }

          var SimpleLinkService = /*#__PURE__*/function () {
            function SimpleLinkService() {
              _classCallCheck(this, SimpleLinkService);

              this.externalLinkTarget = null;
              this.externalLinkRel = null;
              this.externalLinkEnabled = true;
              this._ignoreDestinationZoom = false;
            }

            _createClass(SimpleLinkService, [{
              key: "navigateTo",
              value: function navigateTo(dest) {}
            }, {
              key: "getDestinationHash",
              value: function getDestinationHash(dest) {
                return "#";
              }
            }, {
              key: "getAnchorUrl",
              value: function getAnchorUrl(hash) {
                return "#";
              }
            }, {
              key: "setHash",
              value: function setHash(hash) {}
            }, {
              key: "executeNamedAction",
              value: function executeNamedAction(action) {}
            }, {
              key: "cachePageRef",
              value: function cachePageRef(pageNum, pageRef) {}
            }, {
              key: "isPageVisible",
              value: function isPageVisible(pageNumber) {
                return true;
              }
            }, {
              key: "pagesCount",
              get: function get() {
                return 0;
              }
            }, {
              key: "page",
              get: function get() {
                return 0;
              },
              set: function set(value) {}
            }, {
              key: "rotation",
              get: function get() {
                return 0;
              },
              set: function set(value) {}
            }]);

            return SimpleLinkService;
          }();

          exports.SimpleLinkService = SimpleLinkService;
          /***/
        },
        /* 5 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.DefaultTextLayerFactory = exports.TextLayerBuilder = void 0;

          var _ui_utils = __w_pdfjs_require__(3);

          var _pdfjsLib = __w_pdfjs_require__(2);

          var EXPAND_DIVS_TIMEOUT = 300;

          var TextLayerBuilder = /*#__PURE__*/function () {
            function TextLayerBuilder(_ref43) {
              var textLayerDiv = _ref43.textLayerDiv,
                  eventBus = _ref43.eventBus,
                  pageIndex = _ref43.pageIndex,
                  viewport = _ref43.viewport,
                  _ref43$findController = _ref43.findController,
                  findController = _ref43$findController === void 0 ? null : _ref43$findController,
                  _ref43$enhanceTextSel = _ref43.enhanceTextSelection,
                  enhanceTextSelection = _ref43$enhanceTextSel === void 0 ? false : _ref43$enhanceTextSel;

              _classCallCheck(this, TextLayerBuilder);

              this.textLayerDiv = textLayerDiv;
              this.eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();
              this.textContent = null;
              this.textContentItemsStr = [];
              this.textContentStream = null;
              this.renderingDone = false;
              this.pageIdx = pageIndex;
              this.pageNumber = this.pageIdx + 1;
              this.matches = [];
              this.viewport = viewport;
              this.textDivs = [];
              this.findController = findController;
              this.textLayerRenderTask = null;
              this.enhanceTextSelection = enhanceTextSelection;
              this._onUpdateTextLayerMatches = null;

              this._bindMouse();
            }

            _createClass(TextLayerBuilder, [{
              key: "_finishRendering",
              value: function _finishRendering() {
                this.renderingDone = true;

                if (!this.enhanceTextSelection) {
                  var endOfContent = document.createElement("div");
                  endOfContent.className = "endOfContent";
                  this.textLayerDiv.appendChild(endOfContent);
                }

                this.eventBus.dispatch("textlayerrendered", {
                  source: this,
                  pageNumber: this.pageNumber,
                  numTextDivs: this.textDivs.length
                });
              }
            }, {
              key: "render",
              value: function render() {
                var _this61 = this;

                var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

                if (!(this.textContent || this.textContentStream) || this.renderingDone) {
                  return;
                }

                this.cancel();
                this.textDivs = [];
                var textLayerFrag = document.createDocumentFragment();
                this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({
                  textContent: this.textContent,
                  textContentStream: this.textContentStream,
                  container: textLayerFrag,
                  viewport: this.viewport,
                  textDivs: this.textDivs,
                  textContentItemsStr: this.textContentItemsStr,
                  timeout: timeout,
                  enhanceTextSelection: this.enhanceTextSelection
                });
                this.textLayerRenderTask.promise.then(function () {
                  _this61.textLayerDiv.appendChild(textLayerFrag);

                  _this61._finishRendering();

                  _this61._updateMatches();
                }, function (reason) {});

                if (!this._onUpdateTextLayerMatches) {
                  this._onUpdateTextLayerMatches = function (evt) {
                    if (evt.pageIndex === _this61.pageIdx || evt.pageIndex === -1) {
                      _this61._updateMatches();
                    }
                  };

                  this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches);
                }
              }
            }, {
              key: "cancel",
              value: function cancel() {
                if (this.textLayerRenderTask) {
                  this.textLayerRenderTask.cancel();
                  this.textLayerRenderTask = null;
                }

                if (this._onUpdateTextLayerMatches) {
                  this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches);

                  this._onUpdateTextLayerMatches = null;
                }
              }
            }, {
              key: "setTextContentStream",
              value: function setTextContentStream(readableStream) {
                this.cancel();
                this.textContentStream = readableStream;
              }
            }, {
              key: "setTextContent",
              value: function setTextContent(textContent) {
                this.cancel();
                this.textContent = textContent;
              }
            }, {
              key: "_convertMatches",
              value: function _convertMatches(matches, matchesLength) {
                if (!matches) {
                  return [];
                }

                var findController = this.findController,
                    textContentItemsStr = this.textContentItemsStr;
                var i = 0,
                    iIndex = 0;
                var end = textContentItemsStr.length - 1;
                var queryLen = findController.state.query.length;
                var result = [];

                for (var m = 0, mm = matches.length; m < mm; m++) {
                  var matchIdx = matches[m];

                  while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
                    iIndex += textContentItemsStr[i].length;
                    i++;
                  }

                  if (i === textContentItemsStr.length) {
                    console.error("Could not find a matching mapping");
                  }

                  var match = {
                    begin: {
                      divIdx: i,
                      offset: matchIdx - iIndex
                    }
                  };

                  if (matchesLength) {
                    matchIdx += matchesLength[m];
                  } else {
                    matchIdx += queryLen;
                  }

                  while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
                    iIndex += textContentItemsStr[i].length;
                    i++;
                  }

                  match.end = {
                    divIdx: i,
                    offset: matchIdx - iIndex
                  };
                  result.push(match);
                }

                return result;
              }
            }, {
              key: "_renderMatches",
              value: function _renderMatches(matches) {
                if (matches.length === 0) {
                  return;
                }

                var findController = this.findController,
                    pageIdx = this.pageIdx,
                    textContentItemsStr = this.textContentItemsStr,
                    textDivs = this.textDivs;
                var isSelectedPage = pageIdx === findController.selected.pageIdx;
                var selectedMatchIdx = findController.selected.matchIdx;
                var highlightAll = findController.state.highlightAll;
                var prevEnd = null;
                var infinity = {
                  divIdx: -1,
                  offset: undefined
                };

                function beginText(begin, className) {
                  var divIdx = begin.divIdx;
                  textDivs[divIdx].textContent = "";
                  appendTextToDiv(divIdx, 0, begin.offset, className);
                }

                function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
                  var div = textDivs[divIdx];
                  var content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
                  var node = document.createTextNode(content);

                  if (className) {
                    var span = document.createElement("span");
                    span.className = className;
                    span.appendChild(node);
                    div.appendChild(span);
                    return;
                  }

                  div.appendChild(node);
                }

                var i0 = selectedMatchIdx,
                    i1 = i0 + 1;

                if (highlightAll) {
                  i0 = 0;
                  i1 = matches.length;
                } else if (!isSelectedPage) {
                  return;
                }

                for (var i = i0; i < i1; i++) {
                  var match = matches[i];
                  var begin = match.begin;
                  var end = match.end;
                  var isSelected = isSelectedPage && i === selectedMatchIdx;
                  var highlightSuffix = isSelected ? " selected" : "";

                  if (isSelected) {
                    findController.scrollMatchIntoView({
                      element: textDivs[begin.divIdx],
                      pageIndex: pageIdx,
                      matchIndex: selectedMatchIdx
                    });
                  }

                  if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
                    if (prevEnd !== null) {
                      appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
                    }

                    beginText(begin);
                  } else {
                    appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
                  }

                  if (begin.divIdx === end.divIdx) {
                    appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix);
                  } else {
                    appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix);

                    for (var n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
                      textDivs[n0].className = "highlight middle" + highlightSuffix;
                    }

                    beginText(end, "highlight end" + highlightSuffix);
                  }

                  prevEnd = end;
                }

                if (prevEnd) {
                  appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
                }
              }
            }, {
              key: "_updateMatches",
              value: function _updateMatches() {
                if (!this.renderingDone) {
                  return;
                }

                var findController = this.findController,
                    matches = this.matches,
                    pageIdx = this.pageIdx,
                    textContentItemsStr = this.textContentItemsStr,
                    textDivs = this.textDivs;
                var clearedUntilDivIdx = -1;

                for (var i = 0, ii = matches.length; i < ii; i++) {
                  var match = matches[i];
                  var begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);

                  for (var n = begin, end = match.end.divIdx; n <= end; n++) {
                    var div = textDivs[n];
                    div.textContent = textContentItemsStr[n];
                    div.className = "";
                  }

                  clearedUntilDivIdx = match.end.divIdx + 1;
                }

                if (!findController || !findController.highlightMatches) {
                  return;
                }

                var pageMatches = findController.pageMatches[pageIdx] || null;
                var pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;
                this.matches = this._convertMatches(pageMatches, pageMatchesLength);

                this._renderMatches(this.matches);
              }
            }, {
              key: "_bindMouse",
              value: function _bindMouse() {
                var _this62 = this;

                var div = this.textLayerDiv;
                var expandDivsTimer = null;
                div.addEventListener("mousedown", function (evt) {
                  if (_this62.enhanceTextSelection && _this62.textLayerRenderTask) {
                    _this62.textLayerRenderTask.expandTextDivs(true);

                    if (expandDivsTimer) {
                      clearTimeout(expandDivsTimer);
                      expandDivsTimer = null;
                    }

                    return;
                  }

                  var end = div.querySelector(".endOfContent");

                  if (!end) {
                    return;
                  }

                  var adjustTop = evt.target !== div;
                  adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue("-moz-user-select") !== "none";

                  if (adjustTop) {
                    var divBounds = div.getBoundingClientRect();
                    var r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
                    end.style.top = (r * 100).toFixed(2) + "%";
                  }

                  end.classList.add("active");
                });
                div.addEventListener("mouseup", function () {
                  if (_this62.enhanceTextSelection && _this62.textLayerRenderTask) {
                    expandDivsTimer = setTimeout(function () {
                      if (_this62.textLayerRenderTask) {
                        _this62.textLayerRenderTask.expandTextDivs(false);
                      }

                      expandDivsTimer = null;
                    }, EXPAND_DIVS_TIMEOUT);
                    return;
                  }

                  var end = div.querySelector(".endOfContent");

                  if (!end) {
                    return;
                  }

                  end.style.top = "";
                  end.classList.remove("active");
                });
              }
            }]);

            return TextLayerBuilder;
          }();

          exports.TextLayerBuilder = TextLayerBuilder;

          var DefaultTextLayerFactory = /*#__PURE__*/function () {
            function DefaultTextLayerFactory() {
              _classCallCheck(this, DefaultTextLayerFactory);
            }

            _createClass(DefaultTextLayerFactory, [{
              key: "createTextLayerBuilder",
              value: function createTextLayerBuilder(textLayerDiv, pageIndex, viewport) {
                var enhanceTextSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                var eventBus = arguments.length > 4 ? arguments[4] : undefined;
                return new TextLayerBuilder({
                  textLayerDiv: textLayerDiv,
                  pageIndex: pageIndex,
                  viewport: viewport,
                  enhanceTextSelection: enhanceTextSelection,
                  eventBus: eventBus
                });
              }
            }]);

            return DefaultTextLayerFactory;
          }();

          exports.DefaultTextLayerFactory = DefaultTextLayerFactory;
          /***/
        },
        /* 6 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.DownloadManager = void 0;

          var _pdfjsLib = __w_pdfjs_require__(2);

          ;
          var DISABLE_CREATE_OBJECT_URL = _pdfjsLib.apiCompatibilityParams.disableCreateObjectURL || false;

          function _download2(blobUrl, filename) {
            var a = document.createElement("a");

            if (!a.click) {
              throw new Error('DownloadManager: "a.click()" is not supported.');
            }

            a.href = blobUrl;
            a.target = "_parent";

            if ("download" in a) {
              a.download = filename;
            }

            (document.body || document.documentElement).appendChild(a);
            a.click();
            a.remove();
          }

          var DownloadManager = /*#__PURE__*/function () {
            function DownloadManager(_ref44) {
              var _ref44$disableCreateO = _ref44.disableCreateObjectURL,
                  disableCreateObjectURL = _ref44$disableCreateO === void 0 ? DISABLE_CREATE_OBJECT_URL : _ref44$disableCreateO;

              _classCallCheck(this, DownloadManager);

              this.disableCreateObjectURL = disableCreateObjectURL;
            }

            _createClass(DownloadManager, [{
              key: "downloadUrl",
              value: function downloadUrl(url, filename) {
                if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, "http://example.com")) {
                  return;
                }

                _download2(url + "#pdfjs.action=download", filename);
              }
            }, {
              key: "downloadData",
              value: function downloadData(data, filename, contentType) {
                if (navigator.msSaveBlob) {
                  navigator.msSaveBlob(new Blob([data], {
                    type: contentType
                  }), filename);
                  return;
                }

                var blobUrl = (0, _pdfjsLib.createObjectURL)(data, contentType, this.disableCreateObjectURL);

                _download2(blobUrl, filename);
              }
            }, {
              key: "download",
              value: function download(blob, url, filename) {
                if (navigator.msSaveBlob) {
                  if (!navigator.msSaveBlob(blob, filename)) {
                    this.downloadUrl(url, filename);
                  }

                  return;
                }

                if (this.disableCreateObjectURL) {
                  this.downloadUrl(url, filename);
                  return;
                }

                var blobUrl = URL.createObjectURL(blob);

                _download2(blobUrl, filename);
              }
            }]);

            return DownloadManager;
          }();

          exports.DownloadManager = DownloadManager;
          /***/
        },
        /* 7 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.GenericL10n = void 0;

          __w_pdfjs_require__(8);

          var webL10n = document.webL10n;

          var GenericL10n = /*#__PURE__*/function () {
            function GenericL10n(lang) {
              _classCallCheck(this, GenericL10n);

              this._lang = lang;
              this._ready = new Promise(function (resolve, reject) {
                webL10n.setLanguage(lang, function () {
                  resolve(webL10n);
                });
              });
            }

            _createClass(GenericL10n, [{
              key: "getLanguage",
              value: function () {
                var _getLanguage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
                  var l10n;
                  return regeneratorRuntime.wrap(function _callee19$(_context19) {
                    while (1) {
                      switch (_context19.prev = _context19.next) {
                        case 0:
                          _context19.next = 2;
                          return this._ready;

                        case 2:
                          l10n = _context19.sent;
                          return _context19.abrupt("return", l10n.getLanguage());

                        case 4:
                        case "end":
                          return _context19.stop();
                      }
                    }
                  }, _callee19, this);
                }));

                function getLanguage() {
                  return _getLanguage.apply(this, arguments);
                }

                return getLanguage;
              }()
            }, {
              key: "getDirection",
              value: function () {
                var _getDirection = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
                  var l10n;
                  return regeneratorRuntime.wrap(function _callee20$(_context20) {
                    while (1) {
                      switch (_context20.prev = _context20.next) {
                        case 0:
                          _context20.next = 2;
                          return this._ready;

                        case 2:
                          l10n = _context20.sent;
                          return _context20.abrupt("return", l10n.getDirection());

                        case 4:
                        case "end":
                          return _context20.stop();
                      }
                    }
                  }, _callee20, this);
                }));

                function getDirection() {
                  return _getDirection.apply(this, arguments);
                }

                return getDirection;
              }()
            }, {
              key: "get",
              value: function () {
                var _get2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(property, args, fallback) {
                  var l10n;
                  return regeneratorRuntime.wrap(function _callee21$(_context21) {
                    while (1) {
                      switch (_context21.prev = _context21.next) {
                        case 0:
                          _context21.next = 2;
                          return this._ready;

                        case 2:
                          l10n = _context21.sent;
                          return _context21.abrupt("return", l10n.get(property, args, fallback));

                        case 4:
                        case "end":
                          return _context21.stop();
                      }
                    }
                  }, _callee21, this);
                }));

                function get(_x6, _x7, _x8) {
                  return _get2.apply(this, arguments);
                }

                return get;
              }()
            }, {
              key: "translate",
              value: function () {
                var _translate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22(element) {
                  var l10n;
                  return regeneratorRuntime.wrap(function _callee22$(_context22) {
                    while (1) {
                      switch (_context22.prev = _context22.next) {
                        case 0:
                          _context22.next = 2;
                          return this._ready;

                        case 2:
                          l10n = _context22.sent;
                          return _context22.abrupt("return", l10n.translate(element));

                        case 4:
                        case "end":
                          return _context22.stop();
                      }
                    }
                  }, _callee22, this);
                }));

                function translate(_x9) {
                  return _translate.apply(this, arguments);
                }

                return translate;
              }()
            }]);

            return GenericL10n;
          }();

          exports.GenericL10n = GenericL10n;
          /***/
        },
        /* 8 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          document.webL10n = function (window, document, undefined) {
            var gL10nData = {};
            var gTextData = '';
            var gTextProp = 'textContent';
            var gLanguage = '';
            var gMacros = {};
            var gReadyState = 'loading';
            var gAsyncResourceLoading = true;

            function getL10nResourceLinks() {
              return document.querySelectorAll('link[type="application/l10n"]');
            }

            function getL10nDictionary() {
              var script = document.querySelector('script[type="application/l10n"]');
              return script ? JSON.parse(script.innerHTML) : null;
            }

            function getTranslatableChildren(element) {
              return element ? element.querySelectorAll('*[data-l10n-id]') : [];
            }

            function getL10nAttributes(element) {
              if (!element) return {};
              var l10nId = element.getAttribute('data-l10n-id');
              var l10nArgs = element.getAttribute('data-l10n-args');
              var args = {};

              if (l10nArgs) {
                try {
                  args = JSON.parse(l10nArgs);
                } catch (e) {
                  console.warn('could not parse arguments for #' + l10nId);
                }
              }

              return {
                id: l10nId,
                args: args
              };
            }

            function xhrLoadText(url, onSuccess, onFailure) {
              onSuccess = onSuccess || function _onSuccess(data) {};

              onFailure = onFailure || function _onFailure() {};

              var xhr = new XMLHttpRequest();
              xhr.open('GET', url, gAsyncResourceLoading);

              if (xhr.overrideMimeType) {
                xhr.overrideMimeType('text/plain; charset=utf-8');
              }

              xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                  if (xhr.status == 200 || xhr.status === 0) {
                    onSuccess(xhr.responseText);
                  } else {
                    onFailure();
                  }
                }
              };

              xhr.onerror = onFailure;
              xhr.ontimeout = onFailure;

              try {
                xhr.send(null);
              } catch (e) {
                onFailure();
              }
            }

            function parseResource(href, lang, successCallback, failureCallback) {
              var baseURL = href.replace(/[^\/]*$/, '') || './';

              function evalString(text) {
                if (text.lastIndexOf('\\') < 0) return text;
                return text.replace(/\\\\/g, '\\').replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\b/g, '\b').replace(/\\f/g, '\f').replace(/\\{/g, '{').replace(/\\}/g, '}').replace(/\\"/g, '"').replace(/\\'/g, "'");
              }

              function parseProperties(text, parsedPropertiesCallback) {
                var dictionary = {};
                var reBlank = /^\s*|\s*$/;
                var reComment = /^\s*#|^\s*$/;
                var reSection = /^\s*\[(.*)\]\s*$/;
                var reImport = /^\s*@import\s+url\((.*)\)\s*$/i;
                var reSplit = /^([^=\s]*)\s*=\s*(.+)$/;

                function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) {
                  var entries = rawText.replace(reBlank, '').split(/[\r\n]+/);
                  var currentLang = '*';
                  var genericLang = lang.split('-', 1)[0];
                  var skipLang = false;
                  var match = '';

                  function nextEntry() {
                    while (true) {
                      if (!entries.length) {
                        parsedRawLinesCallback();
                        return;
                      }

                      var line = entries.shift();
                      if (reComment.test(line)) continue;

                      if (extendedSyntax) {
                        match = reSection.exec(line);

                        if (match) {
                          currentLang = match[1].toLowerCase();
                          skipLang = currentLang !== '*' && currentLang !== lang && currentLang !== genericLang;
                          continue;
                        } else if (skipLang) {
                          continue;
                        }

                        match = reImport.exec(line);

                        if (match) {
                          loadImport(baseURL + match[1], nextEntry);
                          return;
                        }
                      }

                      var tmp = line.match(reSplit);

                      if (tmp && tmp.length == 3) {
                        dictionary[tmp[1]] = evalString(tmp[2]);
                      }
                    }
                  }

                  nextEntry();
                }

                function loadImport(url, callback) {
                  xhrLoadText(url, function (content) {
                    parseRawLines(content, false, callback);
                  }, function () {
                    console.warn(url + ' not found.');
                    callback();
                  });
                }

                parseRawLines(text, true, function () {
                  parsedPropertiesCallback(dictionary);
                });
              }

              xhrLoadText(href, function (response) {
                gTextData += response;
                parseProperties(response, function (data) {
                  for (var key in data) {
                    var id,
                        prop,
                        index = key.lastIndexOf('.');

                    if (index > 0) {
                      id = key.substring(0, index);
                      prop = key.substring(index + 1);
                    } else {
                      id = key;
                      prop = gTextProp;
                    }

                    if (!gL10nData[id]) {
                      gL10nData[id] = {};
                    }

                    gL10nData[id][prop] = data[key];
                  }

                  if (successCallback) {
                    successCallback();
                  }
                });
              }, failureCallback);
            }

            function loadLocale(lang, callback) {
              if (lang) {
                lang = lang.toLowerCase();
              }

              callback = callback || function _callback() {};

              clear();
              gLanguage = lang;
              var langLinks = getL10nResourceLinks();
              var langCount = langLinks.length;

              if (langCount === 0) {
                var dict = getL10nDictionary();

                if (dict && dict.locales && dict.default_locale) {
                  console.log('using the embedded JSON directory, early way out');
                  gL10nData = dict.locales[lang];

                  if (!gL10nData) {
                    var defaultLocale = dict.default_locale.toLowerCase();

                    for (var anyCaseLang in dict.locales) {
                      anyCaseLang = anyCaseLang.toLowerCase();

                      if (anyCaseLang === lang) {
                        gL10nData = dict.locales[lang];
                        break;
                      } else if (anyCaseLang === defaultLocale) {
                        gL10nData = dict.locales[defaultLocale];
                      }
                    }
                  }

                  callback();
                } else {
                  console.log('no resource to load, early way out');
                }

                gReadyState = 'complete';
                return;
              }

              var onResourceLoaded = null;
              var gResourceCount = 0;

              onResourceLoaded = function onResourceLoaded() {
                gResourceCount++;

                if (gResourceCount >= langCount) {
                  callback();
                  gReadyState = 'complete';
                }
              };

              function L10nResourceLink(link) {
                var href = link.href;

                this.load = function (lang, callback) {
                  parseResource(href, lang, callback, function () {
                    console.warn(href + ' not found.');
                    console.warn('"' + lang + '" resource not found');
                    gLanguage = '';
                    callback();
                  });
                };
              }

              for (var i = 0; i < langCount; i++) {
                var resource = new L10nResourceLink(langLinks[i]);
                resource.load(lang, onResourceLoaded);
              }
            }

            function clear() {
              gL10nData = {};
              gTextData = '';
              gLanguage = '';
            }

            function getPluralRules(lang) {
              var locales2rules = {
                'af': 3,
                'ak': 4,
                'am': 4,
                'ar': 1,
                'asa': 3,
                'az': 0,
                'be': 11,
                'bem': 3,
                'bez': 3,
                'bg': 3,
                'bh': 4,
                'bm': 0,
                'bn': 3,
                'bo': 0,
                'br': 20,
                'brx': 3,
                'bs': 11,
                'ca': 3,
                'cgg': 3,
                'chr': 3,
                'cs': 12,
                'cy': 17,
                'da': 3,
                'de': 3,
                'dv': 3,
                'dz': 0,
                'ee': 3,
                'el': 3,
                'en': 3,
                'eo': 3,
                'es': 3,
                'et': 3,
                'eu': 3,
                'fa': 0,
                'ff': 5,
                'fi': 3,
                'fil': 4,
                'fo': 3,
                'fr': 5,
                'fur': 3,
                'fy': 3,
                'ga': 8,
                'gd': 24,
                'gl': 3,
                'gsw': 3,
                'gu': 3,
                'guw': 4,
                'gv': 23,
                'ha': 3,
                'haw': 3,
                'he': 2,
                'hi': 4,
                'hr': 11,
                'hu': 0,
                'id': 0,
                'ig': 0,
                'ii': 0,
                'is': 3,
                'it': 3,
                'iu': 7,
                'ja': 0,
                'jmc': 3,
                'jv': 0,
                'ka': 0,
                'kab': 5,
                'kaj': 3,
                'kcg': 3,
                'kde': 0,
                'kea': 0,
                'kk': 3,
                'kl': 3,
                'km': 0,
                'kn': 0,
                'ko': 0,
                'ksb': 3,
                'ksh': 21,
                'ku': 3,
                'kw': 7,
                'lag': 18,
                'lb': 3,
                'lg': 3,
                'ln': 4,
                'lo': 0,
                'lt': 10,
                'lv': 6,
                'mas': 3,
                'mg': 4,
                'mk': 16,
                'ml': 3,
                'mn': 3,
                'mo': 9,
                'mr': 3,
                'ms': 0,
                'mt': 15,
                'my': 0,
                'nah': 3,
                'naq': 7,
                'nb': 3,
                'nd': 3,
                'ne': 3,
                'nl': 3,
                'nn': 3,
                'no': 3,
                'nr': 3,
                'nso': 4,
                'ny': 3,
                'nyn': 3,
                'om': 3,
                'or': 3,
                'pa': 3,
                'pap': 3,
                'pl': 13,
                'ps': 3,
                'pt': 3,
                'rm': 3,
                'ro': 9,
                'rof': 3,
                'ru': 11,
                'rwk': 3,
                'sah': 0,
                'saq': 3,
                'se': 7,
                'seh': 3,
                'ses': 0,
                'sg': 0,
                'sh': 11,
                'shi': 19,
                'sk': 12,
                'sl': 14,
                'sma': 7,
                'smi': 7,
                'smj': 7,
                'smn': 7,
                'sms': 7,
                'sn': 3,
                'so': 3,
                'sq': 3,
                'sr': 11,
                'ss': 3,
                'ssy': 3,
                'st': 3,
                'sv': 3,
                'sw': 3,
                'syr': 3,
                'ta': 3,
                'te': 3,
                'teo': 3,
                'th': 0,
                'ti': 4,
                'tig': 3,
                'tk': 3,
                'tl': 4,
                'tn': 3,
                'to': 0,
                'tr': 0,
                'ts': 3,
                'tzm': 22,
                'uk': 11,
                'ur': 3,
                've': 3,
                'vi': 0,
                'vun': 3,
                'wa': 4,
                'wae': 3,
                'wo': 0,
                'xh': 3,
                'xog': 3,
                'yo': 0,
                'zh': 0,
                'zu': 3
              };

              function isIn(n, list) {
                return list.indexOf(n) !== -1;
              }

              function isBetween(n, start, end) {
                return start <= n && n <= end;
              }

              var pluralRules = {
                '0': function _(n) {
                  return 'other';
                },
                '1': function _(n) {
                  if (isBetween(n % 100, 3, 10)) return 'few';
                  if (n === 0) return 'zero';
                  if (isBetween(n % 100, 11, 99)) return 'many';
                  if (n == 2) return 'two';
                  if (n == 1) return 'one';
                  return 'other';
                },
                '2': function _(n) {
                  if (n !== 0 && n % 10 === 0) return 'many';
                  if (n == 2) return 'two';
                  if (n == 1) return 'one';
                  return 'other';
                },
                '3': function _(n) {
                  if (n == 1) return 'one';
                  return 'other';
                },
                '4': function _(n) {
                  if (isBetween(n, 0, 1)) return 'one';
                  return 'other';
                },
                '5': function _(n) {
                  if (isBetween(n, 0, 2) && n != 2) return 'one';
                  return 'other';
                },
                '6': function _(n) {
                  if (n === 0) return 'zero';
                  if (n % 10 == 1 && n % 100 != 11) return 'one';
                  return 'other';
                },
                '7': function _(n) {
                  if (n == 2) return 'two';
                  if (n == 1) return 'one';
                  return 'other';
                },
                '8': function _(n) {
                  if (isBetween(n, 3, 6)) return 'few';
                  if (isBetween(n, 7, 10)) return 'many';
                  if (n == 2) return 'two';
                  if (n == 1) return 'one';
                  return 'other';
                },
                '9': function _(n) {
                  if (n === 0 || n != 1 && isBetween(n % 100, 1, 19)) return 'few';
                  if (n == 1) return 'one';
                  return 'other';
                },
                '10': function _(n) {
                  if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19)) return 'few';
                  if (n % 10 == 1 && !isBetween(n % 100, 11, 19)) return 'one';
                  return 'other';
                },
                '11': function _(n) {
                  if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
                  if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14)) return 'many';
                  if (n % 10 == 1 && n % 100 != 11) return 'one';
                  return 'other';
                },
                '12': function _(n) {
                  if (isBetween(n, 2, 4)) return 'few';
                  if (n == 1) return 'one';
                  return 'other';
                },
                '13': function _(n) {
                  if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
                  if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14)) return 'many';
                  if (n == 1) return 'one';
                  return 'other';
                },
                '14': function _(n) {
                  if (isBetween(n % 100, 3, 4)) return 'few';
                  if (n % 100 == 2) return 'two';
                  if (n % 100 == 1) return 'one';
                  return 'other';
                },
                '15': function _(n) {
                  if (n === 0 || isBetween(n % 100, 2, 10)) return 'few';
                  if (isBetween(n % 100, 11, 19)) return 'many';
                  if (n == 1) return 'one';
                  return 'other';
                },
                '16': function _(n) {
                  if (n % 10 == 1 && n != 11) return 'one';
                  return 'other';
                },
                '17': function _(n) {
                  if (n == 3) return 'few';
                  if (n === 0) return 'zero';
                  if (n == 6) return 'many';
                  if (n == 2) return 'two';
                  if (n == 1) return 'one';
                  return 'other';
                },
                '18': function _(n) {
                  if (n === 0) return 'zero';
                  if (isBetween(n, 0, 2) && n !== 0 && n != 2) return 'one';
                  return 'other';
                },
                '19': function _(n) {
                  if (isBetween(n, 2, 10)) return 'few';
                  if (isBetween(n, 0, 1)) return 'one';
                  return 'other';
                },
                '20': function _(n) {
                  if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99))) return 'few';
                  if (n % 1000000 === 0 && n !== 0) return 'many';
                  if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92])) return 'two';
                  if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91])) return 'one';
                  return 'other';
                },
                '21': function _(n) {
                  if (n === 0) return 'zero';
                  if (n == 1) return 'one';
                  return 'other';
                },
                '22': function _(n) {
                  if (isBetween(n, 0, 1) || isBetween(n, 11, 99)) return 'one';
                  return 'other';
                },
                '23': function _(n) {
                  if (isBetween(n % 10, 1, 2) || n % 20 === 0) return 'one';
                  return 'other';
                },
                '24': function _(n) {
                  if (isBetween(n, 3, 10) || isBetween(n, 13, 19)) return 'few';
                  if (isIn(n, [2, 12])) return 'two';
                  if (isIn(n, [1, 11])) return 'one';
                  return 'other';
                }
              };
              var index = locales2rules[lang.replace(/-.*$/, '')];

              if (!(index in pluralRules)) {
                console.warn('plural form unknown for [' + lang + ']');
                return function () {
                  return 'other';
                };
              }

              return pluralRules[index];
            }

            gMacros.plural = function (str, param, key, prop) {
              var n = parseFloat(param);
              if (isNaN(n)) return str;
              if (prop != gTextProp) return str;

              if (!gMacros._pluralRules) {
                gMacros._pluralRules = getPluralRules(gLanguage);
              }

              var index = '[' + gMacros._pluralRules(n) + ']';

              if (n === 0 && key + '[zero]' in gL10nData) {
                str = gL10nData[key + '[zero]'][prop];
              } else if (n == 1 && key + '[one]' in gL10nData) {
                str = gL10nData[key + '[one]'][prop];
              } else if (n == 2 && key + '[two]' in gL10nData) {
                str = gL10nData[key + '[two]'][prop];
              } else if (key + index in gL10nData) {
                str = gL10nData[key + index][prop];
              } else if (key + '[other]' in gL10nData) {
                str = gL10nData[key + '[other]'][prop];
              }

              return str;
            };

            function getL10nData(key, args, fallback) {
              var data = gL10nData[key];

              if (!data) {
                console.warn('#' + key + ' is undefined.');

                if (!fallback) {
                  return null;
                }

                data = fallback;
              }

              var rv = {};

              for (var prop in data) {
                var str = data[prop];
                str = substIndexes(str, args, key, prop);
                str = substArguments(str, args, key);
                rv[prop] = str;
              }

              return rv;
            }

            function substIndexes(str, args, key, prop) {
              var reIndex = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/;
              var reMatch = reIndex.exec(str);
              if (!reMatch || !reMatch.length) return str;
              var macroName = reMatch[1];
              var paramName = reMatch[2];
              var param;

              if (args && paramName in args) {
                param = args[paramName];
              } else if (paramName in gL10nData) {
                param = gL10nData[paramName];
              }

              if (macroName in gMacros) {
                var macro = gMacros[macroName];
                str = macro(str, param, key, prop);
              }

              return str;
            }

            function substArguments(str, args, key) {
              var reArgs = /\{\{\s*(.+?)\s*\}\}/g;
              return str.replace(reArgs, function (matched_text, arg) {
                if (args && arg in args) {
                  return args[arg];
                }

                if (arg in gL10nData) {
                  return gL10nData[arg];
                }

                console.log('argument {{' + arg + '}} for #' + key + ' is undefined.');
                return matched_text;
              });
            }

            function translateElement(element) {
              var l10n = getL10nAttributes(element);
              if (!l10n.id) return;
              var data = getL10nData(l10n.id, l10n.args);

              if (!data) {
                console.warn('#' + l10n.id + ' is undefined.');
                return;
              }

              if (data[gTextProp]) {
                if (getChildElementCount(element) === 0) {
                  element[gTextProp] = data[gTextProp];
                } else {
                  var children = element.childNodes;
                  var found = false;

                  for (var i = 0, l = children.length; i < l; i++) {
                    if (children[i].nodeType === 3 && /\S/.test(children[i].nodeValue)) {
                      if (found) {
                        children[i].nodeValue = '';
                      } else {
                        children[i].nodeValue = data[gTextProp];
                        found = true;
                      }
                    }
                  }

                  if (!found) {
                    var textNode = document.createTextNode(data[gTextProp]);
                    element.insertBefore(textNode, element.firstChild);
                  }
                }

                delete data[gTextProp];
              }

              for (var k in data) {
                element[k] = data[k];
              }
            }

            function getChildElementCount(element) {
              if (element.children) {
                return element.children.length;
              }

              if (typeof element.childElementCount !== 'undefined') {
                return element.childElementCount;
              }

              var count = 0;

              for (var i = 0; i < element.childNodes.length; i++) {
                count += element.nodeType === 1 ? 1 : 0;
              }

              return count;
            }

            function translateFragment(element) {
              element = element || document.documentElement;
              var children = getTranslatableChildren(element);
              var elementCount = children.length;

              for (var i = 0; i < elementCount; i++) {
                translateElement(children[i]);
              }

              translateElement(element);
            }

            return {
              get: function get(key, args, fallbackString) {
                var index = key.lastIndexOf('.');
                var prop = gTextProp;

                if (index > 0) {
                  prop = key.substring(index + 1);
                  key = key.substring(0, index);
                }

                var fallback;

                if (fallbackString) {
                  fallback = {};
                  fallback[prop] = fallbackString;
                }

                var data = getL10nData(key, args, fallback);

                if (data && prop in data) {
                  return data[prop];
                }

                return '{{' + key + '}}';
              },
              getData: function getData() {
                return gL10nData;
              },
              getText: function getText() {
                return gTextData;
              },
              getLanguage: function getLanguage() {
                return gLanguage;
              },
              setLanguage: function setLanguage(lang, callback) {
                loadLocale(lang, function () {
                  if (callback) callback();
                });
              },
              getDirection: function getDirection() {
                var rtlList = ['ar', 'he', 'fa', 'ps', 'ur'];
                var shortCode = gLanguage.split('-', 1)[0];
                return rtlList.indexOf(shortCode) >= 0 ? 'rtl' : 'ltr';
              },
              translate: translateFragment,
              getReadyState: function getReadyState() {
                return gReadyState;
              },
              ready: function ready(callback) {
                if (!callback) {
                  return;
                } else if (gReadyState == 'complete' || gReadyState == 'interactive') {
                  window.setTimeout(function () {
                    callback();
                  });
                } else if (document.addEventListener) {
                  document.addEventListener('localized', function once() {
                    document.removeEventListener('localized', once);
                    callback();
                  });
                }
              }
            };
          }(window, document);
          /***/

        },
        /* 9 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PDFFindController = exports.FindState = void 0;

          var _ui_utils = __w_pdfjs_require__(3);

          var _pdfjsLib = __w_pdfjs_require__(2);

          var _pdf_find_utils = __w_pdfjs_require__(10);

          var FindState = {
            FOUND: 0,
            NOT_FOUND: 1,
            WRAPPED: 2,
            PENDING: 3
          };
          exports.FindState = FindState;
          var FIND_TIMEOUT = 250;
          var MATCH_SCROLL_OFFSET_TOP = -50;
          var MATCH_SCROLL_OFFSET_LEFT = -400;
          var CHARACTERS_TO_NORMALIZE = {
            "\u2018": "'",
            "\u2019": "'",
            "\u201A": "'",
            "\u201B": "'",
            "\u201C": '"',
            "\u201D": '"',
            "\u201E": '"',
            "\u201F": '"',
            "\xBC": "1/4",
            "\xBD": "1/2",
            "\xBE": "3/4"
          };
          var normalizationRegex = null;

          function normalize(text) {
            if (!normalizationRegex) {
              var replace = Object.keys(CHARACTERS_TO_NORMALIZE).join("");
              normalizationRegex = new RegExp("[".concat(replace, "]"), "g");
            }

            return text.replace(normalizationRegex, function (ch) {
              return CHARACTERS_TO_NORMALIZE[ch];
            });
          }

          var PDFFindController = /*#__PURE__*/function () {
            function PDFFindController(_ref45) {
              var linkService = _ref45.linkService,
                  eventBus = _ref45.eventBus;

              _classCallCheck(this, PDFFindController);

              this._linkService = linkService;
              this._eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();

              this._reset();

              eventBus._on("findbarclose", this._onFindBarClose.bind(this));
            }

            _createClass(PDFFindController, [{
              key: "setDocument",
              value: function setDocument(pdfDocument) {
                if (this._pdfDocument) {
                  this._reset();
                }

                if (!pdfDocument) {
                  return;
                }

                this._pdfDocument = pdfDocument;

                this._firstPageCapability.resolve();
              }
            }, {
              key: "executeCommand",
              value: function executeCommand(cmd, state) {
                var _this63 = this;

                if (!state) {
                  return;
                }

                var pdfDocument = this._pdfDocument;

                if (this._state === null || this._shouldDirtyMatch(cmd, state)) {
                  this._dirtyMatch = true;
                }

                this._state = state;

                if (cmd !== "findhighlightallchange") {
                  this._updateUIState(FindState.PENDING);
                }

                this._firstPageCapability.promise.then(function () {
                  if (!_this63._pdfDocument || pdfDocument && _this63._pdfDocument !== pdfDocument) {
                    return;
                  }

                  _this63._extractText();

                  var findbarClosed = !_this63._highlightMatches;
                  var pendingTimeout = !!_this63._findTimeout;

                  if (_this63._findTimeout) {
                    clearTimeout(_this63._findTimeout);
                    _this63._findTimeout = null;
                  }

                  if (cmd === "find") {
                    _this63._findTimeout = setTimeout(function () {
                      _this63._nextMatch();

                      _this63._findTimeout = null;
                    }, FIND_TIMEOUT);
                  } else if (_this63._dirtyMatch) {
                    _this63._nextMatch();
                  } else if (cmd === "findagain") {
                    _this63._nextMatch();

                    if (findbarClosed && _this63._state.highlightAll) {
                      _this63._updateAllPages();
                    }
                  } else if (cmd === "findhighlightallchange") {
                    if (pendingTimeout) {
                      _this63._nextMatch();
                    } else {
                      _this63._highlightMatches = true;
                    }

                    _this63._updateAllPages();
                  } else {
                    _this63._nextMatch();
                  }
                });
              }
            }, {
              key: "scrollMatchIntoView",
              value: function scrollMatchIntoView(_ref46) {
                var _ref46$element = _ref46.element,
                    element = _ref46$element === void 0 ? null : _ref46$element,
                    _ref46$pageIndex = _ref46.pageIndex,
                    pageIndex = _ref46$pageIndex === void 0 ? -1 : _ref46$pageIndex,
                    _ref46$matchIndex = _ref46.matchIndex,
                    matchIndex = _ref46$matchIndex === void 0 ? -1 : _ref46$matchIndex;

                if (!this._scrollMatches || !element) {
                  return;
                } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {
                  return;
                } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {
                  return;
                }

                this._scrollMatches = false;
                var spot = {
                  top: MATCH_SCROLL_OFFSET_TOP,
                  left: MATCH_SCROLL_OFFSET_LEFT
                };
                (0, _ui_utils.scrollIntoView)(element, spot, true);
              }
            }, {
              key: "_reset",
              value: function _reset() {
                this._highlightMatches = false;
                this._scrollMatches = false;
                this._pdfDocument = null;
                this._pageMatches = [];
                this._pageMatchesLength = [];
                this._state = null;
                this._selected = {
                  pageIdx: -1,
                  matchIdx: -1
                };
                this._offset = {
                  pageIdx: null,
                  matchIdx: null,
                  wrapped: false
                };
                this._extractTextPromises = [];
                this._pageContents = [];
                this._matchesCountTotal = 0;
                this._pagesToSearch = null;
                this._pendingFindMatches = Object.create(null);
                this._resumePageIdx = null;
                this._dirtyMatch = false;
                clearTimeout(this._findTimeout);
                this._findTimeout = null;
                this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
              }
            }, {
              key: "_shouldDirtyMatch",
              value: function _shouldDirtyMatch(cmd, state) {
                if (state.query !== this._state.query) {
                  return true;
                }

                switch (cmd) {
                  case "findagain":
                    var pageNumber = this._selected.pageIdx + 1;
                    var linkService = this._linkService;

                    if (pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !linkService.isPageVisible(pageNumber)) {
                      return true;
                    }

                    return false;

                  case "findhighlightallchange":
                    return false;
                }

                return true;
              }
            }, {
              key: "_prepareMatches",
              value: function _prepareMatches(matchesWithLength, matches, matchesLength) {
                function isSubTerm(currentIndex) {
                  var currentElem = matchesWithLength[currentIndex];
                  var nextElem = matchesWithLength[currentIndex + 1];

                  if (currentIndex < matchesWithLength.length - 1 && currentElem.match === nextElem.match) {
                    currentElem.skipped = true;
                    return true;
                  }

                  for (var i = currentIndex - 1; i >= 0; i--) {
                    var prevElem = matchesWithLength[i];

                    if (prevElem.skipped) {
                      continue;
                    }

                    if (prevElem.match + prevElem.matchLength < currentElem.match) {
                      break;
                    }

                    if (prevElem.match + prevElem.matchLength >= currentElem.match + currentElem.matchLength) {
                      currentElem.skipped = true;
                      return true;
                    }
                  }

                  return false;
                }

                matchesWithLength.sort(function (a, b) {
                  return a.match === b.match ? a.matchLength - b.matchLength : a.match - b.match;
                });

                for (var i = 0, len = matchesWithLength.length; i < len; i++) {
                  if (isSubTerm(i)) {
                    continue;
                  }

                  matches.push(matchesWithLength[i].match);
                  matchesLength.push(matchesWithLength[i].matchLength);
                }
              }
            }, {
              key: "_isEntireWord",
              value: function _isEntireWord(content, startIdx, length) {
                if (startIdx > 0) {
                  var first = content.charCodeAt(startIdx);
                  var limit = content.charCodeAt(startIdx - 1);

                  if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) {
                    return false;
                  }
                }

                var endIdx = startIdx + length - 1;

                if (endIdx < content.length - 1) {
                  var last = content.charCodeAt(endIdx);

                  var _limit = content.charCodeAt(endIdx + 1);

                  if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(_limit)) {
                    return false;
                  }
                }

                return true;
              }
            }, {
              key: "_calculatePhraseMatch",
              value: function _calculatePhraseMatch(query, pageIndex, pageContent, entireWord) {
                var matches = [];
                var queryLen = query.length;
                var matchIdx = -queryLen;

                while (true) {
                  matchIdx = pageContent.indexOf(query, matchIdx + queryLen);

                  if (matchIdx === -1) {
                    break;
                  }

                  if (entireWord && !this._isEntireWord(pageContent, matchIdx, queryLen)) {
                    continue;
                  }

                  matches.push(matchIdx);
                }

                this._pageMatches[pageIndex] = matches;
              }
            }, {
              key: "_calculateWordMatch",
              value: function _calculateWordMatch(query, pageIndex, pageContent, entireWord) {
                var matchesWithLength = [];
                var queryArray = query.match(/\S+/g);

                for (var i = 0, len = queryArray.length; i < len; i++) {
                  var subquery = queryArray[i];
                  var subqueryLen = subquery.length;
                  var matchIdx = -subqueryLen;

                  while (true) {
                    matchIdx = pageContent.indexOf(subquery, matchIdx + subqueryLen);

                    if (matchIdx === -1) {
                      break;
                    }

                    if (entireWord && !this._isEntireWord(pageContent, matchIdx, subqueryLen)) {
                      continue;
                    }

                    matchesWithLength.push({
                      match: matchIdx,
                      matchLength: subqueryLen,
                      skipped: false
                    });
                  }
                }

                this._pageMatchesLength[pageIndex] = [];
                this._pageMatches[pageIndex] = [];

                this._prepareMatches(matchesWithLength, this._pageMatches[pageIndex], this._pageMatchesLength[pageIndex]);
              }
            }, {
              key: "_calculateMatch",
              value: function _calculateMatch(pageIndex) {
                var pageContent = this._pageContents[pageIndex];
                var query = this._query;
                var _this$_state = this._state,
                    caseSensitive = _this$_state.caseSensitive,
                    entireWord = _this$_state.entireWord,
                    phraseSearch = _this$_state.phraseSearch;

                if (query.length === 0) {
                  return;
                }

                if (!caseSensitive) {
                  pageContent = pageContent.toLowerCase();
                  query = query.toLowerCase();
                }

                if (phraseSearch) {
                  this._calculatePhraseMatch(query, pageIndex, pageContent, entireWord);
                } else {
                  this._calculateWordMatch(query, pageIndex, pageContent, entireWord);
                }

                if (this._state.highlightAll) {
                  this._updatePage(pageIndex);
                }

                if (this._resumePageIdx === pageIndex) {
                  this._resumePageIdx = null;

                  this._nextPageMatch();
                }

                var pageMatchesCount = this._pageMatches[pageIndex].length;

                if (pageMatchesCount > 0) {
                  this._matchesCountTotal += pageMatchesCount;

                  this._updateUIResultsCount();
                }
              }
            }, {
              key: "_extractText",
              value: function _extractText() {
                var _this64 = this;

                if (this._extractTextPromises.length > 0) {
                  return;
                }

                var promise = Promise.resolve();

                var _loop2 = function _loop2(i, ii) {
                  var extractTextCapability = (0, _pdfjsLib.createPromiseCapability)();
                  _this64._extractTextPromises[i] = extractTextCapability.promise;
                  promise = promise.then(function () {
                    return _this64._pdfDocument.getPage(i + 1).then(function (pdfPage) {
                      return pdfPage.getTextContent({
                        normalizeWhitespace: true
                      });
                    }).then(function (textContent) {
                      var textItems = textContent.items;
                      var strBuf = [];

                      for (var j = 0, jj = textItems.length; j < jj; j++) {
                        strBuf.push(textItems[j].str);
                      }

                      _this64._pageContents[i] = normalize(strBuf.join(""));
                      extractTextCapability.resolve(i);
                    }, function (reason) {
                      console.error("Unable to get text content for page ".concat(i + 1), reason);
                      _this64._pageContents[i] = "";
                      extractTextCapability.resolve(i);
                    });
                  });
                };

                for (var i = 0, ii = this._linkService.pagesCount; i < ii; i++) {
                  _loop2(i, ii);
                }
              }
            }, {
              key: "_updatePage",
              value: function _updatePage(index) {
                if (this._scrollMatches && this._selected.pageIdx === index) {
                  this._linkService.page = index + 1;
                }

                this._eventBus.dispatch("updatetextlayermatches", {
                  source: this,
                  pageIndex: index
                });
              }
            }, {
              key: "_updateAllPages",
              value: function _updateAllPages() {
                this._eventBus.dispatch("updatetextlayermatches", {
                  source: this,
                  pageIndex: -1
                });
              }
            }, {
              key: "_nextMatch",
              value: function _nextMatch() {
                var _this65 = this;

                var previous = this._state.findPrevious;
                var currentPageIndex = this._linkService.page - 1;
                var numPages = this._linkService.pagesCount;
                this._highlightMatches = true;

                if (this._dirtyMatch) {
                  this._dirtyMatch = false;
                  this._selected.pageIdx = this._selected.matchIdx = -1;
                  this._offset.pageIdx = currentPageIndex;
                  this._offset.matchIdx = null;
                  this._offset.wrapped = false;
                  this._resumePageIdx = null;
                  this._pageMatches.length = 0;
                  this._pageMatchesLength.length = 0;
                  this._matchesCountTotal = 0;

                  this._updateAllPages();

                  for (var i = 0; i < numPages; i++) {
                    if (this._pendingFindMatches[i] === true) {
                      continue;
                    }

                    this._pendingFindMatches[i] = true;

                    this._extractTextPromises[i].then(function (pageIdx) {
                      delete _this65._pendingFindMatches[pageIdx];

                      _this65._calculateMatch(pageIdx);
                    });
                  }
                }

                if (this._query === "") {
                  this._updateUIState(FindState.FOUND);

                  return;
                }

                if (this._resumePageIdx) {
                  return;
                }

                var offset = this._offset;
                this._pagesToSearch = numPages;

                if (offset.matchIdx !== null) {
                  var numPageMatches = this._pageMatches[offset.pageIdx].length;

                  if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) {
                    offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;

                    this._updateMatch(true);

                    return;
                  }

                  this._advanceOffsetPage(previous);
                }

                this._nextPageMatch();
              }
            }, {
              key: "_matchesReady",
              value: function _matchesReady(matches) {
                var offset = this._offset;
                var numMatches = matches.length;
                var previous = this._state.findPrevious;

                if (numMatches) {
                  offset.matchIdx = previous ? numMatches - 1 : 0;

                  this._updateMatch(true);

                  return true;
                }

                this._advanceOffsetPage(previous);

                if (offset.wrapped) {
                  offset.matchIdx = null;

                  if (this._pagesToSearch < 0) {
                    this._updateMatch(false);

                    return true;
                  }
                }

                return false;
              }
            }, {
              key: "_nextPageMatch",
              value: function _nextPageMatch() {
                if (this._resumePageIdx !== null) {
                  console.error("There can only be one pending page.");
                }

                var matches = null;

                do {
                  var pageIdx = this._offset.pageIdx;
                  matches = this._pageMatches[pageIdx];

                  if (!matches) {
                    this._resumePageIdx = pageIdx;
                    break;
                  }
                } while (!this._matchesReady(matches));
              }
            }, {
              key: "_advanceOffsetPage",
              value: function _advanceOffsetPage(previous) {
                var offset = this._offset;
                var numPages = this._linkService.pagesCount;
                offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;
                offset.matchIdx = null;
                this._pagesToSearch--;

                if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
                  offset.pageIdx = previous ? numPages - 1 : 0;
                  offset.wrapped = true;
                }
              }
            }, {
              key: "_updateMatch",
              value: function _updateMatch() {
                var found = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                var state = FindState.NOT_FOUND;
                var wrapped = this._offset.wrapped;
                this._offset.wrapped = false;

                if (found) {
                  var previousPage = this._selected.pageIdx;
                  this._selected.pageIdx = this._offset.pageIdx;
                  this._selected.matchIdx = this._offset.matchIdx;
                  state = wrapped ? FindState.WRAPPED : FindState.FOUND;

                  if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {
                    this._updatePage(previousPage);
                  }
                }

                this._updateUIState(state, this._state.findPrevious);

                if (this._selected.pageIdx !== -1) {
                  this._scrollMatches = true;

                  this._updatePage(this._selected.pageIdx);
                }
              }
            }, {
              key: "_onFindBarClose",
              value: function _onFindBarClose(evt) {
                var _this66 = this;

                var pdfDocument = this._pdfDocument;

                this._firstPageCapability.promise.then(function () {
                  if (!_this66._pdfDocument || pdfDocument && _this66._pdfDocument !== pdfDocument) {
                    return;
                  }

                  if (_this66._findTimeout) {
                    clearTimeout(_this66._findTimeout);
                    _this66._findTimeout = null;
                  }

                  if (_this66._resumePageIdx) {
                    _this66._resumePageIdx = null;
                    _this66._dirtyMatch = true;
                  }

                  _this66._updateUIState(FindState.FOUND);

                  _this66._highlightMatches = false;

                  _this66._updateAllPages();
                });
              }
            }, {
              key: "_requestMatchesCount",
              value: function _requestMatchesCount() {
                var _this$_selected = this._selected,
                    pageIdx = _this$_selected.pageIdx,
                    matchIdx = _this$_selected.matchIdx;
                var current = 0,
                    total = this._matchesCountTotal;

                if (matchIdx !== -1) {
                  for (var i = 0; i < pageIdx; i++) {
                    current += this._pageMatches[i] && this._pageMatches[i].length || 0;
                  }

                  current += matchIdx + 1;
                }

                if (current < 1 || current > total) {
                  current = total = 0;
                }

                return {
                  current: current,
                  total: total
                };
              }
            }, {
              key: "_updateUIResultsCount",
              value: function _updateUIResultsCount() {
                this._eventBus.dispatch("updatefindmatchescount", {
                  source: this,
                  matchesCount: this._requestMatchesCount()
                });
              }
            }, {
              key: "_updateUIState",
              value: function _updateUIState(state, previous) {
                this._eventBus.dispatch("updatefindcontrolstate", {
                  source: this,
                  state: state,
                  previous: previous,
                  matchesCount: this._requestMatchesCount()
                });
              }
            }, {
              key: "highlightMatches",
              get: function get() {
                return this._highlightMatches;
              }
            }, {
              key: "pageMatches",
              get: function get() {
                return this._pageMatches;
              }
            }, {
              key: "pageMatchesLength",
              get: function get() {
                return this._pageMatchesLength;
              }
            }, {
              key: "selected",
              get: function get() {
                return this._selected;
              }
            }, {
              key: "state",
              get: function get() {
                return this._state;
              }
            }, {
              key: "_query",
              get: function get() {
                if (this._state.query !== this._rawQuery) {
                  this._rawQuery = this._state.query;
                  this._normalizedQuery = normalize(this._state.query);
                }

                return this._normalizedQuery;
              }
            }]);

            return PDFFindController;
          }();

          exports.PDFFindController = PDFFindController;
          /***/
        },
        /* 10 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getCharacterType = getCharacterType;
          exports.CharacterType = void 0;
          var CharacterType = {
            SPACE: 0,
            ALPHA_LETTER: 1,
            PUNCT: 2,
            HAN_LETTER: 3,
            KATAKANA_LETTER: 4,
            HIRAGANA_LETTER: 5,
            HALFWIDTH_KATAKANA_LETTER: 6,
            THAI_LETTER: 7
          };
          exports.CharacterType = CharacterType;

          function isAlphabeticalScript(charCode) {
            return charCode < 0x2e80;
          }

          function isAscii(charCode) {
            return (charCode & 0xff80) === 0;
          }

          function isAsciiAlpha(charCode) {
            return charCode >= 0x61 && charCode <= 0x7a || charCode >= 0x41 && charCode <= 0x5a;
          }

          function isAsciiDigit(charCode) {
            return charCode >= 0x30 && charCode <= 0x39;
          }

          function isAsciiSpace(charCode) {
            return charCode === 0x20 || charCode === 0x09 || charCode === 0x0d || charCode === 0x0a;
          }

          function isHan(charCode) {
            return charCode >= 0x3400 && charCode <= 0x9fff || charCode >= 0xf900 && charCode <= 0xfaff;
          }

          function isKatakana(charCode) {
            return charCode >= 0x30a0 && charCode <= 0x30ff;
          }

          function isHiragana(charCode) {
            return charCode >= 0x3040 && charCode <= 0x309f;
          }

          function isHalfwidthKatakana(charCode) {
            return charCode >= 0xff60 && charCode <= 0xff9f;
          }

          function isThai(charCode) {
            return (charCode & 0xff80) === 0x0e00;
          }

          function getCharacterType(charCode) {
            if (isAlphabeticalScript(charCode)) {
              if (isAscii(charCode)) {
                if (isAsciiSpace(charCode)) {
                  return CharacterType.SPACE;
                } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 0x5f) {
                  return CharacterType.ALPHA_LETTER;
                }

                return CharacterType.PUNCT;
              } else if (isThai(charCode)) {
                return CharacterType.THAI_LETTER;
              } else if (charCode === 0xa0) {
                return CharacterType.SPACE;
              }

              return CharacterType.ALPHA_LETTER;
            }

            if (isHan(charCode)) {
              return CharacterType.HAN_LETTER;
            } else if (isKatakana(charCode)) {
              return CharacterType.KATAKANA_LETTER;
            } else if (isHiragana(charCode)) {
              return CharacterType.HIRAGANA_LETTER;
            } else if (isHalfwidthKatakana(charCode)) {
              return CharacterType.HALFWIDTH_KATAKANA_LETTER;
            }

            return CharacterType.ALPHA_LETTER;
          }
          /***/

        },
        /* 11 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.isDestHashesEqual = isDestHashesEqual;
          exports.isDestArraysEqual = isDestArraysEqual;
          exports.PDFHistory = void 0;

          var _ui_utils = __w_pdfjs_require__(3);

          var HASH_CHANGE_TIMEOUT = 1000;
          var POSITION_UPDATED_THRESHOLD = 50;
          var UPDATE_VIEWAREA_TIMEOUT = 1000;

          function getCurrentHash() {
            return document.location.hash;
          }

          var PDFHistory = /*#__PURE__*/function () {
            function PDFHistory(_ref47) {
              var _this67 = this;

              var linkService = _ref47.linkService,
                  eventBus = _ref47.eventBus;

              _classCallCheck(this, PDFHistory);

              this.linkService = linkService;
              this.eventBus = eventBus || (0, _ui_utils.getGlobalEventBus)();
              this._initialized = false;
              this._fingerprint = "";
              this.reset();
              this._boundEvents = null;
              this._isViewerInPresentationMode = false;

              this.eventBus._on("presentationmodechanged", function (evt) {
                _this67._isViewerInPresentationMode = evt.active || evt.switchInProgress;
              });

              this.eventBus._on("pagesinit", function () {
                _this67._isPagesLoaded = false;

                var onPagesLoaded = function onPagesLoaded(evt) {
                  _this67.eventBus._off("pagesloaded", onPagesLoaded);

                  _this67._isPagesLoaded = !!evt.pagesCount;
                };

                _this67.eventBus._on("pagesloaded", onPagesLoaded);
              });
            }

            _createClass(PDFHistory, [{
              key: "initialize",
              value: function initialize(_ref48) {
                var fingerprint = _ref48.fingerprint,
                    _ref48$resetHistory = _ref48.resetHistory,
                    resetHistory = _ref48$resetHistory === void 0 ? false : _ref48$resetHistory,
                    _ref48$updateUrl = _ref48.updateUrl,
                    updateUrl = _ref48$updateUrl === void 0 ? false : _ref48$updateUrl;

                if (!fingerprint || typeof fingerprint !== "string") {
                  console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
                  return;
                }

                if (this._initialized) {
                  this.reset();
                }

                var reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint;
                this._fingerprint = fingerprint;
                this._updateUrl = updateUrl === true;
                this._initialized = true;

                this._bindEvents();

                var state = window.history.state;
                this._popStateInProgress = false;
                this._blockHashChange = 0;
                this._currentHash = getCurrentHash();
                this._numPositionUpdates = 0;
                this._uid = this._maxUid = 0;
                this._destination = null;
                this._position = null;

                if (!this._isValidState(state, true) || resetHistory) {
                  var _this$_parseCurrentHa = this._parseCurrentHash(),
                      hash = _this$_parseCurrentHa.hash,
                      page = _this$_parseCurrentHa.page,
                      rotation = _this$_parseCurrentHa.rotation;

                  if (!hash || reInitialized || resetHistory) {
                    this._pushOrReplaceState(null, true);

                    return;
                  }

                  this._pushOrReplaceState({
                    hash: hash,
                    page: page,
                    rotation: rotation
                  }, true);

                  return;
                }

                var destination = state.destination;

                this._updateInternalState(destination, state.uid, true);

                if (this._uid > this._maxUid) {
                  this._maxUid = this._uid;
                }

                if (destination.rotation !== undefined) {
                  this._initialRotation = destination.rotation;
                }

                if (destination.dest) {
                  this._initialBookmark = JSON.stringify(destination.dest);
                  this._destination.page = null;
                } else if (destination.hash) {
                  this._initialBookmark = destination.hash;
                } else if (destination.page) {
                  this._initialBookmark = "page=".concat(destination.page);
                }
              }
            }, {
              key: "reset",
              value: function reset() {
                if (this._initialized) {
                  this._pageHide();

                  this._initialized = false;

                  this._unbindEvents();
                }

                if (this._updateViewareaTimeout) {
                  clearTimeout(this._updateViewareaTimeout);
                  this._updateViewareaTimeout = null;
                }

                this._initialBookmark = null;
                this._initialRotation = null;
              }
            }, {
              key: "push",
              value: function push(_ref49) {
                var _this68 = this;

                var _ref49$namedDest = _ref49.namedDest,
                    namedDest = _ref49$namedDest === void 0 ? null : _ref49$namedDest,
                    explicitDest = _ref49.explicitDest,
                    pageNumber = _ref49.pageNumber;

                if (!this._initialized) {
                  return;
                }

                if (namedDest && typeof namedDest !== "string") {
                  console.error("PDFHistory.push: " + "\"".concat(namedDest, "\" is not a valid namedDest parameter."));
                  return;
                } else if (!Array.isArray(explicitDest)) {
                  console.error("PDFHistory.push: " + "\"".concat(explicitDest, "\" is not a valid explicitDest parameter."));
                  return;
                } else if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.linkService.pagesCount)) {
                  if (pageNumber !== null || this._destination) {
                    console.error("PDFHistory.push: " + "\"".concat(pageNumber, "\" is not a valid pageNumber parameter."));
                    return;
                  }
                }

                var hash = namedDest || JSON.stringify(explicitDest);

                if (!hash) {
                  return;
                }

                var forceReplace = false;

                if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {
                  if (this._destination.page) {
                    return;
                  }

                  forceReplace = true;
                }

                if (this._popStateInProgress && !forceReplace) {
                  return;
                }

                this._pushOrReplaceState({
                  dest: explicitDest,
                  hash: hash,
                  page: pageNumber,
                  rotation: this.linkService.rotation
                }, forceReplace);

                if (!this._popStateInProgress) {
                  this._popStateInProgress = true;
                  Promise.resolve().then(function () {
                    _this68._popStateInProgress = false;
                  });
                }
              }
            }, {
              key: "pushCurrentPosition",
              value: function pushCurrentPosition() {
                if (!this._initialized || this._popStateInProgress) {
                  return;
                }

                this._tryPushCurrentPosition();
              }
            }, {
              key: "back",
              value: function back() {
                if (!this._initialized || this._popStateInProgress) {
                  return;
                }

                var state = window.history.state;

                if (this._isValidState(state) && state.uid > 0) {
                  window.history.back();
                }
              }
            }, {
              key: "forward",
              value: function forward() {
                if (!this._initialized || this._popStateInProgress) {
                  return;
                }

                var state = window.history.state;

                if (this._isValidState(state) && state.uid < this._maxUid) {
                  window.history.forward();
                }
              }
            }, {
              key: "_pushOrReplaceState",
              value: function _pushOrReplaceState(destination) {
                var forceReplace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var shouldReplace = forceReplace || !this._destination;
                var newState = {
                  fingerprint: this._fingerprint,
                  uid: shouldReplace ? this._uid : this._uid + 1,
                  destination: destination
                };

                this._updateInternalState(destination, newState.uid);

                var newUrl;

                if (this._updateUrl && destination && destination.hash) {
                  var baseUrl = document.location.href.split("#")[0];

                  if (!baseUrl.startsWith("file://")) {
                    newUrl = "".concat(baseUrl, "#").concat(destination.hash);
                  }
                }

                if (shouldReplace) {
                  window.history.replaceState(newState, "", newUrl);
                } else {
                  this._maxUid = this._uid;
                  window.history.pushState(newState, "", newUrl);
                }
              }
            }, {
              key: "_tryPushCurrentPosition",
              value: function _tryPushCurrentPosition() {
                var temporary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                if (!this._position) {
                  return;
                }

                var position = this._position;

                if (temporary) {
                  position = Object.assign(Object.create(null), this._position);
                  position.temporary = true;
                }

                if (!this._destination) {
                  this._pushOrReplaceState(position);

                  return;
                }

                if (this._destination.temporary) {
                  this._pushOrReplaceState(position, true);

                  return;
                }

                if (this._destination.hash === position.hash) {
                  return;
                }

                if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {
                  return;
                }

                var forceReplace = false;

                if (this._destination.page >= position.first && this._destination.page <= position.page) {
                  if (this._destination.dest || !this._destination.first) {
                    return;
                  }

                  forceReplace = true;
                }

                this._pushOrReplaceState(position, forceReplace);
              }
            }, {
              key: "_isValidState",
              value: function _isValidState(state) {
                var checkReload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                if (!state) {
                  return false;
                }

                if (state.fingerprint !== this._fingerprint) {
                  if (checkReload) {
                    if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) {
                      return false;
                    }

                    var _performance$getEntri = performance.getEntriesByType("navigation"),
                        _performance$getEntri2 = _slicedToArray(_performance$getEntri, 1),
                        perfEntry = _performance$getEntri2[0];

                    if (!perfEntry || perfEntry.type !== "reload") {
                      return false;
                    }
                  } else {
                    return false;
                  }
                }

                if (!Number.isInteger(state.uid) || state.uid < 0) {
                  return false;
                }

                if (state.destination === null || typeof state.destination !== "object") {
                  return false;
                }

                return true;
              }
            }, {
              key: "_updateInternalState",
              value: function _updateInternalState(destination, uid) {
                var removeTemporary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

                if (this._updateViewareaTimeout) {
                  clearTimeout(this._updateViewareaTimeout);
                  this._updateViewareaTimeout = null;
                }

                if (removeTemporary && destination && destination.temporary) {
                  delete destination.temporary;
                }

                this._destination = destination;
                this._uid = uid;
                this._numPositionUpdates = 0;
              }
            }, {
              key: "_parseCurrentHash",
              value: function _parseCurrentHash() {
                var hash = unescape(getCurrentHash()).substring(1);
                var page = (0, _ui_utils.parseQueryString)(hash).page | 0;

                if (!(Number.isInteger(page) && page > 0 && page <= this.linkService.pagesCount)) {
                  page = null;
                }

                return {
                  hash: hash,
                  page: page,
                  rotation: this.linkService.rotation
                };
              }
            }, {
              key: "_updateViewarea",
              value: function _updateViewarea(_ref50) {
                var _this69 = this;

                var location = _ref50.location;

                if (this._updateViewareaTimeout) {
                  clearTimeout(this._updateViewareaTimeout);
                  this._updateViewareaTimeout = null;
                }

                this._position = {
                  hash: this._isViewerInPresentationMode ? "page=".concat(location.pageNumber) : location.pdfOpenParams.substring(1),
                  page: this.linkService.page,
                  first: location.pageNumber,
                  rotation: location.rotation
                };

                if (this._popStateInProgress) {
                  return;
                }

                if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {
                  this._numPositionUpdates++;
                }

                if (UPDATE_VIEWAREA_TIMEOUT > 0) {
                  this._updateViewareaTimeout = setTimeout(function () {
                    if (!_this69._popStateInProgress) {
                      _this69._tryPushCurrentPosition(true);
                    }

                    _this69._updateViewareaTimeout = null;
                  }, UPDATE_VIEWAREA_TIMEOUT);
                }
              }
            }, {
              key: "_popState",
              value: function _popState(_ref51) {
                var _this70 = this;

                var state = _ref51.state;
                var newHash = getCurrentHash(),
                    hashChanged = this._currentHash !== newHash;
                this._currentHash = newHash;

                if (!state) {
                  this._uid++;

                  var _this$_parseCurrentHa2 = this._parseCurrentHash(),
                      hash = _this$_parseCurrentHa2.hash,
                      page = _this$_parseCurrentHa2.page,
                      rotation = _this$_parseCurrentHa2.rotation;

                  this._pushOrReplaceState({
                    hash: hash,
                    page: page,
                    rotation: rotation
                  }, true);

                  return;
                }

                if (!this._isValidState(state)) {
                  return;
                }

                this._popStateInProgress = true;

                if (hashChanged) {
                  this._blockHashChange++;
                  (0, _ui_utils.waitOnEventOrTimeout)({
                    target: window,
                    name: "hashchange",
                    delay: HASH_CHANGE_TIMEOUT
                  }).then(function () {
                    _this70._blockHashChange--;
                  });
                }

                var destination = state.destination;

                this._updateInternalState(destination, state.uid, true);

                if (this._uid > this._maxUid) {
                  this._maxUid = this._uid;
                }

                if ((0, _ui_utils.isValidRotation)(destination.rotation)) {
                  this.linkService.rotation = destination.rotation;
                }

                if (destination.dest) {
                  this.linkService.navigateTo(destination.dest);
                } else if (destination.hash) {
                  this.linkService.setHash(destination.hash);
                } else if (destination.page) {
                  this.linkService.page = destination.page;
                }

                Promise.resolve().then(function () {
                  _this70._popStateInProgress = false;
                });
              }
            }, {
              key: "_pageHide",
              value: function _pageHide() {
                if (!this._destination || this._destination.temporary) {
                  this._tryPushCurrentPosition();
                }
              }
            }, {
              key: "_bindEvents",
              value: function _bindEvents() {
                if (this._boundEvents) {
                  return;
                }

                this._boundEvents = {
                  updateViewarea: this._updateViewarea.bind(this),
                  popState: this._popState.bind(this),
                  pageHide: this._pageHide.bind(this)
                };

                this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea);

                window.addEventListener("popstate", this._boundEvents.popState);
                window.addEventListener("pagehide", this._boundEvents.pageHide);
              }
            }, {
              key: "_unbindEvents",
              value: function _unbindEvents() {
                if (!this._boundEvents) {
                  return;
                }

                this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea);

                window.removeEventListener("popstate", this._boundEvents.popState);
                window.removeEventListener("pagehide", this._boundEvents.pageHide);
                this._boundEvents = null;
              }
            }, {
              key: "popStateInProgress",
              get: function get() {
                return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
              }
            }, {
              key: "initialBookmark",
              get: function get() {
                return this._initialized ? this._initialBookmark : null;
              }
            }, {
              key: "initialRotation",
              get: function get() {
                return this._initialized ? this._initialRotation : null;
              }
            }]);

            return PDFHistory;
          }();

          exports.PDFHistory = PDFHistory;

          function isDestHashesEqual(destHash, pushHash) {
            if (typeof destHash !== "string" || typeof pushHash !== "string") {
              return false;
            }

            if (destHash === pushHash) {
              return true;
            }

            var _ref52 = (0, _ui_utils.parseQueryString)(destHash),
                nameddest = _ref52.nameddest;

            if (nameddest === pushHash) {
              return true;
            }

            return false;
          }

          function isDestArraysEqual(firstDest, secondDest) {
            function isEntryEqual(first, second) {
              if (typeof first !== typeof second) {
                return false;
              }

              if (Array.isArray(first) || Array.isArray(second)) {
                return false;
              }

              if (first !== null && typeof first === "object" && second !== null) {
                if (Object.keys(first).length !== Object.keys(second).length) {
                  return false;
                }

                for (var key in first) {
                  if (!isEntryEqual(first[key], second[key])) {
                    return false;
                  }
                }

                return true;
              }

              return first === second || Number.isNaN(first) && Number.isNaN(second);
            }

            if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {
              return false;
            }

            if (firstDest.length !== secondDest.length) {
              return false;
            }

            for (var i = 0, ii = firstDest.length; i < ii; i++) {
              if (!isEntryEqual(firstDest[i], secondDest[i])) {
                return false;
              }
            }

            return true;
          }
          /***/

        },
        /* 12 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PDFPageView = void 0;

          var _ui_utils = __w_pdfjs_require__(3);

          var _pdfjsLib = __w_pdfjs_require__(2);

          var _pdf_rendering_queue = __w_pdfjs_require__(13);

          var _viewer_compatibility = __w_pdfjs_require__(14);

          var MAX_CANVAS_PIXELS = _viewer_compatibility.viewerCompatibilityParams.maxCanvasPixels || 16777216;

          var PDFPageView = /*#__PURE__*/function () {
            function PDFPageView(options) {
              _classCallCheck(this, PDFPageView);

              var container = options.container;
              var defaultViewport = options.defaultViewport;
              this.id = options.id;
              this.renderingId = "page" + this.id;
              this.pdfPage = null;
              this.pageLabel = null;
              this.rotation = 0;
              this.scale = options.scale || _ui_utils.DEFAULT_SCALE;
              this.viewport = defaultViewport;
              this.pdfPageRotate = defaultViewport.rotation;
              this.hasRestrictedScaling = false;
              this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE;
              this.imageResourcesPath = options.imageResourcesPath || "";
              this.renderInteractiveForms = options.renderInteractiveForms || false;
              this.useOnlyCssZoom = options.useOnlyCssZoom || false;
              this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS;
              this.eventBus = options.eventBus || (0, _ui_utils.getGlobalEventBus)();
              this.renderingQueue = options.renderingQueue;
              this.textLayerFactory = options.textLayerFactory;
              this.annotationLayerFactory = options.annotationLayerFactory;
              this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
              this.enableWebGL = options.enableWebGL || false;
              this.l10n = options.l10n || _ui_utils.NullL10n;
              this.paintTask = null;
              this.paintedViewportMap = new WeakMap();
              this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
              this.resume = null;
              this.error = null;
              this.annotationLayer = null;
              this.textLayer = null;
              this.zoomLayer = null;
              var div = document.createElement("div");
              div.className = "page";
              div.style.width = Math.floor(this.viewport.width) + "px";
              div.style.height = Math.floor(this.viewport.height) + "px";
              div.setAttribute("data-page-number", this.id);
              this.div = div;
              container.appendChild(div);
            }

            _createClass(PDFPageView, [{
              key: "setPdfPage",
              value: function setPdfPage(pdfPage) {
                this.pdfPage = pdfPage;
                this.pdfPageRotate = pdfPage.rotate;
                var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
                this.viewport = pdfPage.getViewport({
                  scale: this.scale * _ui_utils.CSS_UNITS,
                  rotation: totalRotation
                });
                this.stats = pdfPage.stats;
                this.reset();
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.reset();

                if (this.pdfPage) {
                  this.pdfPage.cleanup();
                }
              }
            }, {
              key: "_resetZoomLayer",
              value: function _resetZoomLayer() {
                var removeFromDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                if (!this.zoomLayer) {
                  return;
                }

                var zoomLayerCanvas = this.zoomLayer.firstChild;
                this.paintedViewportMap["delete"](zoomLayerCanvas);
                zoomLayerCanvas.width = 0;
                zoomLayerCanvas.height = 0;

                if (removeFromDOM) {
                  this.zoomLayer.remove();
                }

                this.zoomLayer = null;
              }
            }, {
              key: "reset",
              value: function reset() {
                var keepZoomLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                var keepAnnotations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                this.cancelRendering(keepAnnotations);
                this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
                var div = this.div;
                div.style.width = Math.floor(this.viewport.width) + "px";
                div.style.height = Math.floor(this.viewport.height) + "px";
                var childNodes = div.childNodes;
                var currentZoomLayerNode = keepZoomLayer && this.zoomLayer || null;
                var currentAnnotationNode = keepAnnotations && this.annotationLayer && this.annotationLayer.div || null;

                for (var i = childNodes.length - 1; i >= 0; i--) {
                  var node = childNodes[i];

                  if (currentZoomLayerNode === node || currentAnnotationNode === node) {
                    continue;
                  }

                  div.removeChild(node);
                }

                div.removeAttribute("data-loaded");

                if (currentAnnotationNode) {
                  this.annotationLayer.hide();
                } else if (this.annotationLayer) {
                  this.annotationLayer.cancel();
                  this.annotationLayer = null;
                }

                if (!currentZoomLayerNode) {
                  if (this.canvas) {
                    this.paintedViewportMap["delete"](this.canvas);
                    this.canvas.width = 0;
                    this.canvas.height = 0;
                    delete this.canvas;
                  }

                  this._resetZoomLayer();
                }

                if (this.svg) {
                  this.paintedViewportMap["delete"](this.svg);
                  delete this.svg;
                }

                this.loadingIconDiv = document.createElement("div");
                this.loadingIconDiv.className = "loadingIcon";
                div.appendChild(this.loadingIconDiv);
              }
            }, {
              key: "update",
              value: function update(scale, rotation) {
                this.scale = scale || this.scale;

                if (typeof rotation !== "undefined") {
                  this.rotation = rotation;
                }

                var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
                this.viewport = this.viewport.clone({
                  scale: this.scale * _ui_utils.CSS_UNITS,
                  rotation: totalRotation
                });

                if (this.svg) {
                  this.cssTransform(this.svg, true);
                  this.eventBus.dispatch("pagerendered", {
                    source: this,
                    pageNumber: this.id,
                    cssTransform: true,
                    timestamp: performance.now()
                  });
                  return;
                }

                var isScalingRestricted = false;

                if (this.canvas && this.maxCanvasPixels > 0) {
                  var outputScale = this.outputScale;

                  if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) {
                    isScalingRestricted = true;
                  }
                }

                if (this.canvas) {
                  if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) {
                    this.cssTransform(this.canvas, true);
                    this.eventBus.dispatch("pagerendered", {
                      source: this,
                      pageNumber: this.id,
                      cssTransform: true,
                      timestamp: performance.now()
                    });
                    return;
                  }

                  if (!this.zoomLayer && !this.canvas.hasAttribute("hidden")) {
                    this.zoomLayer = this.canvas.parentNode;
                    this.zoomLayer.style.position = "absolute";
                  }
                }

                if (this.zoomLayer) {
                  this.cssTransform(this.zoomLayer.firstChild);
                }

                this.reset(true, true);
              }
            }, {
              key: "cancelRendering",
              value: function cancelRendering() {
                var keepAnnotations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

                if (this.paintTask) {
                  this.paintTask.cancel();
                  this.paintTask = null;
                }

                this.resume = null;

                if (this.textLayer) {
                  this.textLayer.cancel();
                  this.textLayer = null;
                }

                if (!keepAnnotations && this.annotationLayer) {
                  this.annotationLayer.cancel();
                  this.annotationLayer = null;
                }
              }
            }, {
              key: "cssTransform",
              value: function cssTransform(target) {
                var redrawAnnotations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var width = this.viewport.width;
                var height = this.viewport.height;
                var div = this.div;
                target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + "px";
                target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + "px";
                var relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation;
                var absRotation = Math.abs(relativeRotation);
                var scaleX = 1,
                    scaleY = 1;

                if (absRotation === 90 || absRotation === 270) {
                  scaleX = height / width;
                  scaleY = width / height;
                }

                var cssTransform = "rotate(" + relativeRotation + "deg) " + "scale(" + scaleX + "," + scaleY + ")";
                target.style.transform = cssTransform;

                if (this.textLayer) {
                  var textLayerViewport = this.textLayer.viewport;
                  var textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation;
                  var textAbsRotation = Math.abs(textRelativeRotation);
                  var scale = width / textLayerViewport.width;

                  if (textAbsRotation === 90 || textAbsRotation === 270) {
                    scale = width / textLayerViewport.height;
                  }

                  var textLayerDiv = this.textLayer.textLayerDiv;
                  var transX, transY;

                  switch (textAbsRotation) {
                    case 0:
                      transX = transY = 0;
                      break;

                    case 90:
                      transX = 0;
                      transY = "-" + textLayerDiv.style.height;
                      break;

                    case 180:
                      transX = "-" + textLayerDiv.style.width;
                      transY = "-" + textLayerDiv.style.height;
                      break;

                    case 270:
                      transX = "-" + textLayerDiv.style.width;
                      transY = 0;
                      break;

                    default:
                      console.error("Bad rotation value.");
                      break;
                  }

                  textLayerDiv.style.transform = "rotate(" + textAbsRotation + "deg) " + "scale(" + scale + ", " + scale + ") " + "translate(" + transX + ", " + transY + ")";
                  textLayerDiv.style.transformOrigin = "0% 0%";
                }

                if (redrawAnnotations && this.annotationLayer) {
                  this.annotationLayer.render(this.viewport, "display");
                }
              }
            }, {
              key: "getPagePoint",
              value: function getPagePoint(x, y) {
                return this.viewport.convertToPdfPoint(x, y);
              }
            }, {
              key: "draw",
              value: function draw() {
                var _this71 = this;

                if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
                  console.error("Must be in new state before drawing");
                  this.reset();
                }

                var div = this.div,
                    pdfPage = this.pdfPage;

                if (!pdfPage) {
                  this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

                  if (this.loadingIconDiv) {
                    div.removeChild(this.loadingIconDiv);
                    delete this.loadingIconDiv;
                  }

                  return Promise.reject(new Error("pdfPage is not loaded"));
                }

                this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
                var canvasWrapper = document.createElement("div");
                canvasWrapper.style.width = div.style.width;
                canvasWrapper.style.height = div.style.height;
                canvasWrapper.classList.add("canvasWrapper");

                if (this.annotationLayer && this.annotationLayer.div) {
                  div.insertBefore(canvasWrapper, this.annotationLayer.div);
                } else {
                  div.appendChild(canvasWrapper);
                }

                var textLayer = null;

                if (this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && this.textLayerFactory) {
                  var textLayerDiv = document.createElement("div");
                  textLayerDiv.className = "textLayer";
                  textLayerDiv.style.width = canvasWrapper.style.width;
                  textLayerDiv.style.height = canvasWrapper.style.height;

                  if (this.annotationLayer && this.annotationLayer.div) {
                    div.insertBefore(textLayerDiv, this.annotationLayer.div);
                  } else {
                    div.appendChild(textLayerDiv);
                  }

                  textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.textLayerMode === _ui_utils.TextLayerMode.ENABLE_ENHANCE, this.eventBus);
                }

                this.textLayer = textLayer;
                var renderContinueCallback = null;

                if (this.renderingQueue) {
                  renderContinueCallback = function renderContinueCallback(cont) {
                    if (!_this71.renderingQueue.isHighestPriority(_this71)) {
                      _this71.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED;

                      _this71.resume = function () {
                        _this71.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
                        cont();
                      };

                      return;
                    }

                    cont();
                  };
                }

                var finishPaintTask = /*#__PURE__*/function () {
                  var _ref53 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(error) {
                    return regeneratorRuntime.wrap(function _callee23$(_context23) {
                      while (1) {
                        switch (_context23.prev = _context23.next) {
                          case 0:
                            if (paintTask === _this71.paintTask) {
                              _this71.paintTask = null;
                            }

                            if (!(error instanceof _pdfjsLib.RenderingCancelledException)) {
                              _context23.next = 4;
                              break;
                            }

                            _this71.error = null;
                            return _context23.abrupt("return");

                          case 4:
                            _this71.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

                            if (_this71.loadingIconDiv) {
                              div.removeChild(_this71.loadingIconDiv);
                              delete _this71.loadingIconDiv;
                            }

                            _this71._resetZoomLayer(true);

                            _this71.error = error;
                            _this71.stats = pdfPage.stats;

                            _this71.eventBus.dispatch("pagerendered", {
                              source: _this71,
                              pageNumber: _this71.id,
                              cssTransform: false,
                              timestamp: performance.now()
                            });

                            if (!error) {
                              _context23.next = 12;
                              break;
                            }

                            throw error;

                          case 12:
                          case "end":
                            return _context23.stop();
                        }
                      }
                    }, _callee23);
                  }));

                  return function finishPaintTask(_x10) {
                    return _ref53.apply(this, arguments);
                  };
                }();

                var paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper);
                paintTask.onRenderContinue = renderContinueCallback;
                this.paintTask = paintTask;
                var resultPromise = paintTask.promise.then(function () {
                  return finishPaintTask(null).then(function () {
                    if (textLayer) {
                      var readableStream = pdfPage.streamTextContent({
                        normalizeWhitespace: true
                      });
                      textLayer.setTextContentStream(readableStream);
                      textLayer.render();
                    }
                  });
                }, function (reason) {
                  return finishPaintTask(reason);
                });

                if (this.annotationLayerFactory) {
                  if (!this.annotationLayer) {
                    this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, this.imageResourcesPath, this.renderInteractiveForms, this.l10n);
                  }

                  this.annotationLayer.render(this.viewport, "display");
                }

                div.setAttribute("data-loaded", true);
                this.eventBus.dispatch("pagerender", {
                  source: this,
                  pageNumber: this.id
                });
                return resultPromise;
              }
            }, {
              key: "paintOnCanvas",
              value: function paintOnCanvas(canvasWrapper) {
                var renderCapability = (0, _pdfjsLib.createPromiseCapability)();
                var result = {
                  promise: renderCapability.promise,
                  onRenderContinue: function onRenderContinue(cont) {
                    cont();
                  },
                  cancel: function cancel() {
                    renderTask.cancel();
                  }
                };
                var viewport = this.viewport;
                var canvas = document.createElement("canvas");
                this.l10n.get("page_canvas", {
                  page: this.id
                }, "Page {{page}}").then(function (msg) {
                  canvas.setAttribute("aria-label", msg);
                });
                canvas.setAttribute("hidden", "hidden");
                var isCanvasHidden = true;

                var showCanvas = function showCanvas() {
                  if (isCanvasHidden) {
                    canvas.removeAttribute("hidden");
                    isCanvasHidden = false;
                  }
                };

                canvasWrapper.appendChild(canvas);
                this.canvas = canvas;
                canvas.mozOpaque = true;
                var ctx = canvas.getContext("2d", {
                  alpha: false
                });
                var outputScale = (0, _ui_utils.getOutputScale)(ctx);
                this.outputScale = outputScale;

                if (this.useOnlyCssZoom) {
                  var actualSizeViewport = viewport.clone({
                    scale: _ui_utils.CSS_UNITS
                  });
                  outputScale.sx *= actualSizeViewport.width / viewport.width;
                  outputScale.sy *= actualSizeViewport.height / viewport.height;
                  outputScale.scaled = true;
                }

                if (this.maxCanvasPixels > 0) {
                  var pixelsInViewport = viewport.width * viewport.height;
                  var maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);

                  if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
                    outputScale.sx = maxScale;
                    outputScale.sy = maxScale;
                    outputScale.scaled = true;
                    this.hasRestrictedScaling = true;
                  } else {
                    this.hasRestrictedScaling = false;
                  }
                }

                var sfx = (0, _ui_utils.approximateFraction)(outputScale.sx);
                var sfy = (0, _ui_utils.approximateFraction)(outputScale.sy);
                canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]);
                canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]);
                canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + "px";
                canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + "px";
                this.paintedViewportMap.set(canvas, viewport);
                var transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0];
                var renderContext = {
                  canvasContext: ctx,
                  transform: transform,
                  viewport: this.viewport,
                  enableWebGL: this.enableWebGL,
                  renderInteractiveForms: this.renderInteractiveForms
                };
                var renderTask = this.pdfPage.render(renderContext);

                renderTask.onContinue = function (cont) {
                  showCanvas();

                  if (result.onRenderContinue) {
                    result.onRenderContinue(cont);
                  } else {
                    cont();
                  }
                };

                renderTask.promise.then(function () {
                  showCanvas();
                  renderCapability.resolve(undefined);
                }, function (error) {
                  showCanvas();
                  renderCapability.reject(error);
                });
                return result;
              }
            }, {
              key: "paintOnSvg",
              value: function paintOnSvg(wrapper) {
                var _this72 = this;

                var cancelled = false;

                var ensureNotCancelled = function ensureNotCancelled() {
                  if (cancelled) {
                    throw new _pdfjsLib.RenderingCancelledException("Rendering cancelled, page ".concat(_this72.id), "svg");
                  }
                };

                var pdfPage = this.pdfPage;
                var actualSizeViewport = this.viewport.clone({
                  scale: _ui_utils.CSS_UNITS
                });
                var promise = pdfPage.getOperatorList().then(function (opList) {
                  ensureNotCancelled();
                  var svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs);
                  return svgGfx.getSVG(opList, actualSizeViewport).then(function (svg) {
                    ensureNotCancelled();
                    _this72.svg = svg;

                    _this72.paintedViewportMap.set(svg, actualSizeViewport);

                    svg.style.width = wrapper.style.width;
                    svg.style.height = wrapper.style.height;
                    _this72.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
                    wrapper.appendChild(svg);
                  });
                });
                return {
                  promise: promise,
                  onRenderContinue: function onRenderContinue(cont) {
                    cont();
                  },
                  cancel: function cancel() {
                    cancelled = true;
                  }
                };
              }
            }, {
              key: "setPageLabel",
              value: function setPageLabel(label) {
                this.pageLabel = typeof label === "string" ? label : null;

                if (this.pageLabel !== null) {
                  this.div.setAttribute("data-page-label", this.pageLabel);
                } else {
                  this.div.removeAttribute("data-page-label");
                }
              }
            }, {
              key: "width",
              get: function get() {
                return this.viewport.width;
              }
            }, {
              key: "height",
              get: function get() {
                return this.viewport.height;
              }
            }]);

            return PDFPageView;
          }();

          exports.PDFPageView = PDFPageView;
          /***/
        },
        /* 13 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PDFRenderingQueue = exports.RenderingStates = void 0;
          var CLEANUP_TIMEOUT = 30000;
          var RenderingStates = {
            INITIAL: 0,
            RUNNING: 1,
            PAUSED: 2,
            FINISHED: 3
          };
          exports.RenderingStates = RenderingStates;

          var PDFRenderingQueue = /*#__PURE__*/function () {
            function PDFRenderingQueue() {
              _classCallCheck(this, PDFRenderingQueue);

              this.pdfViewer = null;
              this.pdfThumbnailViewer = null;
              this.onIdle = null;
              this.highestPriorityPage = null;
              this.idleTimeout = null;
              this.printing = false;
              this.isThumbnailViewEnabled = false;
            }

            _createClass(PDFRenderingQueue, [{
              key: "setViewer",
              value: function setViewer(pdfViewer) {
                this.pdfViewer = pdfViewer;
              }
            }, {
              key: "setThumbnailViewer",
              value: function setThumbnailViewer(pdfThumbnailViewer) {
                this.pdfThumbnailViewer = pdfThumbnailViewer;
              }
            }, {
              key: "isHighestPriority",
              value: function isHighestPriority(view) {
                return this.highestPriorityPage === view.renderingId;
              }
            }, {
              key: "renderHighestPriority",
              value: function renderHighestPriority(currentlyVisiblePages) {
                if (this.idleTimeout) {
                  clearTimeout(this.idleTimeout);
                  this.idleTimeout = null;
                }

                if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
                  return;
                }

                if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {
                  if (this.pdfThumbnailViewer.forceRendering()) {
                    return;
                  }
                }

                if (this.printing) {
                  return;
                }

                if (this.onIdle) {
                  this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);
                }
              }
            }, {
              key: "getHighestPriority",
              value: function getHighestPriority(visible, views, scrolledDown) {
                var visibleViews = visible.views;
                var numVisible = visibleViews.length;

                if (numVisible === 0) {
                  return null;
                }

                for (var i = 0; i < numVisible; ++i) {
                  var view = visibleViews[i].view;

                  if (!this.isViewFinished(view)) {
                    return view;
                  }
                }

                if (scrolledDown) {
                  var nextPageIndex = visible.last.id;

                  if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {
                    return views[nextPageIndex];
                  }
                } else {
                  var previousPageIndex = visible.first.id - 2;

                  if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) {
                    return views[previousPageIndex];
                  }
                }

                return null;
              }
            }, {
              key: "isViewFinished",
              value: function isViewFinished(view) {
                return view.renderingState === RenderingStates.FINISHED;
              }
            }, {
              key: "renderView",
              value: function renderView(view) {
                var _this73 = this;

                switch (view.renderingState) {
                  case RenderingStates.FINISHED:
                    return false;

                  case RenderingStates.PAUSED:
                    this.highestPriorityPage = view.renderingId;
                    view.resume();
                    break;

                  case RenderingStates.RUNNING:
                    this.highestPriorityPage = view.renderingId;
                    break;

                  case RenderingStates.INITIAL:
                    this.highestPriorityPage = view.renderingId;
                    view.draw()["finally"](function () {
                      _this73.renderHighestPriority();
                    })["catch"](function (reason) {
                      console.error("renderView: \"".concat(reason, "\""));
                    });
                    break;
                }

                return true;
              }
            }]);

            return PDFRenderingQueue;
          }();

          exports.PDFRenderingQueue = PDFRenderingQueue;
          /***/
        },
        /* 14 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          var compatibilityParams = Object.create(null);
          {
            var userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
            var platform = typeof navigator !== "undefined" && navigator.platform || "";
            var maxTouchPoints = typeof navigator !== "undefined" && navigator.maxTouchPoints || 1;
            var isAndroid = /Android/.test(userAgent);
            var isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1;

            (function checkCanvasSizeLimitation() {
              if (isIOS || isAndroid) {
                compatibilityParams.maxCanvasPixels = 5242880;
              }
            })();
          }
          exports.viewerCompatibilityParams = Object.freeze(compatibilityParams);
          /***/
        },
        /* 15 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PDFSinglePageViewer = void 0;

          var _base_viewer = __w_pdfjs_require__(16);

          var _pdfjsLib = __w_pdfjs_require__(2);

          var PDFSinglePageViewer = /*#__PURE__*/function (_base_viewer$BaseView) {
            _inherits(PDFSinglePageViewer, _base_viewer$BaseView);

            var _super38 = _createSuper(PDFSinglePageViewer);

            function PDFSinglePageViewer(options) {
              var _this74;

              _classCallCheck(this, PDFSinglePageViewer);

              _this74 = _super38.call(this, options);

              _this74.eventBus._on("pagesinit", function (evt) {
                _this74._ensurePageViewVisible();
              });

              return _this74;
            }

            _createClass(PDFSinglePageViewer, [{
              key: "_resetView",
              value: function _resetView() {
                _get(_getPrototypeOf(PDFSinglePageViewer.prototype), "_resetView", this).call(this);

                this._previousPageNumber = 1;
                this._shadowViewer = document.createDocumentFragment();
                this._updateScrollDown = null;
              }
            }, {
              key: "_ensurePageViewVisible",
              value: function _ensurePageViewVisible() {
                var pageView = this._pages[this._currentPageNumber - 1];
                var previousPageView = this._pages[this._previousPageNumber - 1];
                var viewerNodes = this.viewer.childNodes;

                switch (viewerNodes.length) {
                  case 0:
                    this.viewer.appendChild(pageView.div);
                    break;

                  case 1:
                    if (viewerNodes[0] !== previousPageView.div) {
                      throw new Error("_ensurePageViewVisible: Unexpected previously visible page.");
                    }

                    if (pageView === previousPageView) {
                      break;
                    }

                    this._shadowViewer.appendChild(previousPageView.div);

                    this.viewer.appendChild(pageView.div);
                    this.container.scrollTop = 0;
                    break;

                  default:
                    throw new Error("_ensurePageViewVisible: Only one page should be visible at a time.");
                }

                this._previousPageNumber = this._currentPageNumber;
              }
            }, {
              key: "_scrollUpdate",
              value: function _scrollUpdate() {
                if (this._updateScrollDown) {
                  this._updateScrollDown();
                }

                _get(_getPrototypeOf(PDFSinglePageViewer.prototype), "_scrollUpdate", this).call(this);
              }
            }, {
              key: "_scrollIntoView",
              value: function _scrollIntoView(_ref54) {
                var _this75 = this;

                var pageDiv = _ref54.pageDiv,
                    _ref54$pageSpot = _ref54.pageSpot,
                    pageSpot = _ref54$pageSpot === void 0 ? null : _ref54$pageSpot,
                    _ref54$pageNumber = _ref54.pageNumber,
                    pageNumber = _ref54$pageNumber === void 0 ? null : _ref54$pageNumber;

                if (pageNumber) {
                  this._setCurrentPageNumber(pageNumber);
                }

                var scrolledDown = this._currentPageNumber >= this._previousPageNumber;

                this._ensurePageViewVisible();

                this.update();

                _get(_getPrototypeOf(PDFSinglePageViewer.prototype), "_scrollIntoView", this).call(this, {
                  pageDiv: pageDiv,
                  pageSpot: pageSpot,
                  pageNumber: pageNumber
                });

                this._updateScrollDown = function () {
                  _this75.scroll.down = scrolledDown;
                  _this75._updateScrollDown = null;
                };
              }
            }, {
              key: "_getVisiblePages",
              value: function _getVisiblePages() {
                return this._getCurrentVisiblePage();
              }
            }, {
              key: "_updateHelper",
              value: function _updateHelper(visiblePages) {}
            }, {
              key: "_updateScrollMode",
              value: function _updateScrollMode() {}
            }, {
              key: "_updateSpreadMode",
              value: function _updateSpreadMode() {}
            }, {
              key: "_setDocumentViewerElement",
              get: function get() {
                return (0, _pdfjsLib.shadow)(this, "_setDocumentViewerElement", this._shadowViewer);
              }
            }, {
              key: "_isScrollModeHorizontal",
              get: function get() {
                return (0, _pdfjsLib.shadow)(this, "_isScrollModeHorizontal", false);
              }
            }]);

            return PDFSinglePageViewer;
          }(_base_viewer.BaseViewer);

          exports.PDFSinglePageViewer = PDFSinglePageViewer;
          /***/
        },
        /* 16 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseViewer = void 0;

          var _ui_utils = __w_pdfjs_require__(3);

          var _pdf_rendering_queue = __w_pdfjs_require__(13);

          var _annotation_layer_builder = __w_pdfjs_require__(1);

          var _pdfjsLib = __w_pdfjs_require__(2);

          var _pdf_page_view = __w_pdfjs_require__(12);

          var _pdf_link_service = __w_pdfjs_require__(4);

          var _text_layer_builder = __w_pdfjs_require__(5);

          var DEFAULT_CACHE_SIZE = 10;

          function PDFPageViewBuffer(size) {
            var data = [];

            this.push = function (view) {
              var i = data.indexOf(view);

              if (i >= 0) {
                data.splice(i, 1);
              }

              data.push(view);

              if (data.length > size) {
                data.shift().destroy();
              }
            };

            this.resize = function (newSize, pagesToKeep) {
              size = newSize;

              if (pagesToKeep) {
                var pageIdsToKeep = new Set();

                for (var i = 0, iMax = pagesToKeep.length; i < iMax; ++i) {
                  pageIdsToKeep.add(pagesToKeep[i].id);
                }

                (0, _ui_utils.moveToEndOfArray)(data, function (page) {
                  return pageIdsToKeep.has(page.id);
                });
              }

              while (data.length > size) {
                data.shift().destroy();
              }
            };
          }

          function isSameScale(oldScale, newScale) {
            if (newScale === oldScale) {
              return true;
            }

            if (Math.abs(newScale - oldScale) < 1e-15) {
              return true;
            }

            return false;
          }

          var BaseViewer = /*#__PURE__*/function () {
            function BaseViewer(options) {
              var _this76 = this;

              _classCallCheck(this, BaseViewer);

              if (this.constructor === BaseViewer) {
                throw new Error("Cannot initialize BaseViewer.");
              }

              this._name = this.constructor.name;
              this.container = options.container;
              this.viewer = options.viewer || options.container.firstElementChild;
              this.eventBus = options.eventBus || (0, _ui_utils.getGlobalEventBus)();
              this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService();
              this.downloadManager = options.downloadManager || null;
              this.findController = options.findController || null;
              this.removePageBorders = options.removePageBorders || false;
              this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE;
              this.imageResourcesPath = options.imageResourcesPath || "";
              this.renderInteractiveForms = options.renderInteractiveForms || false;
              this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;
              this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
              this.enableWebGL = options.enableWebGL || false;
              this.useOnlyCssZoom = options.useOnlyCssZoom || false;
              this.maxCanvasPixels = options.maxCanvasPixels;
              this.l10n = options.l10n || _ui_utils.NullL10n;
              this.defaultRenderingQueue = !options.renderingQueue;

              if (this.defaultRenderingQueue) {
                this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
                this.renderingQueue.setViewer(this);
              } else {
                this.renderingQueue = options.renderingQueue;
              }

              this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this));
              this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN;
              this._onBeforeDraw = this._onAfterDraw = null;

              this._resetView();

              if (this.removePageBorders) {
                this.viewer.classList.add("removePageBorders");
              }

              Promise.resolve().then(function () {
                _this76.eventBus.dispatch("baseviewerinit", {
                  source: _this76
                });
              });
            }

            _createClass(BaseViewer, [{
              key: "getPageView",
              value: function getPageView(index) {
                return this._pages[index];
              }
            }, {
              key: "_setCurrentPageNumber",
              value: function _setCurrentPageNumber(val) {
                var resetCurrentPageView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                if (this._currentPageNumber === val) {
                  if (resetCurrentPageView) {
                    this._resetCurrentPageView();
                  }

                  return true;
                }

                if (!(0 < val && val <= this.pagesCount)) {
                  return false;
                }

                this._currentPageNumber = val;
                this.eventBus.dispatch("pagechanging", {
                  source: this,
                  pageNumber: val,
                  pageLabel: this._pageLabels && this._pageLabels[val - 1]
                });

                if (resetCurrentPageView) {
                  this._resetCurrentPageView();
                }

                return true;
              }
            }, {
              key: "setDocument",
              value: function setDocument(pdfDocument) {
                var _this77 = this;

                if (this.pdfDocument) {
                  this._cancelRendering();

                  this._resetView();

                  if (this.findController) {
                    this.findController.setDocument(null);
                  }
                }

                this.pdfDocument = pdfDocument;

                if (!pdfDocument) {
                  return;
                }

                var pagesCount = pdfDocument.numPages;
                var firstPagePromise = pdfDocument.getPage(1);

                this._pagesCapability.promise.then(function () {
                  _this77.eventBus.dispatch("pagesloaded", {
                    source: _this77,
                    pagesCount: pagesCount
                  });
                });

                this._onBeforeDraw = function (evt) {
                  var pageView = _this77._pages[evt.pageNumber - 1];

                  if (!pageView) {
                    return;
                  }

                  _this77._buffer.push(pageView);
                };

                this.eventBus._on("pagerender", this._onBeforeDraw);

                this._onAfterDraw = function (evt) {
                  if (evt.cssTransform || _this77._onePageRenderedCapability.settled) {
                    return;
                  }

                  _this77._onePageRenderedCapability.resolve();

                  _this77.eventBus._off("pagerendered", _this77._onAfterDraw);

                  _this77._onAfterDraw = null;
                };

                this.eventBus._on("pagerendered", this._onAfterDraw);

                firstPagePromise.then(function (firstPdfPage) {
                  _this77._firstPageCapability.resolve(firstPdfPage);

                  var scale = _this77.currentScale;
                  var viewport = firstPdfPage.getViewport({
                    scale: scale * _ui_utils.CSS_UNITS
                  });
                  var textLayerFactory = _this77.textLayerMode !== _ui_utils.TextLayerMode.DISABLE ? _this77 : null;

                  for (var pageNum = 1; pageNum <= pagesCount; ++pageNum) {
                    var pageView = new _pdf_page_view.PDFPageView({
                      container: _this77._setDocumentViewerElement,
                      eventBus: _this77.eventBus,
                      id: pageNum,
                      scale: scale,
                      defaultViewport: viewport.clone(),
                      renderingQueue: _this77.renderingQueue,
                      textLayerFactory: textLayerFactory,
                      textLayerMode: _this77.textLayerMode,
                      annotationLayerFactory: _this77,
                      imageResourcesPath: _this77.imageResourcesPath,
                      renderInteractiveForms: _this77.renderInteractiveForms,
                      renderer: _this77.renderer,
                      enableWebGL: _this77.enableWebGL,
                      useOnlyCssZoom: _this77.useOnlyCssZoom,
                      maxCanvasPixels: _this77.maxCanvasPixels,
                      l10n: _this77.l10n
                    });

                    _this77._pages.push(pageView);
                  }

                  var firstPageView = _this77._pages[0];

                  if (firstPageView) {
                    firstPageView.setPdfPage(firstPdfPage);

                    _this77.linkService.cachePageRef(1, firstPdfPage.ref);
                  }

                  if (_this77._spreadMode !== _ui_utils.SpreadMode.NONE) {
                    _this77._updateSpreadMode();
                  }

                  _this77._onePageRenderedCapability.promise.then(function () {
                    if (_this77.findController) {
                      _this77.findController.setDocument(pdfDocument);
                    }

                    if (pdfDocument.loadingParams["disableAutoFetch"] || pagesCount > 7500) {
                      _this77._pagesCapability.resolve();

                      return;
                    }

                    var getPagesLeft = pagesCount - 1;

                    if (getPagesLeft <= 0) {
                      _this77._pagesCapability.resolve();

                      return;
                    }

                    var _loop3 = function _loop3(_pageNum) {
                      pdfDocument.getPage(_pageNum).then(function (pdfPage) {
                        var pageView = _this77._pages[_pageNum - 1];

                        if (!pageView.pdfPage) {
                          pageView.setPdfPage(pdfPage);
                        }

                        _this77.linkService.cachePageRef(_pageNum, pdfPage.ref);

                        if (--getPagesLeft === 0) {
                          _this77._pagesCapability.resolve();
                        }
                      }, function (reason) {
                        console.error("Unable to get page ".concat(_pageNum, " to initialize viewer"), reason);

                        if (--getPagesLeft === 0) {
                          _this77._pagesCapability.resolve();
                        }
                      });
                    };

                    for (var _pageNum = 2; _pageNum <= pagesCount; ++_pageNum) {
                      _loop3(_pageNum);
                    }
                  });

                  _this77.eventBus.dispatch("pagesinit", {
                    source: _this77
                  });

                  if (_this77.defaultRenderingQueue) {
                    _this77.update();
                  }
                })["catch"](function (reason) {
                  console.error("Unable to initialize viewer", reason);
                });
              }
            }, {
              key: "setPageLabels",
              value: function setPageLabels(labels) {
                if (!this.pdfDocument) {
                  return;
                }

                if (!labels) {
                  this._pageLabels = null;
                } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
                  this._pageLabels = null;
                  console.error("".concat(this._name, ".setPageLabels: Invalid page labels."));
                } else {
                  this._pageLabels = labels;
                }

                for (var i = 0, ii = this._pages.length; i < ii; i++) {
                  var pageView = this._pages[i];
                  var label = this._pageLabels && this._pageLabels[i];
                  pageView.setPageLabel(label);
                }
              }
            }, {
              key: "_resetView",
              value: function _resetView() {
                this._pages = [];
                this._currentPageNumber = 1;
                this._currentScale = _ui_utils.UNKNOWN_SCALE;
                this._currentScaleValue = null;
                this._pageLabels = null;
                this._buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);
                this._location = null;
                this._pagesRotation = 0;
                this._pagesRequests = new WeakMap();
                this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
                this._onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)();
                this._pagesCapability = (0, _pdfjsLib.createPromiseCapability)();
                this._scrollMode = _ui_utils.ScrollMode.VERTICAL;
                this._spreadMode = _ui_utils.SpreadMode.NONE;

                if (this._onBeforeDraw) {
                  this.eventBus._off("pagerender", this._onBeforeDraw);

                  this._onBeforeDraw = null;
                }

                if (this._onAfterDraw) {
                  this.eventBus._off("pagerendered", this._onAfterDraw);

                  this._onAfterDraw = null;
                }

                this.viewer.textContent = "";

                this._updateScrollMode();
              }
            }, {
              key: "_scrollUpdate",
              value: function _scrollUpdate() {
                if (this.pagesCount === 0) {
                  return;
                }

                this.update();
              }
            }, {
              key: "_scrollIntoView",
              value: function _scrollIntoView(_ref55) {
                var pageDiv = _ref55.pageDiv,
                    _ref55$pageSpot = _ref55.pageSpot,
                    pageSpot = _ref55$pageSpot === void 0 ? null : _ref55$pageSpot,
                    _ref55$pageNumber = _ref55.pageNumber,
                    pageNumber = _ref55$pageNumber === void 0 ? null : _ref55$pageNumber;
                (0, _ui_utils.scrollIntoView)(pageDiv, pageSpot);
              }
            }, {
              key: "_setScaleUpdatePages",
              value: function _setScaleUpdatePages(newScale, newValue) {
                var noScroll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                var preset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                this._currentScaleValue = newValue.toString();

                if (isSameScale(this._currentScale, newScale)) {
                  if (preset) {
                    this.eventBus.dispatch("scalechanging", {
                      source: this,
                      scale: newScale,
                      presetValue: newValue
                    });
                  }

                  return;
                }

                for (var i = 0, ii = this._pages.length; i < ii; i++) {
                  this._pages[i].update(newScale);
                }

                this._currentScale = newScale;

                if (!noScroll) {
                  var page = this._currentPageNumber,
                      dest;

                  if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) {
                    page = this._location.pageNumber;
                    dest = [null, {
                      name: "XYZ"
                    }, this._location.left, this._location.top, null];
                  }

                  this.scrollPageIntoView({
                    pageNumber: page,
                    destArray: dest,
                    allowNegativeOffset: true
                  });
                }

                this.eventBus.dispatch("scalechanging", {
                  source: this,
                  scale: newScale,
                  presetValue: preset ? newValue : undefined
                });

                if (this.defaultRenderingQueue) {
                  this.update();
                }
              }
            }, {
              key: "_setScale",
              value: function _setScale(value) {
                var noScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                var scale = parseFloat(value);

                if (scale > 0) {
                  this._setScaleUpdatePages(scale, value, noScroll, false);
                } else {
                  var currentPage = this._pages[this._currentPageNumber - 1];

                  if (!currentPage) {
                    return;
                  }

                  var noPadding = this.isInPresentationMode || this.removePageBorders;
                  var hPadding = noPadding ? 0 : _ui_utils.SCROLLBAR_PADDING;
                  var vPadding = noPadding ? 0 : _ui_utils.VERTICAL_PADDING;

                  if (!noPadding && this._isScrollModeHorizontal) {
                    var _ref56 = [vPadding, hPadding];
                    hPadding = _ref56[0];
                    vPadding = _ref56[1];
                  }

                  var pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale;
                  var pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;

                  switch (value) {
                    case "page-actual":
                      scale = 1;
                      break;

                    case "page-width":
                      scale = pageWidthScale;
                      break;

                    case "page-height":
                      scale = pageHeightScale;
                      break;

                    case "page-fit":
                      scale = Math.min(pageWidthScale, pageHeightScale);
                      break;

                    case "auto":
                      var horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);
                      scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale);
                      break;

                    default:
                      console.error("".concat(this._name, "._setScale: \"").concat(value, "\" is an unknown zoom value."));
                      return;
                  }

                  this._setScaleUpdatePages(scale, value, noScroll, true);
                }
              }
            }, {
              key: "_resetCurrentPageView",
              value: function _resetCurrentPageView() {
                if (this.isInPresentationMode) {
                  this._setScale(this._currentScaleValue, true);
                }

                var pageView = this._pages[this._currentPageNumber - 1];

                this._scrollIntoView({
                  pageDiv: pageView.div
                });
              }
            }, {
              key: "scrollPageIntoView",
              value: function scrollPageIntoView(_ref57) {
                var pageNumber = _ref57.pageNumber,
                    _ref57$destArray = _ref57.destArray,
                    destArray = _ref57$destArray === void 0 ? null : _ref57$destArray,
                    _ref57$allowNegativeO = _ref57.allowNegativeOffset,
                    allowNegativeOffset = _ref57$allowNegativeO === void 0 ? false : _ref57$allowNegativeO,
                    _ref57$ignoreDestinat = _ref57.ignoreDestinationZoom,
                    ignoreDestinationZoom = _ref57$ignoreDestinat === void 0 ? false : _ref57$ignoreDestinat;

                if (!this.pdfDocument) {
                  return;
                }

                var pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];

                if (!pageView) {
                  console.error("".concat(this._name, ".scrollPageIntoView: ") + "\"".concat(pageNumber, "\" is not a valid pageNumber parameter."));
                  return;
                }

                if (this.isInPresentationMode || !destArray) {
                  this._setCurrentPageNumber(pageNumber, true);

                  return;
                }

                var x = 0,
                    y = 0;
                var width = 0,
                    height = 0,
                    widthScale,
                    heightScale;
                var changeOrientation = pageView.rotation % 180 !== 0;
                var pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _ui_utils.CSS_UNITS;
                var pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _ui_utils.CSS_UNITS;
                var scale = 0;

                switch (destArray[1].name) {
                  case "XYZ":
                    x = destArray[2];
                    y = destArray[3];
                    scale = destArray[4];
                    x = x !== null ? x : 0;
                    y = y !== null ? y : pageHeight;
                    break;

                  case "Fit":
                  case "FitB":
                    scale = "page-fit";
                    break;

                  case "FitH":
                  case "FitBH":
                    y = destArray[2];
                    scale = "page-width";

                    if (y === null && this._location) {
                      x = this._location.left;
                      y = this._location.top;
                    }

                    break;

                  case "FitV":
                  case "FitBV":
                    x = destArray[2];
                    width = pageWidth;
                    height = pageHeight;
                    scale = "page-height";
                    break;

                  case "FitR":
                    x = destArray[2];
                    y = destArray[3];
                    width = destArray[4] - x;
                    height = destArray[5] - y;
                    var hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING;
                    var vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING;
                    widthScale = (this.container.clientWidth - hPadding) / width / _ui_utils.CSS_UNITS;
                    heightScale = (this.container.clientHeight - vPadding) / height / _ui_utils.CSS_UNITS;
                    scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
                    break;

                  default:
                    console.error("".concat(this._name, ".scrollPageIntoView: ") + "\"".concat(destArray[1].name, "\" is not a valid destination type."));
                    return;
                }

                if (!ignoreDestinationZoom) {
                  if (scale && scale !== this._currentScale) {
                    this.currentScaleValue = scale;
                  } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) {
                    this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
                  }
                }

                if (scale === "page-fit" && !destArray[4]) {
                  this._scrollIntoView({
                    pageDiv: pageView.div,
                    pageNumber: pageNumber
                  });

                  return;
                }

                var boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)];
                var left = Math.min(boundingRect[0][0], boundingRect[1][0]);
                var top = Math.min(boundingRect[0][1], boundingRect[1][1]);

                if (!allowNegativeOffset) {
                  left = Math.max(left, 0);
                  top = Math.max(top, 0);
                }

                this._scrollIntoView({
                  pageDiv: pageView.div,
                  pageSpot: {
                    left: left,
                    top: top
                  },
                  pageNumber: pageNumber
                });
              }
            }, {
              key: "_updateLocation",
              value: function _updateLocation(firstPage) {
                var currentScale = this._currentScale;
                var currentScaleValue = this._currentScaleValue;
                var normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue;
                var pageNumber = firstPage.id;
                var pdfOpenParams = "#page=" + pageNumber;
                pdfOpenParams += "&zoom=" + normalizedScaleValue;
                var currentPageView = this._pages[pageNumber - 1];
                var container = this.container;
                var topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);
                var intLeft = Math.round(topLeft[0]);
                var intTop = Math.round(topLeft[1]);
                pdfOpenParams += "," + intLeft + "," + intTop;
                this._location = {
                  pageNumber: pageNumber,
                  scale: normalizedScaleValue,
                  top: intTop,
                  left: intLeft,
                  rotation: this._pagesRotation,
                  pdfOpenParams: pdfOpenParams
                };
              }
            }, {
              key: "_updateHelper",
              value: function _updateHelper(visiblePages) {
                throw new Error("Not implemented: _updateHelper");
              }
            }, {
              key: "update",
              value: function update() {
                var visible = this._getVisiblePages();

                var visiblePages = visible.views,
                    numVisiblePages = visiblePages.length;

                if (numVisiblePages === 0) {
                  return;
                }

                var newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);

                this._buffer.resize(newCacheSize, visiblePages);

                this.renderingQueue.renderHighestPriority(visible);

                this._updateHelper(visiblePages);

                this._updateLocation(visible.first);

                this.eventBus.dispatch("updateviewarea", {
                  source: this,
                  location: this._location
                });
              }
            }, {
              key: "containsElement",
              value: function containsElement(element) {
                return this.container.contains(element);
              }
            }, {
              key: "focus",
              value: function focus() {
                this.container.focus();
              }
            }, {
              key: "_getCurrentVisiblePage",
              value: function _getCurrentVisiblePage() {
                if (!this.pagesCount) {
                  return {
                    views: []
                  };
                }

                var pageView = this._pages[this._currentPageNumber - 1];
                var element = pageView.div;
                var view = {
                  id: pageView.id,
                  x: element.offsetLeft + element.clientLeft,
                  y: element.offsetTop + element.clientTop,
                  view: pageView
                };
                return {
                  first: view,
                  last: view,
                  views: [view]
                };
              }
            }, {
              key: "_getVisiblePages",
              value: function _getVisiblePages() {
                return (0, _ui_utils.getVisibleElements)(this.container, this._pages, true, this._isScrollModeHorizontal);
              }
            }, {
              key: "isPageVisible",
              value: function isPageVisible(pageNumber) {
                if (!this.pdfDocument) {
                  return false;
                }

                if (pageNumber < 1 || pageNumber > this.pagesCount) {
                  console.error("".concat(this._name, ".isPageVisible: \"").concat(pageNumber, "\" is out of bounds."));
                  return false;
                }

                return this._getVisiblePages().views.some(function (view) {
                  return view.id === pageNumber;
                });
              }
            }, {
              key: "cleanup",
              value: function cleanup() {
                for (var i = 0, ii = this._pages.length; i < ii; i++) {
                  if (this._pages[i] && this._pages[i].renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
                    this._pages[i].reset();
                  }
                }
              }
            }, {
              key: "_cancelRendering",
              value: function _cancelRendering() {
                for (var i = 0, ii = this._pages.length; i < ii; i++) {
                  if (this._pages[i]) {
                    this._pages[i].cancelRendering();
                  }
                }
              }
            }, {
              key: "_ensurePdfPageLoaded",
              value: function _ensurePdfPageLoaded(pageView) {
                var _this78 = this;

                if (pageView.pdfPage) {
                  return Promise.resolve(pageView.pdfPage);
                }

                if (this._pagesRequests.has(pageView)) {
                  return this._pagesRequests.get(pageView);
                }

                var promise = this.pdfDocument.getPage(pageView.id).then(function (pdfPage) {
                  if (!pageView.pdfPage) {
                    pageView.setPdfPage(pdfPage);
                  }

                  _this78._pagesRequests["delete"](pageView);

                  return pdfPage;
                })["catch"](function (reason) {
                  console.error("Unable to get page for page view", reason);

                  _this78._pagesRequests["delete"](pageView);
                });

                this._pagesRequests.set(pageView, promise);

                return promise;
              }
            }, {
              key: "forceRendering",
              value: function forceRendering(currentlyVisiblePages) {
                var _this79 = this;

                var visiblePages = currentlyVisiblePages || this._getVisiblePages();

                var scrollAhead = this._isScrollModeHorizontal ? this.scroll.right : this.scroll.down;
                var pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead);

                if (pageView) {
                  this._ensurePdfPageLoaded(pageView).then(function () {
                    _this79.renderingQueue.renderView(pageView);
                  });

                  return true;
                }

                return false;
              }
            }, {
              key: "createTextLayerBuilder",
              value: function createTextLayerBuilder(textLayerDiv, pageIndex, viewport) {
                var enhanceTextSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                var eventBus = arguments.length > 4 ? arguments[4] : undefined;
                return new _text_layer_builder.TextLayerBuilder({
                  textLayerDiv: textLayerDiv,
                  eventBus: eventBus,
                  pageIndex: pageIndex,
                  viewport: viewport,
                  findController: this.isInPresentationMode ? null : this.findController,
                  enhanceTextSelection: this.isInPresentationMode ? false : enhanceTextSelection
                });
              }
            }, {
              key: "createAnnotationLayerBuilder",
              value: function createAnnotationLayerBuilder(pageDiv, pdfPage) {
                var imageResourcesPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
                var renderInteractiveForms = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                var l10n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _ui_utils.NullL10n;
                return new _annotation_layer_builder.AnnotationLayerBuilder({
                  pageDiv: pageDiv,
                  pdfPage: pdfPage,
                  imageResourcesPath: imageResourcesPath,
                  renderInteractiveForms: renderInteractiveForms,
                  linkService: this.linkService,
                  downloadManager: this.downloadManager,
                  l10n: l10n
                });
              }
            }, {
              key: "getPagesOverview",
              value: function getPagesOverview() {
                var pagesOverview = this._pages.map(function (pageView) {
                  var viewport = pageView.pdfPage.getViewport({
                    scale: 1
                  });
                  return {
                    width: viewport.width,
                    height: viewport.height,
                    rotation: viewport.rotation
                  };
                });

                if (!this.enablePrintAutoRotate) {
                  return pagesOverview;
                }

                var isFirstPagePortrait = (0, _ui_utils.isPortraitOrientation)(pagesOverview[0]);
                return pagesOverview.map(function (size) {
                  if (isFirstPagePortrait === (0, _ui_utils.isPortraitOrientation)(size)) {
                    return size;
                  }

                  return {
                    width: size.height,
                    height: size.width,
                    rotation: (size.rotation + 90) % 360
                  };
                });
              }
            }, {
              key: "_updateScrollMode",
              value: function _updateScrollMode() {
                var pageNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                var scrollMode = this._scrollMode,
                    viewer = this.viewer;
                viewer.classList.toggle("scrollHorizontal", scrollMode === _ui_utils.ScrollMode.HORIZONTAL);
                viewer.classList.toggle("scrollWrapped", scrollMode === _ui_utils.ScrollMode.WRAPPED);

                if (!this.pdfDocument || !pageNumber) {
                  return;
                }

                if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
                  this._setScale(this._currentScaleValue, true);
                }

                this._setCurrentPageNumber(pageNumber, true);

                this.update();
              }
            }, {
              key: "_updateSpreadMode",
              value: function _updateSpreadMode() {
                var pageNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

                if (!this.pdfDocument) {
                  return;
                }

                var viewer = this.viewer,
                    pages = this._pages;
                viewer.textContent = "";

                if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
                  for (var i = 0, iMax = pages.length; i < iMax; ++i) {
                    viewer.appendChild(pages[i].div);
                  }
                } else {
                  var parity = this._spreadMode - 1;
                  var spread = null;

                  for (var _i11 = 0, _iMax = pages.length; _i11 < _iMax; ++_i11) {
                    if (spread === null) {
                      spread = document.createElement("div");
                      spread.className = "spread";
                      viewer.appendChild(spread);
                    } else if (_i11 % 2 === parity) {
                      spread = spread.cloneNode(false);
                      viewer.appendChild(spread);
                    }

                    spread.appendChild(pages[_i11].div);
                  }
                }

                if (!pageNumber) {
                  return;
                }

                this._setCurrentPageNumber(pageNumber, true);

                this.update();
              }
            }, {
              key: "pagesCount",
              get: function get() {
                return this._pages.length;
              }
            }, {
              key: "pageViewsReady",
              get: function get() {
                if (!this._pagesCapability.settled) {
                  return false;
                }

                return this._pages.every(function (pageView) {
                  return pageView && pageView.pdfPage;
                });
              }
            }, {
              key: "currentPageNumber",
              get: function get() {
                return this._currentPageNumber;
              },
              set: function set(val) {
                if (!Number.isInteger(val)) {
                  throw new Error("Invalid page number.");
                }

                if (!this.pdfDocument) {
                  return;
                }

                if (!this._setCurrentPageNumber(val, true)) {
                  console.error("".concat(this._name, ".currentPageNumber: \"").concat(val, "\" is not a valid page."));
                }
              }
            }, {
              key: "currentPageLabel",
              get: function get() {
                return this._pageLabels && this._pageLabels[this._currentPageNumber - 1];
              },
              set: function set(val) {
                if (!this.pdfDocument) {
                  return;
                }

                var page = val | 0;

                if (this._pageLabels) {
                  var i = this._pageLabels.indexOf(val);

                  if (i >= 0) {
                    page = i + 1;
                  }
                }

                if (!this._setCurrentPageNumber(page, true)) {
                  console.error("".concat(this._name, ".currentPageLabel: \"").concat(val, "\" is not a valid page."));
                }
              }
            }, {
              key: "currentScale",
              get: function get() {
                return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE;
              },
              set: function set(val) {
                if (isNaN(val)) {
                  throw new Error("Invalid numeric scale.");
                }

                if (!this.pdfDocument) {
                  return;
                }

                this._setScale(val, false);
              }
            }, {
              key: "currentScaleValue",
              get: function get() {
                return this._currentScaleValue;
              },
              set: function set(val) {
                if (!this.pdfDocument) {
                  return;
                }

                this._setScale(val, false);
              }
            }, {
              key: "pagesRotation",
              get: function get() {
                return this._pagesRotation;
              },
              set: function set(rotation) {
                if (!(0, _ui_utils.isValidRotation)(rotation)) {
                  throw new Error("Invalid pages rotation angle.");
                }

                if (!this.pdfDocument) {
                  return;
                }

                if (this._pagesRotation === rotation) {
                  return;
                }

                this._pagesRotation = rotation;
                var pageNumber = this._currentPageNumber;

                for (var i = 0, ii = this._pages.length; i < ii; i++) {
                  var pageView = this._pages[i];
                  pageView.update(pageView.scale, rotation);
                }

                if (this._currentScaleValue) {
                  this._setScale(this._currentScaleValue, true);
                }

                this.eventBus.dispatch("rotationchanging", {
                  source: this,
                  pagesRotation: rotation,
                  pageNumber: pageNumber
                });

                if (this.defaultRenderingQueue) {
                  this.update();
                }
              }
            }, {
              key: "firstPagePromise",
              get: function get() {
                return this.pdfDocument ? this._firstPageCapability.promise : null;
              }
            }, {
              key: "onePageRendered",
              get: function get() {
                return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
              }
            }, {
              key: "pagesPromise",
              get: function get() {
                return this.pdfDocument ? this._pagesCapability.promise : null;
              }
            }, {
              key: "_setDocumentViewerElement",
              get: function get() {
                throw new Error("Not implemented: _setDocumentViewerElement");
              }
            }, {
              key: "_isScrollModeHorizontal",
              get: function get() {
                return this.isInPresentationMode ? false : this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL;
              }
            }, {
              key: "isInPresentationMode",
              get: function get() {
                return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN;
              }
            }, {
              key: "isChangingPresentationMode",
              get: function get() {
                return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING;
              }
            }, {
              key: "isHorizontalScrollbarEnabled",
              get: function get() {
                return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth;
              }
            }, {
              key: "isVerticalScrollbarEnabled",
              get: function get() {
                return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight;
              }
            }, {
              key: "hasEqualPageSizes",
              get: function get() {
                var firstPageView = this._pages[0];

                for (var i = 1, ii = this._pages.length; i < ii; ++i) {
                  var pageView = this._pages[i];

                  if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {
                    return false;
                  }
                }

                return true;
              }
            }, {
              key: "scrollMode",
              get: function get() {
                return this._scrollMode;
              },
              set: function set(mode) {
                if (this._scrollMode === mode) {
                  return;
                }

                if (!(0, _ui_utils.isValidScrollMode)(mode)) {
                  throw new Error("Invalid scroll mode: ".concat(mode));
                }

                this._scrollMode = mode;
                this.eventBus.dispatch("scrollmodechanged", {
                  source: this,
                  mode: mode
                });

                this._updateScrollMode(this._currentPageNumber);
              }
            }, {
              key: "spreadMode",
              get: function get() {
                return this._spreadMode;
              },
              set: function set(mode) {
                if (this._spreadMode === mode) {
                  return;
                }

                if (!(0, _ui_utils.isValidSpreadMode)(mode)) {
                  throw new Error("Invalid spread mode: ".concat(mode));
                }

                this._spreadMode = mode;
                this.eventBus.dispatch("spreadmodechanged", {
                  source: this,
                  mode: mode
                });

                this._updateSpreadMode(this._currentPageNumber);
              }
            }]);

            return BaseViewer;
          }();

          exports.BaseViewer = BaseViewer;
          /***/
        },
        /* 17 */

        /***/
        function (module, exports, __w_pdfjs_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PDFViewer = void 0;

          var _base_viewer = __w_pdfjs_require__(16);

          var _pdfjsLib = __w_pdfjs_require__(2);

          var PDFViewer = /*#__PURE__*/function (_base_viewer$BaseView2) {
            _inherits(PDFViewer, _base_viewer$BaseView2);

            var _super39 = _createSuper(PDFViewer);

            function PDFViewer() {
              _classCallCheck(this, PDFViewer);

              return _super39.apply(this, arguments);
            }

            _createClass(PDFViewer, [{
              key: "_scrollIntoView",
              value: function _scrollIntoView(_ref58) {
                var pageDiv = _ref58.pageDiv,
                    _ref58$pageSpot = _ref58.pageSpot,
                    pageSpot = _ref58$pageSpot === void 0 ? null : _ref58$pageSpot,
                    _ref58$pageNumber = _ref58.pageNumber,
                    pageNumber = _ref58$pageNumber === void 0 ? null : _ref58$pageNumber;

                if (!pageSpot && !this.isInPresentationMode) {
                  var left = pageDiv.offsetLeft + pageDiv.clientLeft;
                  var right = left + pageDiv.clientWidth;
                  var _this$container = this.container,
                      scrollLeft = _this$container.scrollLeft,
                      clientWidth = _this$container.clientWidth;

                  if (this._isScrollModeHorizontal || left < scrollLeft || right > scrollLeft + clientWidth) {
                    pageSpot = {
                      left: 0,
                      top: 0
                    };
                  }
                }

                _get(_getPrototypeOf(PDFViewer.prototype), "_scrollIntoView", this).call(this, {
                  pageDiv: pageDiv,
                  pageSpot: pageSpot,
                  pageNumber: pageNumber
                });
              }
            }, {
              key: "_getVisiblePages",
              value: function _getVisiblePages() {
                if (this.isInPresentationMode) {
                  return this._getCurrentVisiblePage();
                }

                return _get(_getPrototypeOf(PDFViewer.prototype), "_getVisiblePages", this).call(this);
              }
            }, {
              key: "_updateHelper",
              value: function _updateHelper(visiblePages) {
                if (this.isInPresentationMode) {
                  return;
                }

                var currentId = this._currentPageNumber;
                var stillFullyVisible = false;

                var _iterator24 = _createForOfIteratorHelper(visiblePages),
                    _step24;

                try {
                  for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                    var page = _step24.value;

                    if (page.percent < 100) {
                      break;
                    }

                    if (page.id === currentId) {
                      stillFullyVisible = true;
                      break;
                    }
                  }
                } catch (err) {
                  _iterator24.e(err);
                } finally {
                  _iterator24.f();
                }

                if (!stillFullyVisible) {
                  currentId = visiblePages[0].id;
                }

                this._setCurrentPageNumber(currentId);
              }
            }, {
              key: "_setDocumentViewerElement",
              get: function get() {
                return (0, _pdfjsLib.shadow)(this, "_setDocumentViewerElement", this.viewer);
              }
            }]);

            return PDFViewer;
          }(_base_viewer.BaseViewer);

          exports.PDFViewer = PDFViewer;
          /***/
        }
        /******/
        ])
      );
    }); //# sourceMappingURL=pdf_viewer.js.map

    /***/

  },

  /***/
  "./node_modules/webpack/buildin/module.js":
  /*!***********************************!*\
    !*** (webpack)/buildin/module.js ***!
    \***********************************/

  /*! no static exports found */

  /***/
  function node_modulesWebpackBuildinModuleJs(module, exports) {
    module.exports = function (module) {
      if (!module.webpackPolyfill) {
        module.deprecate = function () {};

        module.paths = []; // module.parent = undefined by default

        if (!module.children) module.children = [];
        Object.defineProperty(module, "loaded", {
          enumerable: true,
          get: function get() {
            return module.l;
          }
        });
        Object.defineProperty(module, "id", {
          enumerable: true,
          get: function get() {
            return module.i;
          }
        });
        module.webpackPolyfill = 1;
      }

      return module;
    };
    /***/

  },

  /***/
  "./src/app/_models/candidate/allIndustries.ts":
  /*!****************************************************!*\
    !*** ./src/app/_models/candidate/allIndustries.ts ***!
    \****************************************************/

  /*! exports provided: AllIndustries */

  /***/
  function srcApp_modelsCandidateAllIndustriesTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AllIndustries", function () {
      return AllIndustries;
    });

    var AllIndustries = function AllIndustries() {
      _classCallCheck(this, AllIndustries);
    };
    /***/

  },

  /***/
  "./src/app/_models/candidate/allJobTypes.ts":
  /*!**************************************************!*\
    !*** ./src/app/_models/candidate/allJobTypes.ts ***!
    \**************************************************/

  /*! exports provided: AllJobTypes */

  /***/
  function srcApp_modelsCandidateAllJobTypesTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AllJobTypes", function () {
      return AllJobTypes;
    });

    var AllJobTypes = function AllJobTypes() {
      _classCallCheck(this, AllJobTypes);
    };
    /***/

  },

  /***/
  "./src/app/_models/candidateProfile.ts":
  /*!*********************************************!*\
    !*** ./src/app/_models/candidateProfile.ts ***!
    \*********************************************/

  /*! exports provided: CandidateProfile */

  /***/
  function srcApp_modelsCandidateProfileTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CandidateProfile", function () {
      return CandidateProfile;
    });

    var CandidateProfile = function CandidateProfile() {
      _classCallCheck(this, CandidateProfile);
    };
    /***/

  },

  /***/
  "./src/app/_services/candidate/crawled-joblist.service.ts":
  /*!****************************************************************!*\
    !*** ./src/app/_services/candidate/crawled-joblist.service.ts ***!
    \****************************************************************/

  /*! exports provided: CrawledJoblistService */

  /***/
  function srcApp_servicesCandidateCrawledJoblistServiceTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CrawledJoblistService", function () {
      return CrawledJoblistService;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _angular_common_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/common/http */
    "./node_modules/@angular/common/__ivy_ngcc__/fesm2015/http.js");

    var CrawledJoblistService = /*#__PURE__*/function () {
      function CrawledJoblistService(http) {
        _classCallCheck(this, CrawledJoblistService);

        this.http = http;
        this.crawledJobPostURL = 'http://localhost:8080/home/otherwebsites/alljobposts';
        this.getAllIndustryURL = 'http://localhost:8080/candidate/industries';
      }

      _createClass(CrawledJoblistService, [{
        key: "getCrawledJobPost",
        value: function getCrawledJobPost(websitename) {
          return this.http.get("".concat(this.crawledJobPostURL, "/").concat(websitename));
        }
      }, {
        key: "getOtherWebs",
        value: function getOtherWebs(websitename, pageNo) {
          return this.http.get("".concat(this.crawledJobPostURL, "/").concat(websitename) + '?pageNo=' + pageNo);
        }
      }, {
        key: "getAllIndustries",
        value: function getAllIndustries() {
          return this.http.get("".concat(this.getAllIndustryURL));
        }
      }]);

      return CrawledJoblistService;
    }();

    CrawledJoblistService.ɵfac = function CrawledJoblistService_Factory(t) {
      return new (t || CrawledJoblistService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common_http__WEBPACK_IMPORTED_MODULE_1__["HttpClient"]));
    };

    CrawledJoblistService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
      token: CrawledJoblistService,
      factory: CrawledJoblistService.ɵfac,
      providedIn: 'root'
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CrawledJoblistService, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"],
        args: [{
          providedIn: 'root'
        }]
      }], function () {
        return [{
          type: _angular_common_http__WEBPACK_IMPORTED_MODULE_1__["HttpClient"]
        }];
      }, null);
    })();
    /***/

  },

  /***/
  "./src/app/_services/candidate/user-account.service.ts":
  /*!*************************************************************!*\
    !*** ./src/app/_services/candidate/user-account.service.ts ***!
    \*************************************************************/

  /*! exports provided: UserAccountService */

  /***/
  function srcApp_servicesCandidateUserAccountServiceTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UserAccountService", function () {
      return UserAccountService;
    });
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _angular_common_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/common/http */
    "./node_modules/@angular/common/__ivy_ngcc__/fesm2015/http.js");

    var UserAccountService = /*#__PURE__*/function () {
      function UserAccountService(http) {
        _classCallCheck(this, UserAccountService);

        this.http = http;
        this.getProfileurl = 'http://localhost:8080/candidate/myprofile';
        this.createExperienceURL = 'http://localhost:8080/candidate/myprofile/addExperience';
        this.deleteExperienceURL = 'http://localhost:8080/candidate/myprofile/experience/remove';
        this.createEducationURL = 'http://localhost:8080/candidate/myprofile/addEducation';
        this.deleteEducationURL = 'http://localhost:8080/candidate/myprofile/education/remove';
        this.updateProfileURL = 'http://localhost:8080/candidate/myprofile';
        this.getJobTypeURL = 'http://localhost:8080/candidate/jobtypes';
      }

      _createClass(UserAccountService, [{
        key: "getJobTypes",
        value: function getJobTypes() {
          return this.http.get("".concat(this.getJobTypeURL));
        }
      }, {
        key: "getAccounts",
        value: function getAccounts() {
          return this.http.get("".concat(this.getProfileurl));
        }
      }, {
        key: "deleteExperience",
        value: function deleteExperience(id) {
          return this.http["delete"]("".concat(this.deleteExperienceURL, "/").concat(id), {
            responseType: 'text'
          });
        }
      }, {
        key: "deleteEducation",
        value: function deleteEducation(id) {
          return this.http["delete"]("".concat(this.deleteEducationURL, "/").concat(id), {
            responseType: 'text'
          });
        }
      }, {
        key: "createExperience",
        value: function createExperience(ex) {
          return this.http.post("".concat(this.createExperienceURL), ex, {
            responseType: 'text'
          });
        } // updateExperience(id: number, value: any): Observable<Object> {
        //   return this.http.put(`${this.updateurl}/${id}`, value);
        // }

      }, {
        key: "createEducation",
        value: function createEducation(edu) {
          return this.http.post("".concat(this.createEducationURL), edu, {
            responseType: 'text'
          });
        }
      }, {
        key: "updateProfile",
        value: function updateProfile(value) {
          return this.http.put("".concat(this.updateProfileURL), value, {
            responseType: 'text'
          });
        }
      }]);

      return UserAccountService;
    }();

    UserAccountService.ɵfac = function UserAccountService_Factory(t) {
      return new (t || UserAccountService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common_http__WEBPACK_IMPORTED_MODULE_1__["HttpClient"]));
    };

    UserAccountService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
      token: UserAccountService,
      factory: UserAccountService.ɵfac,
      providedIn: 'root'
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](UserAccountService, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"],
        args: [{
          providedIn: 'root'
        }]
      }], function () {
        return [{
          type: _angular_common_http__WEBPACK_IMPORTED_MODULE_1__["HttpClient"]
        }];
      }, null);
    })();
    /***/

  },

  /***/
  4:
  /*!**********************!*\
    !*** zlib (ignored) ***!
    \**********************/

  /*! no static exports found */

  /***/
  function _(module, exports) {
    /* (ignored) */

    /***/
  },

  /***/
  5:
  /*!********************!*\
    !*** fs (ignored) ***!
    \********************/

  /*! no static exports found */

  /***/
  function _(module, exports) {
    /* (ignored) */

    /***/
  },

  /***/
  6:
  /*!**********************!*\
    !*** http (ignored) ***!
    \**********************/

  /*! no static exports found */

  /***/
  function _(module, exports) {
    /* (ignored) */

    /***/
  },

  /***/
  7:
  /*!***********************!*\
    !*** https (ignored) ***!
    \***********************/

  /*! no static exports found */

  /***/
  function _(module, exports) {
    /* (ignored) */

    /***/
  },

  /***/
  8:
  /*!*********************!*\
    !*** url (ignored) ***!
    \*********************/

  /*! no static exports found */

  /***/
  function _(module, exports) {
    /* (ignored) */

    /***/
  }
}]);
//# sourceMappingURL=default~components-candidate-candidate-module~components-employer-employer-module-es5.js.map